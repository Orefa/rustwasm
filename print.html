<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust and WebAssembly</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="why-rust-and-webassembly.html"><strong aria-hidden="true">2.</strong> 为什么是Rust和WebAssembly?</a></li><li class="chapter-item expanded "><a href="background-and-concepts.html"><strong aria-hidden="true">3.</strong> 背景和概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-webassembly.html"><strong aria-hidden="true">3.1.</strong> 什么是WebAssembly?</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="game-of-life/introduction.html"><strong aria-hidden="true">4.</strong> 教程 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="game-of-life/setup.html"><strong aria-hidden="true">4.1.</strong> 设置</a></li><li class="chapter-item expanded "><a href="game-of-life/hello-world.html"><strong aria-hidden="true">4.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="game-of-life/rules.html"><strong aria-hidden="true">4.3.</strong> 规则</a></li><li class="chapter-item expanded "><a href="game-of-life/implementing.html"><strong aria-hidden="true">4.4.</strong> 实现康威的生命游戏</a></li><li class="chapter-item expanded "><a href="game-of-life/testing.html"><strong aria-hidden="true">4.5.</strong> 测试康威的生命游戏</a></li><li class="chapter-item expanded "><a href="game-of-life/debugging.html"><strong aria-hidden="true">4.6.</strong> 调试</a></li><li class="chapter-item expanded "><a href="game-of-life/interactivity.html"><strong aria-hidden="true">4.7.</strong> 添加交互性</a></li><li class="chapter-item expanded "><a href="game-of-life/time-profiling.html"><strong aria-hidden="true">4.8.</strong> 时间分析</a></li><li class="chapter-item expanded "><a href="game-of-life/code-size.html"><strong aria-hidden="true">4.9.</strong> 缩小.wasm 大小</a></li><li class="chapter-item expanded "><a href="game-of-life/publishing-to-npm.html"><strong aria-hidden="true">4.10.</strong> 发布到 npm</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">5.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/crates.html"><strong aria-hidden="true">5.1.</strong> 你应该知道的Crates</a></li><li class="chapter-item expanded "><a href="reference/tools.html"><strong aria-hidden="true">5.2.</strong> 你应该知道的工具</a></li><li class="chapter-item expanded "><a href="reference/project-templates.html"><strong aria-hidden="true">5.3.</strong> 项目模板</a></li><li class="chapter-item expanded "><a href="reference/debugging.html"><strong aria-hidden="true">5.4.</strong> 调试</a></li><li class="chapter-item expanded "><a href="reference/time-profiling.html"><strong aria-hidden="true">5.5.</strong> 时间分析</a></li><li class="chapter-item expanded "><a href="reference/code-size.html"><strong aria-hidden="true">5.6.</strong> Shrinking .wasm Size</a></li><li class="chapter-item expanded "><a href="reference/js-ffi.html"><strong aria-hidden="true">5.7.</strong> JavaScript Interoperation</a></li><li class="chapter-item expanded "><a href="reference/which-crates-work-with-wasm.html"><strong aria-hidden="true">5.8.</strong> Which Crates Will Work Off-the-Shelf with WebAssembly?</a></li><li class="chapter-item expanded "><a href="reference/add-wasm-support-to-crate.html"><strong aria-hidden="true">5.9.</strong> How to Add WebAssembly Support to a General-Purpose Crate</a></li><li class="chapter-item expanded "><a href="reference/deploying-to-production.html"><strong aria-hidden="true">5.10.</strong> Deploying Rust and WebAssembly to Production</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust and WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust--and-webassembly-"><a class="header" href="#rust--and-webassembly-">Rust 🦀 and WebAssembly 🕸</a></h1>
<p>这本小书描述了如何将<a href="https://www.rust-lang.org">Rust</a>和<a href="https://webassembly.org/">WebAssembly</a>一起使用。</p>
<h2 id="这本书是为谁写的"><a class="header" href="#这本书是为谁写的">这本书是为谁写的?</a></h2>
<p>本书是为那些对将Rust编译成 WebAssembly 以实现快速、可靠的网络代码感兴趣的人编写的。汇编成WebAssembly，以便在网络上获得快速可靠的代码。你应该了解一些Rust，并熟悉 JavaScript，HTML，和 CSS。你不需要成为其中任何一个方面的专家。</p>
<p>还不了解Rust吗？ <a href="https://doc.rust-lang.org/book/">先从 <em>The Rust Programming Language</em> 开始</a></p>
<p>不懂JavaScript、HTML或CSS？<a href="https://developer.mozilla.org/en-US/docs/Learn">在MDN上了解他们的情况</a></p>
<h2 id="如何阅读此书"><a class="header" href="#如何阅读此书">如何阅读此书</a></h2>
<p>你应该先阅读<a href="./why-rust-and-webassembly.html">一起使用Rust和WebAssembly的动机</a>，以及熟悉<a href="./background-and-concepts.html">背景和概念</a>。</p>
<p><a href="./game-of-life/introduction.html">教程</a>是为了从头到尾阅读而写的。你应该跟随：自己编写、编译和运行教程中的代码。如果你以前没有一起使用过Rust和WebAssembly，那就从教程开始吧!</p>
<p><a href="./reference/index.html">参考章节</a> 可以按任何顺序进行阅读。</p>
<blockquote>
<p><strong>💡 Tip:</strong> 你可以通过点击页面上面的搜索 🔍 图标或按下 <code>s</code> 键 进行搜索</p>
</blockquote>
<h2 id="参与完善本书"><a class="header" href="#参与完善本书">参与完善本书</a></h2>
<p>这本书是开放源代码的! 发现一个错别字？我们是否忽略了什么？</p>
<ul>
<li>中文版本: <a href="https://github.com/Orefa/rustwasm"><strong>Send us a pull request!</strong></a></li>
<li>英文版本: <a href="https://github.com/rustwasm/book"><strong>Send us a pull request!</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为什么是rust和webassembly"><a class="header" href="#为什么是rust和webassembly">为什么是Rust和WebAssembly?</a></h1>
<h2 id="低水平控制与高水平的人机工程学"><a class="header" href="#低水平控制与高水平的人机工程学">低水平控制与高水平的人机工程学</a></h2>
<p>JavaScript网络应用程序很难达到并保持可靠的性能。JavaScript的动态类型系统和垃圾收集的暂停并没有帮助。看似很小的代码改动，如果你不小心偏离了JIT的快乐路径，就会导致性能的急剧下降。你不小心偏离了JIT的快乐路径。</p>
<p>Rust 为程序员提供了低级控制和可靠的性能。 它没有困扰 JavaScript 的非确定性垃圾收集暂停。 程序员可以控制间接、单态化和内存布局。 </p>
<h2 id="小的-wasm-尺寸"><a class="header" href="#小的-wasm-尺寸">小的 <code>.wasm</code> 尺寸</a></h2>
<p>代码大小非常重要，因为 <code>.wasm</code> 必须通过网络下载。 Rust 缺少运行时，支持较小的 <code>.wasm</code> 大小，因为没有像垃圾收集器那样包含额外的膨胀。 您只需为实际使用的功能付费（按代码大小）。 </p>
<h2 id="不需要-重写一切"><a class="header" href="#不需要-重写一切"><em>不需要</em> 重写一切</a></h2>
<p>不需要丢弃现有的代码库。 您可以首先将您对性能最敏感的 JavaScript 函数移植到 Rust，以获得直接的好处。 如果您愿意，你甚至可以到此为止。 </p>
<h2 id="与其程序可以很好的结合"><a class="header" href="#与其程序可以很好的结合">与其程序可以很好的结合</a></h2>
<p>Rust 和 WebAssembly 与现有的 JavaScript 工具集成。它支持 ECMAScript 模块，你可以继续使用你已经喜欢的工具，如 npm 和 Webpack。</p>
<h2 id="您期待的便利设施"><a class="header" href="#您期待的便利设施">您期待的便利设施</a></h2>
<p>Rust 拥有开发人员所期望的现代设施，例如： </p>
<ul>
<li>
<p>强大的包管理  <code>cargo</code>,</p>
</li>
<li>
<p>富有表现力（和零成本）的抽象， </p>
</li>
<li>
<p>和一个热情的社区！ 😊</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="背景和概念"><a class="header" href="#背景和概念">背景和概念</a></h1>
<p>本节提供了进入 Rust 和 WebAssembly 的必要背景。开发的必要背景。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是webassembly"><a class="header" href="#什么是webassembly">什么是WebAssembly?</a></h1>
<p>WebAssembly(wasm)是一种简单的机器模型和可执行格式，有一个<a href="https://webassembly.github.io/spec/">广泛的规范</a>。它被设计成可移植、紧凑，并以或接近原生速度执行。</p>
<p>作为一种编程语言，WebAssembly是由两种格式组成的。表示相同的结构，只是方式不同而已：</p>
<ol>
<li><code>.wat</code> 文本格式（称为<code>wat</code>，表示 &quot;<strong>W</strong>eb<strong>A</strong>ssembly <strong>T</strong>ext&quot;）使用 <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a>，与 Lisp 系列语言有一些相似之处  像 Scheme 和 Clojure。</li>
<li><code>.wasm</code> 二进制格式是较低级的，目的是让 wasm 虚拟机直接使用。它在概念上类似于 ELF 和 Mach-O</li>
</ol>
<p>作为参考，这里有一个阶乘函数，在 <code>wat</code>:</p>
<pre><code>(module
  (func $fac (param f64) (result f64)
    local.get 0
    f64.const 1
    f64.lt
    if (result f64)
      f64.const 1
    else
      local.get 0
      local.get 0
      f64.const 1
      f64.sub
      call $fac
      f64.mul
    end)
  (export &quot;fac&quot; (func $fac)))
</code></pre>
<p>如果您对 <code>wasm</code> 文件的外观感到好奇，可以将 <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">wat2wasm demo</a> 与上述代码一起使用。 </p>
<h2 id="线性内存"><a class="header" href="#线性内存">线性内存</a></h2>
<p>WebAssembly有一个非常简单的<a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem">内存模型</a>。一个wasm模块可以访问一个单一的 &quot;线性内存&quot;，这基本上是一个字节的平面阵列。这个[内存可以按页面大小（64K）的倍数增长。它不能被缩小。</p>
<h2 id="webassembly-只是用于-web-吗"><a class="header" href="#webassembly-只是用于-web-吗">WebAssembly 只是用于 Web 吗？</a></h2>
<p>尽管它目前在 JavaScript 和 Web 社区中普遍受到关注，但 wasm 对其主机环境不做任何假设。因此，推测 wasm 将成为一种 &quot;可移植的可执行 &quot;格式，在未来被用于各种情况下是有意义的。然而，截至<em>今天</em>，wasm 主要与JavaScript（JS）有关，而 JavaScrip t有很多种类（包括 Web 和<a href="https://nodejs.org">Node.js</a>上的）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="教程-康威生命游戏"><a class="header" href="#教程-康威生命游戏">教程: 康威生命游戏</a></h1>
<p>这是一个用 Rust 和 WebAssembly 实现<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">康威生命游戏</a>的教程。</p>
<h2 id="这个教程是为谁准备的"><a class="header" href="#这个教程是为谁准备的">这个教程是为谁准备的？</a></h2>
<p>本教程适用于已经有基本 Rust 和 JavaScript 经验的人，并希望学习如何一起使用 Rust、WebAssembly 和 JavaScript。</p>
<p>你应该能够自如地阅读和编写基本的Rust、JavaScript 和 HTML。你绝对不需要是一个专家。</p>
<h2 id="我将学到什么"><a class="header" href="#我将学到什么">我将学到什么？</a></h2>
<ul>
<li>
<p>如何设置Rust工具链以编译成WebAssembly。</p>
</li>
<li>
<p>一个用于开发由Rust、WebAssembly、JavaScript、HTML和CSS组成的多语言程序的工作流程。</p>
</li>
<li>
<p>如何设计 API 以最大限度地利用 Rust 和 WebAssembly 的优势，同时也是 JavaScript 的优势。</p>
</li>
<li>
<p>如何调试由Rust编译的WebAssembly模块。</p>
</li>
<li>
<p>如何对Rust和WebAssembly程序进行时间剖析以使其更快。</p>
</li>
<li>
<p>如何确定 Rust 和 WebAssembly 程序的大小，使<code>.wasm</code>二进制文件更小，更快通过网络下载。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设置"><a class="header" href="#设置">设置</a></h1>
<p>本节描述了如何设置工具链，将 Rust 程序编译为 WebAssembly，并将其集成到 JavaScript 中。到 WebAssembly，并将其集成到 JavaScript 中。</p>
<h2 id="rust-工具链"><a class="header" href="#rust-工具链">Rust 工具链</a></h2>
<p>你将需要标准的 Rust 工具链，包括 <code>rustup</code>, <code>rustc</code>, 和 <code>cargo</code>.</p>
<p><a href="https://www.rust-lang.org/tools/install">按照这些说明来安装Rust工具链。</a></p>
<p>Rust 和 WebAssembly 的经验是乘着 Rust 发布的列车到了稳定期! 这意味着我们不需要任何实验性功能标志。然而，我们确实 需要 Rust 1.30 或更新版本。</p>
<h2 id="wasm-pack"><a class="header" href="#wasm-pack"><code>wasm-pack</code></a></h2>
<p><code>wasm-pack</code> 是您构建、测试和发布 Rust 生成的 WebAssembly 的一站式商店。 </p>
<p><a href="https://rustwasm.github.io/wasm-pack/installer/">Get <code>wasm-pack</code> here!</a></p>
<h2 id="cargo-generate"><a class="header" href="#cargo-generate"><code>cargo-generate</code></a></h2>
<p><a href="https://github.com/ashleygwilliams/cargo-generate"><code>cargo-generate</code> 通过利用预先存在的 git 存储库作为模板，帮助您快速启动并运行新的 Rust 项目。</a></p>
<p>使用如下命令安装 <code>cargo-generate</code>:</p>
<pre><code>cargo install cargo-generate
</code></pre>
<h2 id="npm"><a class="header" href="#npm"><code>npm</code></a></h2>
<p><code>npm</code> 是 JavaScript 的包管理器。 我们将使用它来安装和运行 JavaScript 打包器和开发服务器。 在教程结束时，我们将把我们编译的 <code>.wasm</code> 发布到 <code>npm</code> 仓库。 </p>
<p><a href="https://www.npmjs.com/get-npm">按照这些说明进行安装 <code>npm</code>.</a></p>
<p>如果您已经安装了 <code>npm</code>，请使用以下命令确保它是最新的： </p>
<pre><code>npm install npm@latest -g
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p>本节将告诉你如何构建和运行你的第一个 Rust 和 WebAssembly 的程序：一个提醒 &quot;Hello, World!&quot; 的网页。</p>
<p>在开始之前，请确保你已经遵循了<a href="game-of-life/setup.html">设置说明</a>。</p>
<h2 id="克隆项目模板"><a class="header" href="#克隆项目模板">克隆项目模板</a></h2>
<p>该项目模板预先配置了合理的默认值，因此你可以快速构建、集成和打包你的代码用于 Web。</p>
<p>用这个命令克隆项目模板:</p>
<pre><code class="language-text">cargo generate --git https://github.com/rustwasm/wasm-pack-template
</code></pre>
<p>这将提示你新项目的名称。我们将使用 <strong>&quot;wasm-game-of-life&quot;</strong>.</p>
<pre><code class="language-text">wasm-game-of-life
</code></pre>
<h2 id="里面有什么"><a class="header" href="#里面有什么">里面有什么</a></h2>
<p>进入新的 <code>wasm-game-of-life</code> 项目</p>
<pre><code>cd wasm-game-of-life
</code></pre>
<p>并让我们看看它的内容。</p>
<pre><code class="language-text">wasm-game-of-life/
├── Cargo.toml
├── LICENSE_APACHE
├── LICENSE_MIT
├── README.md
└── src
    ├── lib.rs
    └── utils.rs
</code></pre>
<p>让我们详细看一下其中的几个文件。 </p>
<h3 id="wasm-game-of-lifecargotoml"><a class="header" href="#wasm-game-of-lifecargotoml"><code>wasm-game-of-life/Cargo.toml</code></a></h3>
<p><code>Cargo.toml</code> 文件为 <code>cargo</code>、Rust 的包管理器和构建工具指定依赖项和元数据。 这个预先配置了一个 <code>wasm-bindgen</code> 依赖项，一些我们稍后将深入研究的可选依赖项，以及正确初始化的 <code>crate-type</code> 以生成 <code>.wasm</code> 库。 </p>
<h3 id="wasm-game-of-lifesrclibrs"><a class="header" href="#wasm-game-of-lifesrclibrs"><code>wasm-game-of-life/src/lib.rs</code></a></h3>
<p><code>src/lib.rs</code> 文件是我们正在编译为 WebAssembly 的 Rust crate 的根目录。 它使用 <code>wasm-bindgen</code> 与 JavaScript 交互。 它导入了 <code>window.alert</code> JavaScript 函数，并导出了 <code>greet</code> Rust 函数，它会提醒一条问候消息。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod utils;

use wasm_bindgen::prelude::*;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = &quot;wee_alloc&quot;)]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet() {
    alert(&quot;Hello, wasm-game-of-life!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="wasm-game-of-lifesrcutilsrs"><a class="header" href="#wasm-game-of-lifesrcutilsrs"><code>wasm-game-of-life/src/utils.rs</code></a></h3>
<p><code>src/utils.rs</code> 模块提供了一些通用的工具来让 Rust 编译成 WebAssembly 变得更容易。 我们将在本教程后面更详细地了解其中一些实用程序，例如当我们查看 <a href="game-of-life/debugging.html">调试我们的 wasm 代码</a> 时，但我们现在可以忽略此文件。 </p>
<h2 id="构建项目"><a class="header" href="#构建项目">构建项目</a></h2>
<p>我们使用 <code>wasm-pack</code> 来编排以下构建步骤： </p>
<ul>
<li>确保我们有 Rust 1.30 或更新版本，并且通过 <code>rustup</code> 安装了 <code>wasm32-unknown-unknown</code> 目标，</li>
<li>通过 <code>cargo</code> 将我们的 Rust 源编译为 WebAssembly <code>.wasm</code> 二进制文件，</li>
<li>使用 <code>wasm-bindgen</code> 生成 JavaScript API，以便使用我们的 Rust 生成的 WebAssembly。 </li>
</ul>
<p>要做到这一切，在项目目录内运行这个命令。</p>
<pre><code>wasm-pack build
</code></pre>
<p>构建完成后，我们可以在 <code>pkg</code> 目录中找到它的工件，它应该有以下内容： </p>
<pre><code>pkg/
├── package.json
├── README.md
├── wasm_game_of_life_bg.wasm
├── wasm_game_of_life.d.ts
└── wasm_game_of_life.js
</code></pre>
<p><code>README.md</code> 文件是从主项目复制的，但其他文件是全新的。 </p>
<h3 id="wasm-game-of-lifepkgwasm_game_of_life_bgwasm"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_life_bgwasm"><code>wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm</code></a></h3>
<p><code>.wasm</code> 文件是由 Rust 编译器从我们的 Rust 源代码生成的 WebAssembly 二进制文件。 它包含我们所有 Rust 函数和数据的编译到 wasm 版本。 例如，它有一个导出的“问候”功能。 </p>
<h3 id="wasm-game-of-lifepkgwasm_game_of_lifejs"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_lifejs"><code>wasm-game-of-life/pkg/wasm_game_of_life.js</code></a></h3>
<p><code>.js</code> 文件由 <code>wasm-bindgen</code> 生成，包含用于将 DOM 和 JavaScript 函数导入 Rust 并将 WebAssembly 函数的良好 API 暴露给 JavaScript 的 JavaScript 胶水。 例如，有一个 JavaScript 的 <code>greet</code> 函数包装了从 WebAssembly 模块导出的 <code>greet</code> 函数。 现在，这种粘合剂并没有做太多事情，但是当我们开始在 wasm 和 JavaScript 之间来回传递更多有趣的值时，它将帮助引导这些值跨越边界。 </p>
<pre><code class="language-js">import * as wasm from './wasm_game_of_life_bg';

// ...

export function greet() {
    return wasm.greet();
}
</code></pre>
<h3 id="wasm-game-of-lifepkgwasm_game_of_lifedts"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_lifedts"><code>wasm-game-of-life/pkg/wasm_game_of_life.d.ts</code></a></h3>
<p><code>.d.ts</code> 文件包含 JavaScript 胶水的 <a href="http://www.typescriptlang.org/">TypeScript</a> 类型声明。 如果您使用的是 TypeScript，您可以检查对 WebAssembly 函数的调用类型，并且您的 IDE 可以提供自动完成和建议！ 如果您不使用 TypeScript，则可以放心地忽略此文件。 </p>
<pre><code class="language-typescript">export function greet(): void;
</code></pre>
<h3 id="wasm-game-of-lifepkgpackagejson"><a class="header" href="#wasm-game-of-lifepkgpackagejson"><code>wasm-game-of-life/pkg/package.json</code></a></h3>
<p><a href="https://docs.npmjs.com/files/package.json"><code>package.json</code> 文件包含有关生成的 JavaScript 和 WebAssembly 包的元数据。</a> npm 和 JavaScript 捆绑器使用它来确定包之间的依赖关系、包名称、版本和一堆其他东西。 它帮助我们与 JavaScript 工具集成，并允许我们将我们的包发布到 npm。 </p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;wasm-game-of-life&quot;,
  &quot;collaborators&quot;: [
    &quot;Your Name &lt;your.email@example.com&gt;&quot;
  ],
  &quot;description&quot;: null,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;license&quot;: null,
  &quot;repository&quot;: null,
  &quot;files&quot;: [
    &quot;wasm_game_of_life_bg.wasm&quot;,
    &quot;wasm_game_of_life.d.ts&quot;
  ],
  &quot;main&quot;: &quot;wasm_game_of_life.js&quot;,
  &quot;types&quot;: &quot;wasm_game_of_life.d.ts&quot;
}
</code></pre>
<h2 id="将其放入网页"><a class="header" href="#将其放入网页">将其放入网页</a></h2>
<p>为了获取我们的 <code>wasm-game-of-life</code> 包并在网页中使用它，我们使用 <a href="https://github.com/rustwasm/create-wasm-app"><code>create-wasm-app</code> JavaScript 项目模板</a>。 </p>
<p>在 <code>wasm-game-of-life</code> 目录中运行此命令： </p>
<pre><code>npm init wasm-app www
</code></pre>
<p>这是我们新的 <code>wasm-game-of-life/www</code> 子目录包含的内容： </p>
<pre><code>wasm-game-of-life/www/
├── bootstrap.js
├── index.html
├── index.js
├── LICENSE-APACHE
├── LICENSE-MIT
├── package.json
├── README.md
└── webpack.config.js
</code></pre>
<p>再一次，让我们仔细看看其中的一些文件。 </p>
<h3 id="wasm-game-of-lifewwwpackagejson"><a class="header" href="#wasm-game-of-lifewwwpackagejson"><code>wasm-game-of-life/www/package.json</code></a></h3>
<p>这个 <code>package.json</code> 预先配置了 <code>webpack</code> 和 <code>webpack-dev-server</code> 依赖，以及对 <code>hello-wasm-pack</code> 的依赖，它是已发布到 npm 的 <code>wasm-pack-template</code> 包。 </p>
<h3 id="wasm-game-of-lifewwwwebpackconfigjs"><a class="header" href="#wasm-game-of-lifewwwwebpackconfigjs"><code>wasm-game-of-life/www/webpack.config.js</code></a></h3>
<p>此文件配置 webpack 及其本地开发服务器。 它是预先配置的，你根本不需要调整它来让 webpack 和它的本地开发服务器工作。 </p>
<h3 id="wasm-game-of-lifewwwindexhtml"><a class="header" href="#wasm-game-of-lifewwwindexhtml"><code>wasm-game-of-life/www/index.html</code></a></h3>
<p>这是网页的根 HTML 文件。 除了加载 <code>bootstrap.js </code>之外，它没有做太多事情，<code>bootstrap.js</code> 是一个非常薄的 <code>index.js</code> 包装器。 </p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello wasm-pack!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;./bootstrap.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="wasm-game-of-lifewwwindexjs"><a class="header" href="#wasm-game-of-lifewwwindexjs"><code>wasm-game-of-life/www/index.js</code></a></h3>
<p><code>index.js</code> 是我们网页的 JavaScript 的主要入口点。 它导入 <code>hello-wasm-pack</code> npm 包，其中包含默认的 <code>wasm-pack-template</code> 编译的 WebAssembly 和 JavaScript 胶水，然后调用 <code>hello-wasm-pack</code> 的 <code>greet</code> 函数。 </p>
<pre><code class="language-js">import * as wasm from &quot;hello-wasm-pack&quot;;

wasm.greet();
</code></pre>
<h3 id="安装依赖项"><a class="header" href="#安装依赖项">安装依赖项</a></h3>
<p>首先，通过在 <code>wasm-game-of-life/www</code> 子目录中运行 <code>npm install</code> 来确保本地开发服务器及其依赖项已安装： </p>
<pre><code class="language-text">npm install
</code></pre>
<p>这个命令只需要运行一次，就会安装<code>webpack</code> JavaScript bundler 和它的开发服务器。</p>
<blockquote>
<p>请注意，使用 Rust 和 WebAssembly 不需要 <code>webpack</code>，
这里它只是我们为了方便而选择的打包器和开发服务器
Parcel 和 Rollup 还应该支持将 WebAssembly 导入为 ECMAScript 模块
你也可以使用 Rust 和 WebAssembly <a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html">没有捆绑器</a> 如果你愿意！ </p>
</blockquote>
<h3 id="在-www-中使用我们本地的-wasm-game-of-life-包"><a class="header" href="#在-www-中使用我们本地的-wasm-game-of-life-包">在 <code>www</code> 中使用我们本地的 <code>wasm-game-of-life</code> 包</a></h3>
<p>我们不想使用 npm 中的 <code>hello-wasm-pack</code> 包，而是想使用我们本地的 <code>wasm-game-of-life</code> 包。 这将使我们能够逐步开发我们的生命游戏程序。</p>
<p>打开 <code>wasm-game-of-life/www/package.json</code> 并在 <code>&quot;devDependencies&quot;</code> 旁边添加 <code>&quot;dependencies&quot;</code> 字段，包括一个 <code>&quot;wasm-game-of-life&quot;: &quot;file :../pkg&quot;</code> 条目： </p>
<pre><code class="language-js">{
  // ...
  &quot;dependencies&quot;: {                     // Add this three lines block!
    &quot;wasm-game-of-life&quot;: &quot;file:../pkg&quot;
  },
  &quot;devDependencies&quot;: {
    //...
  }
}
</code></pre>
<p>接下来，修改 <code>wasm-game-of-life/www/index.js</code> 以导入 <code>wasm-game-of-life</code> 而不是 <code>hello-wasm-pack</code> 包： </p>
<pre><code class="language-js">import * as wasm from &quot;wasm-game-of-life&quot;;

wasm.greet();
</code></pre>
<p>由于我们声明了一个新的依赖项，我们需要安装它：</p>
<pre><code class="language-text">npm install
</code></pre>
<p>我们的网页现在可以在本地提供服务了！ </p>
<h2 id="本地服务"><a class="header" href="#本地服务">本地服务</a></h2>
<p>接下来，为开发服务器打开一个新终端。 在新终端中运行服务器让我们让它在后台运行，同时不会阻止我们运行其他命令。 在新终端中，从 <code>wasm-game-of-life/www</code> 目录中运行以下命令： </p>
<pre><code>npm run start
</code></pre>
<p>将您的 Web 浏览器导航到 <a href="http://localhost:8080/">http://localhost:8080/</a>，您应该会看到一条警告消息： </p>
<p><a href="game-of-life/../images/game-of-life/hello-world.png"><img src="game-of-life/../images/game-of-life/hello-world.png" alt="Screenshot of the &quot;Hello, wasm-game-of-life!&quot; Web page alert" /></a></p>
<p>任何时候进行更改并希望它们反映在 <a href="http://localhost:8080/">http://localhost:8080/</a> 上，只需在 <code>wasm-game-of-life</code> 目录中运行 <code>wasm-pack build</code> 命令.</p>
<p>Anytime you make changes and want them reflected on
<a href="http://localhost:8080/">http://localhost:8080/</a>, just re-run the <code>wasm-pack build</code> command within the <code>wasm-game-of-life</code> directory.</p>
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<ul>
<li>
<p>修改 <code>wasm-game-of-life/src/lib.rs</code> 中的 <code>greet</code> 函数，采用 <code>name: &amp;str</code> 参数来自定义警报消息，并将你的名字从内部传递给 <code>greet</code> 函数 <code>wasm-game-of-life/www/index.js</code>。 使用 <code>wasm-pack build</code> 重新构建 <code>.wasm</code> 二进制文件，然后在 Web 浏览器中刷新 <a href="http://localhost:8080/">http://localhost:8080/</a>，你应该会看到一个自定义的问候语！ </p>
<details>
  <summary>答案</summary>
<p><code>wasm-game-of-life/src/lib.rs</code> 中的 <code>greet</code> 函数的新版本:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
<span class="boring">}
</span></code></pre></pre>
<p><code>wasm-game-of-life/www/index.js</code> 中对 <code>greet</code> 的新调用：</p>
<pre><code class="language-js">wasm.greet(&quot;Your Name&quot;);
</code></pre>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="康威生命游戏规则"><a class="header" href="#康威生命游戏规则">康威生命游戏规则</a></h1>
<p><em>注：如果你已经熟悉了康威的生命游戏及其规则。请随意跳到下一节！</em>。</p>
<p><a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">维基百科对康威生命游戏的规则做了一个很好的描述:</a></p>
<blockquote>
<p>生命游戏的宇宙是一个无限的二维正交方格网格，
每个方格都处于两种可能状态中的一种，活或死，（或分别为有人居住和无人居住）。
每个单元格与其八个相邻单元格相互作用，这些单元格是水平、垂直或对角相邻的单元格。
在时间的每一步，都会发生以下转换：</p>
<ol>
<li>任何具有少于两个活邻居的活单元格都会死亡，就像人口不足一样。</li>
<li>任何有两个或三个活邻居的活单元格都会传给下一代。</li>
<li>任何拥有三个以上活邻居的活单元格都会死亡，就像人口过多一样。</li>
<li>任何只有三个活邻居的死单元格都会变成活单元格，就像通过繁殖一样。</li>
</ol>
<p>这些将自动机的行为与现实生活进行比较的规则可以浓缩为以下内容：</p>
<ol>
<li>任何有两个或三个活邻居的活单元格都能存活。</li>
<li>任何具有三个活邻居的死单元格都会成为活单元格。</li>
<li>所有其他活单元格在下一代中死亡。同样，所有其他死单元格保持死亡。 </li>
</ol>
<p>初始模式构成了系统的种子。 
第一代是通过将上述规则同时应用于种子中的每个单元格，
无论是活的还是死的； 出生和死亡同时发生，
发生这种情况的离散时刻有时称为滴答声。 每
一代都是前一代的纯函数。 这些规则不断被反复应用以创造更多的世代。</p>
</blockquote>
<p>考虑以下初始宇宙:</p>
<img src='../images/game-of-life/initial-universe.png' alt='Initial Universe' width=80 />
<p>我们可以通过考虑每个单元格来计算下一代。左上角的单元格已死。规则 (4) 是唯一适用于死单元格的转换规则。然而，因为左上角的单元格没有正好三个活着的邻居，所以转换规则不适用，它在下一代中仍然是死的。第一行中的每个其他单元格也是如此。</p>
<p>当我们考虑第二行第三列的顶部活单元格时，事情变得有趣了。对于活单元格，前三个规则中的任何一个都可能适用。在这个单元格的情况下，它只有一个活着的邻居，因此规则（1）适用：这个单元格将在下一代死亡。同样的命运等待着底部的活单元格。</p>
<p>中间的活单元格有两个活的邻居：顶部和底部的活单元格。这意味着规则 (2) 适用，并且它在下一代中仍然存在。</p>
<p>最后一个有趣的例子是中间活单元格左侧和右侧的死单元格。三个活单元格都是这两个单元格的邻居，这意味着规则（4）适用，这些单元格将在下一代变得活跃。</p>
<p>把它们放在一起，我们在下一个滴答后得到这个宇宙：</p>
<img src='../images/game-of-life/next-universe.png' alt='Next Universe' width=80 />
<p>从这些简单的、确定性的规则中，出现了奇怪而令人兴奋的行为:</p>
<table><thead><tr><th>Gosper's glider gun</th><th>Pulsar</th><th>Space ship</th></tr></thead><tbody>
<tr><td><img src="game-of-life/../images/wiki/Gospers_glider_gun.gif" alt="Gosper's glider gun" /></td><td><img src="game-of-life/../images/wiki/Game_of_life_pulsar.gif" alt="Pulsar" /></td><td><img src="game-of-life/../images/wiki/Game_of_life_animated_LWSS.gif" alt="Lighweight space ship" /></td></tr>
</tbody></table>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/C2vgICfQawE?rel=0&amp;start=65" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</center>
<h2 id="练习-1"><a class="header" href="#练习-1">练习</a></h2>
<ul>
<li>
<p>用手计算我们的例子宇宙的下一个刻度。注意到任何熟悉的东西吗？</p>
<details>
  <summary>答案</summary>
<p>它应该是例子宇宙的初始状态。</p>
<img src='../images/game-of-life/initial-universe.png' alt='Initial Universe' width=80 />
<p>这种模式是<em>周期性的</em>：它在每两个ticks之后返回到初始状态。</p>
</details>
</li>
<li>
<p>你能找到一个稳定的初始宇宙吗？就是说，一个每一代都是一样的宇宙。</p>
<details>
  <summary>答案</summary>
<p>有无限多的稳定的宇宙! 琐碎稳定的宇宙是空宇宙。一个由活单元格组成的2乘2的正方形也是一个稳定的宇宙。</p>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现康威的生命游戏"><a class="header" href="#实现康威的生命游戏">实现康威的生命游戏</a></h1>
<h2 id="设计"><a class="header" href="#设计">设计</a></h2>
<p>在我们深入研究之前，我们需要考虑一些设计选择。 </p>
<h3 id="无限宇宙"><a class="header" href="#无限宇宙">无限宇宙</a></h3>
<p>生命游戏是在一个无限的宇宙中进行的，但我们没有无限的内存和计算能力。 解决这个相当烦人的限制通常有以下三种方式之一： </p>
<ol>
<li>
<p>跟踪宇宙的哪个子集发生了有趣的事情，并根据需要扩展该区域。 在最坏的情况下，这种扩展是无界的，实现会越来越慢，最终会耗尽内存。 </p>
</li>
<li>
<p>创建一个固定大小的宇宙，其中边缘的单元格比中间的单元格具有更少的邻居。 这种方法的缺点是，像滑翔机一样到达宇宙尽头的无限模式被扼杀了。 </p>
</li>
<li>
<p>创建一个固定大小的周期性宇宙，其中边缘的单元格有环绕宇宙另一侧的邻居。 因为邻居环绕着宇宙的边缘，所以滑翔机可以永远运行。 </p>
</li>
</ol>
<p>我们将实施第三个选项。</p>
<h3 id="rust-和-javascript-的接口"><a class="header" href="#rust-和-javascript-的接口">Rust 和 JavaScript 的接口</a></h3>
<blockquote>
<p>⚡ 这是本教程中需要理解和掌握的最重要的概念之一！</p>
</blockquote>
<p>JavaScript 的垃圾收集堆——其中分配了“对象”、“数组”和 DOM 节点——与 WebAssembly 的线性内存空间不同，我们的 Rust 值存在于其中。 WebAssembly 目前无法直接访问垃圾收集堆（截至 2018 年 4 月，这预计会随着 <a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">“接口类型”提案</a> 的出现而改变）。 另一方面，JavaScript可以读写WebAssembly的线性内存空间，但只能作为标量值的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>（<code>u8</code>，<code>i32</code>，<code>f64</code>，等等）。 WebAssembly 函数也接受和返回标量值。 这些是构成所有 WebAssembly 和 JavaScript 通信的构建块。 </p>
<p><code>wasm_bindgen</code> 定义了如何跨这个边界处理复合结构的共同理解。 它涉及装箱 Rust 结构，并将指针包装在 JavaScript 类中以提高可用性，或者从 Rust 索引到 JavaScript 对象表。 <code>wasm_bindgen</code> 非常方便，但它并没有消除考虑我们的数据表示的需要，以及跨越这个边界传递的值和结构。 相反，将其视为实现您选择的界面设计的工具。</p>
<p>在设计 WebAssembly 和 JavaScript 之间的接口时，我们希望针对以下属性进行优化： </p>
<ol>
<li>
<p><strong>最大限度地减少进出 WebAssembly 线性内存的复制。</strong> 不必要的副本会带来不必要的开销。 </p>
</li>
<li>
<p><strong>最小化序列化和反序列化。</strong> 与副本类似，序列化和反序列化也会产生开销，并且通常也会产生复制。 如果我们可以将不透明的句柄传递给数据结构——而不是在一侧序列化它，将它复制到 WebAssembly 线性内存中的某个已知位置，然后在另一侧反序列化——我们通常可以减少很多开销。 <code>wasm_bindgen</code> 帮助我们定义和使用 JavaScript 对象或盒装 Rust 结构的不透明句柄。 </p>
</li>
</ol>
<h3 id="在我们的生活游戏中连接-rust-和-javascript"><a class="header" href="#在我们的生活游戏中连接-rust-和-javascript">在我们的生活游戏中连接 Rust 和 JavaScript</a></h3>
<p>让我们首先列举一些要避免的危险。 我们不想在每个滴答声中将整个宇宙复制到 WebAssembly 线性内存中。 我们不想为宇宙中的每个单元格分配对象，也不想强加跨界调用来读取和写入每个单元格。</p>
<p>这让我们何去何从？ 我们可以将宇宙表示为一个平面数组，它存在于 WebAssembly 线性内存中，每个单元格都有一个字节。 <code>0</code> 是死单元格，<code>1</code> 是活单元格。</p>
<p>以下是 4 x 4 宇宙在内存中的样子： </p>
<p><img src="game-of-life/../images/game-of-life/universe.png" alt="Screenshot of a 4 by 4 universe" /></p>
<p>为了找到宇宙中某一行和某一列的单元格的阵列索引，我们可以使用这个公式：</p>
<pre><code class="language-text">index(row, column, universe) = row * width(universe) + column
</code></pre>
<p>我们有几种方法可以将宇宙的单元格暴露给 JavaScript。首先，我们将为 &quot;宇宙 &quot;实现<a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>std::fmt::Display</code></a>，我们可以用它来生成一个渲染为文本字符的单元格的Rust<code>String</code>。然后这个Rust字符串从WebAssembly的线性内存中复制到JavaScript的垃圾收集堆中的一个JavaScript字符串，然后通过设置HTML<code>textContent</code>来显示。在本章的后面，我们将发展这个实现，以避免在堆之间复制宇宙的单元，并渲染到<code>&lt;canvas&gt;</code>。</p>
<p><em>另一个可行的设计方案是让Rust在每次打勾后返回一个改变状态的单元格的列表，而不是将整个宇宙暴露给JavaScript。这样一来，JavaScript就不需要在渲染时遍历整个宇宙，只需要遍历相关的子集。这样做的好处是，这种基于delta的设计在实现上稍显困难。</em></p>
<h2 id="rust-实现"><a class="header" href="#rust-实现">Rust 实现</a></h2>
<p>在上一章中，我们克隆了一个初始项目模板。 我们现在将修改该项目模板。</p>
<p>让我们首先从 <code>wasm-game-of-life/src/lib.rs</code> 中删除 <code>alert</code> 导入和 <code>greet</code> 函数，并将它们替换为单元格的类型定义： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
<span class="boring">}
</span></code></pre></pre>
<p>重要的是我们有<code>#[repr(u8)]</code>，这样每个单元格都表示为一个字节。 同样重要的是，<code>Dead</code> 变体为 <code>0</code>，<code>Alive</code> 变体为 <code>1</code>，以便我们可以轻松地通过加法计算单元格的活邻居。</p>
<p>接下来，让我们定义宇宙。 宇宙有宽度和高度，以及长度为 <code>width * height</code> 的单元向量。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec&lt;Cell&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>为了访问给定行和列的单元格，我们将行和列转换为单元格向量的索引，如前所述：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    fn get_index(&amp;self, row: u32, column: u32) -&gt; usize {
        (row * self.width + column) as usize
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>为了计算一个单元格的下一个状态，我们需要计算它的邻居有多少是活着的。 让我们编写一个 <code>live_neighbor_count</code> 方法来做到这一点！ </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    // ...

    fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 &amp;&amp; delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>live_neighbor_count</code> 方法使用 deltas 和 modulo 来避免使用 <code>if</code> 对宇宙边缘进行特殊外壳。 当应用 <code>-1</code> 的增量时，我们<em>添加</em> <code>self.height - 1</code> 并让模数做它的事情，而不是尝试减去 <code>1</code>。 <code>row</code> 和 <code>column</code> 可以是 <code>0</code>，如果我们试图从它们中减去 <code>1</code>，就会出现一个无符号整数下溢。</p>
<p>现在我们拥有了从当前计算下一代所需的一切！ 游戏的每条规则都直接转换为“匹配”表达式的条件。 此外，因为我们希望 JavaScript 控制滴答发生的时间，我们将把这个方法放在一个 <code>#[wasm_bindgen]</code> 块中，以便它暴露给 JavaScript。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&amp;mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>到目前为止，宇宙的状态被表示为一个单元格向量。 为了使人能够读懂这些内容，让我们实现一个基本的文本渲染器。 这个想法是将宇宙一行一行地写成文本，对于每个活着的单元格，打印 Unicode 字符<code>◼</code>（“黑色中型方块”）。 对于死单元格，我们将打印<code>◻</code>（一个“白色中等正方形”）。</p>
<p>通过实现 Rust 标准库中的 <a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>Display</code></a> 特性，我们可以添加一种以面向用户的方式格式化结构的方法。 这也会自动给我们一个 <a href="https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html"><code>to_string</code></a> 方法。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &amp;cell in line {
                let symbol = if cell == Cell::Dead { '◻' } else { '◼' };
                write!(f, &quot;{}&quot;, symbol)?;
            }
            write!(f, &quot;\n&quot;)?;
        }

        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，我们定义了一个构造函数，用一个有趣的活单元格和死单元格的模式来初始化宇宙，以及一个`render'方法:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -&gt; Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&amp;self) -&gt; String {
        self.to_string()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样，我们的生命游戏的Rust部分就完成了。</p>
<p>在<code>wasm-game-of-life</code>目录下运行<code>wasm-pack build</code>，将其重新编译为WebAssembly。</p>
<h2 id="用javascript进行渲染"><a class="header" href="#用javascript进行渲染">用JavaScript进行渲染</a></h2>
<p>首先，让我们在<code>wasm-game-of-life/www/index.html</code>中添加一个<code>&lt;pre&gt;</code>元素，将宇宙渲染进去，就在<code>&lt;script&gt;</code>标签上方:</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;pre id=&quot;game-of-life-canvas&quot;&gt;&lt;/pre&gt;
  &lt;script src=&quot;./bootstrap.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>此外，我们希望<code>&lt;pre&gt;</code>在网页的中间位置。我们可以使用CSS柔性框来完成这个任务。在<code>wasm-game-of-life/www/index.html</code>的<code>&lt;head&gt;</code>内添加以下<code>&lt;style&gt;</code>标签:</p>
<pre><code class="language-html">&lt;style&gt;
  body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
&lt;/style&gt;
</code></pre>
<p>在 <code>wasm-game-of-life/www/index.js</code> 的顶部，让我们修复我们的导入以引入 <code>Universe</code> 而不是旧的 <code>greet</code> 函数： </p>
<pre><code class="language-js">import { Universe } from &quot;wasm-game-of-life&quot;;
</code></pre>
<p>另外，让我们获取刚刚添加的 <code>&lt;pre&gt;</code> 元素并实例化一个新的 Universe：</p>
<pre><code class="language-js">const pre = document.getElementById(&quot;game-of-life-canvas&quot;);
const universe = Universe.new();
</code></pre>
<p>JavaScript在<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">一个<code>requestAnimationFrame</code>循环</a>中运行。在每个迭代中，它将当前的宇宙画到<code>&lt;pre&gt;</code>，然后调用<code>Universe::tick</code>。</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  pre.textContent = universe.render();
  universe.tick();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>为了开始渲染过程，我们所要做的就是为渲染循环的第一次迭代进行初始调用:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<p>确保你的开发服务器仍在运行（在<code>wasm-game-of-life/www</code>内运行<code>npm run start</code>），这就是<a href="http://localhost:8080/">http://localhost:8080/</a>应该有的样子:</p>
<p><a href="game-of-life/../images/game-of-life/initial-game-of-life-pre.png"><img src="game-of-life/../images/game-of-life/initial-game-of-life-pre.png" alt="Screenshot of the Game of Life implementation with text rendering" /></a></p>
<h2 id="直接从内存向画布渲染"><a class="header" href="#直接从内存向画布渲染">直接从内存向画布渲染</a></h2>
<p>在Rust中生成（和分配）一个<code>String</code>，然后让<code>wasm-bindgen</code>将其转换为有效的JavaScript字符串，就会对宇宙的单元格进行不必要的复制。由于JavaScript代码已经知道了宇宙的宽度和高度，并且可以直接读取构成单元格的WebAssembly的线性内存，我们将修改<code>render</code>方法以返回一个指向单元格数组开始的指针。</p>
<p>另外，我们将改用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a>来代替渲染Unicode文本。我们将在本教程的其余部分使用这种设计。</p>
<p>在<code>wasm-game-of-life/www/index.html</code>中，让我们把之前添加的<code>&lt;pre&gt;</code>替换成我们要渲染的<code>&lt;canvas&gt;</code>（它也应该在<code>&lt;body&gt;</code>中，在加载我们JavaScript的<code>&lt;script&gt;</code>之前）：</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;canvas id=&quot;game-of-life-canvas&quot;&gt;&lt;/canvas&gt;
  &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>为了从Rust的实现中获得必要的信息，我们需要为一个宇宙的宽度、高度和指向其单元格数组的指针增加一些getter函数。所有这些也都暴露在JavaScript中。在<code>wasm-game-of-life/src/lib.rs</code>中增加这些内容:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn width(&amp;self) -&gt; u32 {
        self.width
    }

    pub fn height(&amp;self) -&gt; u32 {
        self.height
    }

    pub fn cells(&amp;self) -&gt; *const Cell {
        self.cells.as_ptr()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>接下来，在<code>wasm-game-of-life/www/index.js</code>中，让我们也从<code>wasm-game-of-life</code>中导入<code>Cell</code>，并定义一些常量，我们将在渲染到画布时使用：</p>
<pre><code class="language-js">import { Universe, Cell } from &quot;wasm-game-of-life&quot;;

const CELL_SIZE = 5; // px
const GRID_COLOR = &quot;#CCCCCC&quot;;
const DEAD_COLOR = &quot;#FFFFFF&quot;;
const ALIVE_COLOR = &quot;#000000&quot;;
</code></pre>
<p>现在，让我们重写这段JavaScript代码的其余部分，不再写入<code>&lt;pre&gt;</code>的<code>textContent</code>，而是绘制到<code>&lt;canvas&gt;</code>:</p>
<pre><code class="language-js">// Construct the universe, and get its width and height.
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// Give the canvas room for all of our cells and a 1px border
// around each of them.
const canvas = document.getElementById(&quot;game-of-life-canvas&quot;);
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () =&gt; {
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>为了画出单元格之间的网格，我们画了一组等距的水平线，和一组等距的垂直线。这些线纵横交错，形成网格。</p>
<pre><code class="language-js">const drawGrid = () =&gt; {
  ctx.beginPath();
  ctx.strokeStyle = GRID_COLOR;

  // Vertical lines.
  for (let i = 0; i &lt;= width; i++) {
    ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
    ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
  }

  // Horizontal lines.
  for (let j = 0; j &lt;= height; j++) {
    ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);
    ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
  }

  ctx.stroke();
};
</code></pre>
<p>我们可以通过<code>memory</code>直接访问WebAssembly的线性内存，它被定义在原始wasm模块<code>wasm_game_of_life_bg</code>。为了绘制单元格，我们得到一个指向宇宙单元格的指针，构建一个覆盖单元格缓冲区的<code>Uint8Array</code>，遍历每个单元格，并根据单元格是死是活，分别绘制一个白色或黑色的矩形。通过使用指针和覆盖，我们避免了在每次打勾时将单元格复制到边界上。</p>
<pre><code class="language-js">// Import the WebAssembly memory at the top of the file.
import { memory } from &quot;wasm-game-of-life/wasm_game_of_life_bg&quot;;

// ...

const getIndex = (row, column) =&gt; {
  return row * width + column;
};

const drawCells = () =&gt; {
  const cellsPtr = universe.cells();
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      ctx.fillStyle = cells[idx] === Cell.Dead
        ? DEAD_COLOR
        : ALIVE_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
<p>为了开始渲染过程，我们将使用与上面相同的代码来启动渲染循环的第一次迭代:</p>
<pre><code class="language-js">drawGrid();
drawCells();
requestAnimationFrame(renderLoop);
</code></pre>
<p>注意，我们在这里调用<code>drawGrid()</code>和<code>drawCells()</code>，然后再调用<code>requestAnimationFrame()</code>。我们这样做的原因是为了在我们进行修改之前画出宇宙的_初始_状态。如果我们只是简单地调用<code>requestAnimationFrame(renderLoop)</code>，我们最终会出现这样的情况：第一个被绘制的帧实际上是在第一次调用<code>universe.tick()</code>之后，也就是这些单元格生命中的第二个 &quot;打勾&quot;。</p>
<h2 id="it-works"><a class="header" href="#it-works">It Works!</a></h2>
<p>通过从 <code>wasm-game-of-life</code> 目录中运行以下命令来重建 WebAssembly 和绑定：</p>
<pre><code>wasm-pack build
</code></pre>
<p>确保您的开发服务器仍在运行。 如果不是，请从 <code>wasm-game-of-life/www</code> 目录中重新启动它：</p>
<pre><code>npm run start
</code></pre>
<p>如果你刷新<a href="http://localhost:8080/">http://localhost:8080/</a>，你应该会看到精彩的生活展示！ </p>
<p><a href="game-of-life/../images/game-of-life/initial-game-of-life.png"><img src="game-of-life/../images/game-of-life/initial-game-of-life.png" alt="Screenshot of the Game of Life implementation" /></a></p>
<p>顺便说一句，还有一个非常简洁的算法来实现生命游戏，称为 <a href="https://en.wikipedia.org/wiki/Hashlife">hashlife</a>。 它使用积极的记忆，并且实际上可以<em>指数更快</em>来计算它运行的时间越长的后代！ 鉴于此，您可能想知道为什么我们没有在本教程中实现 hashlife。 这超出了本文的范围，我们专注于 Rust 和 WebAssembly 的集成，但我们强烈建议您自行了解 hashlife！</p>
<h2 id="练习-2"><a class="header" href="#练习-2">练习</a></h2>
<ul>
<li>
<p>用单个太空船初始化宇宙。</p>
</li>
<li>
<p>不是对初始宇宙进行硬编码，而是生成一个随机的宇宙，其中每个单元格有 550 次存活或死亡的机会。 </p>
<p><em>提示：使用<a href="https://crates.io/crates/js-sys"><code>js-sys</code> crate</a> 导入<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random"><code>Math.random</code> JavaScript 函数</a>.</em> </p>
<details>
  <summary>答案</summary>
  *首先，在`wasm-game-of-life/Cargo.toml`中添加`js-sys`作为依赖项：*
<pre><code class="language-toml"># ...
[dependencies]
js-sys = &quot;0.3&quot;
# ...
</code></pre>
<p><em>然后，使用<code>js_sys::Math::random</code>函数来投掷硬币：</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate js_sys;

// ...

if js_sys::Math::random() &lt; 0.5 {
    // Alive...
} else {
    // Dead...
}
<span class="boring">}
</span></code></pre></pre>
</details>
</li>
<li>
<p>用一个字节表示每个单元，使单元的迭代变得容易，但它的代价是浪费了内存。每个字节有八个比特，但是我们只需要一个比特来表示每个单元格是活的还是死的。重构数据表示，使每个单元格只使用一个比特的空间。</p>
<details>
  <summary>答案</summary>
<p>在Rust中，你可以使用<a href="https://crates.io/crates/fixedbitset"><code>fixedbitset</code> crate和它的<code>FixedBitSet</code>类型</a>来表示单元，而不是<code>Vec&lt;Cell&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make sure you also added the dependency to Cargo.toml!
extern crate fixedbitset;
use fixedbitset::FixedBitSet;

// ...

#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: FixedBitSet,
}
<span class="boring">}
</span></code></pre></pre>
<p>Universe 构造函数可以通过以下方式进行调整：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Universe {
    let width = 64;
    let height = 64;

    let size = (width * height) as usize;
    let mut cells = FixedBitSet::with_capacity(size);

    for i in 0..size {
        cells.set(i, i % 2 == 0 || i % 7 == 0);
    }

    Universe {
        width,
        height,
        cells,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>要在宇宙的下一个刻度中更新单元格，我们使用<code>FixedBitSet</code>的<code>set</code>方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>next.set(idx, match (cell, live_neighbors) {
    (true, x) if x &lt; 2 =&gt; false,
    (true, 2) | (true, 3) =&gt; true,
    (true, x) if x &gt; 3 =&gt; false,
    (false, 3) =&gt; true,
    (otherwise, _) =&gt; otherwise
});
<span class="boring">}
</span></code></pre></pre>
<p>要将指向位开头的指针传递给 JavaScript，您可以将 <code>FixedBitSet</code> 转换为切片，然后将切片转换为指针：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Universe {
    // ...

    pub fn cells(&amp;self) -&gt; *const u32 {
        self.cells.as_slice().as_ptr()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在 JavaScript 中，从 Wasm 内存构造一个 <code>Uint8Array</code> 和之前一样，只是数组的长度不再是 <code>width * height</code>，而是 <code>width * height / 8</code> 因为我们每比特有一个单元格而不是 每字节：</p>
<pre><code class="language-js">const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);
</code></pre>
<p>给定一个索引和 <code>Uint8Array</code>，您可以使用以下函数确定是否设置了 <em>n<sup>th</sup></em> 位：</p>
<pre><code class="language-js">const bitIsSet = (n, arr) =&gt; {
  const byte = Math.floor(n / 8);
  const mask = 1 &lt;&lt; (n % 8);
  return (arr[byte] &amp; mask) === mask;
};
</code></pre>
<p>鉴于所有这些，新版本的 <code>drawCells</code> 看起来像这样：</p>
<pre><code class="language-js">const drawCells = () =&gt; {
  const cellsPtr = universe.cells();

  // This is updated!
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      // This is updated!
      ctx.fillStyle = bitIsSet(idx, cells)
        ? ALIVE_COLOR
        : DEAD_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现康威的生命游戏-1"><a class="header" href="#实现康威的生命游戏-1">实现康威的生命游戏</a></h1>
<p>现在我们已经使用 JavaScript 在浏览器中实现了生命游戏渲染的 Rust 实现，让我们来谈谈测试我们的 Rust 生成的 WebAssembly 函数。</p>
<p>我们将测试我们的 <code>tick</code> 函数以确保它提供我们期望的输出。</p>
<p>接下来，我们将要在 <code>wasm_game_of_life/src/lib.rs</code> 文件中现有的 <code>impl Universe</code> 块中创建一些 setter 和 getter 函数。 我们将创建一个 <code>set_width</code> 和一个 <code>set_height</code> 函数，以便我们可以创建不同大小的 <code>Universe</code>。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Universe { 
    // ...

    /// Set the width of the universe.
    ///
    /// Resets all cells to the dead state.
    pub fn set_width(&amp;mut self, width: u32) {
        self.width = width;
        self.cells = (0..width * self.height).map(|_i| Cell::Dead).collect();
    }

    /// Set the height of the universe.
    ///
    /// Resets all cells to the dead state.
    pub fn set_height(&amp;mut self, height: u32) {
        self.height = height;
        self.cells = (0..self.width * height).map(|_i| Cell::Dead).collect();
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>我们将在我们的 <code>wasm_game_of_life/src/lib.rs</code> 文件中创建另一个不带 <code>#[wasm_bindgen]</code> 属性的 <code>impl Universe</code> 块。 有一些我们需要测试的函数我们不想暴露给我们的 JavaScript。 Rust 生成的 WebAssembly 函数不能返回借用的引用。 尝试使用属性编译 Rust 生成的 WebAssembly 并查看您得到的错误。</p>
<p>我们将编写 <code>get_cells</code> 的实现来获取 <code>Universe</code> 的 <code>cells</code> 的内容。 我们还将编写一个 <code>set_cells</code> 函数，以便我们可以将 <code>Universe</code> 的特定行和列中的 <code>cells</code> 设置为 <code>Alive</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    /// Get the dead and alive values of the entire universe.
    pub fn get_cells(&amp;self) -&gt; &amp;[Cell] {
        &amp;self.cells
    }

    /// Set cells to be alive in a universe by passing the row and column
    /// of each cell as an array.
    pub fn set_cells(&amp;mut self, cells: &amp;[(u32, u32)]) {
        for (row, col) in cells.iter().cloned() {
            let idx = self.get_index(row, col);
            self.cells[idx] = Cell::Alive;
        }
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们将在 <code>wasm_game_of_life/tests/web.rs</code> 文件中创建我们的测试。</p>
<p>在我们这样做之前，文件中已经有一个工作测试。 您可以通过在 <code>wasm-game-of-life</code> 目录中运行 <code>wasm-pack test --chrome --headless</code> 来确认 Rust 生成的 WebAssembly 测试正在运行。 你还可以使用 <code>--firefox</code>、<code>--safari</code> 和 <code>--node</code> 选项在这些浏览器中测试你的代码。</p>
<p>在 <code>wasm_game_of_life/tests/web.rs</code> 文件中，我们需要导出 <code>wasm_game_of_life</code> crate 和 <code>Universe</code> 类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate wasm_game_of_life;
use wasm_game_of_life::Universe;
<span class="boring">}
</span></code></pre></pre>
<p>在 <code>wasm_game_of_life/tests/web.rs</code> 文件中，我们将要创建一些飞船建造器功能。</p>
<p>我们需要一个用于我们的输入宇宙飞船，我们将调用 <code>tick</code> 函数，我们希望在一个刻度后我们将获得预期的宇宙飞船。 我们选择了要初始化为 <code>Alive</code> 的单元格，以在 <code>input_spaceship</code> 函数中创建我们的飞船。 <code>input_spaceship</code> 勾选后，<code>expected_spaceship</code> 函数中飞船的位置是手动计算的。 您可以自己确认一下，输入飞船的单元格在一个tick后与预期的飞船相同。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
pub fn input_spaceship() -&gt; Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&amp;[(1,2), (2,3), (3,1), (3,2), (3,3)]);
    universe
}

#[cfg(test)]
pub fn expected_spaceship() -&gt; Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&amp;[(2,1), (2,3), (3,2), (3,3), (4,2)]);
    universe
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们将为我们的<code>test_tick</code> 函数编写实现。 首先，我们创建了一个 <code>input_spaceship()</code> 和 <code>expected_spaceship()</code> 的实例。 然后，我们在 <code>input_universe</code> 上调用 <code>tick</code>。 最后，我们使用 <code>assert_eq!</code> 宏调用 <code>get_cells()</code> 以确保 <code>input_universe</code> 和 <code>expected_universe</code> 具有相同的 <code>Cell</code> 数组值。 我们将 <code>#[wasm_bindgen_test]</code> 属性添加到我们的代码块中，以便我们可以测试 Rust 生成的 WebAssembly 代码并使用 <code>wasm-pack test</code> 来测试 WebAssembly 代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen_test]
pub fn test_tick() {
    // Let's create a smaller Universe with a small spaceship to test!
    let mut input_universe = input_spaceship();

    // This is what our spaceship should look like
    // after one tick in our universe.
    let expected_universe = expected_spaceship();

    // Call `tick` and then see if the cells in the `Universe`s are the same.
    input_universe.tick();
    assert_eq!(&amp;input_universe.get_cells(), &amp;expected_universe.get_cells());
}
<span class="boring">}
</span></code></pre></pre>
<p>通过在 <code>wasm-game-of-life</code> 目录中运行 <code>wasm-pack test --firefox --headless</code> 进行测试。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试"><a class="header" href="#调试">调试</a></h1>
<p>在我们写更多的代码之前，我们会想在我们的腰带上有一些调试工具，以备出错时使用。花点时间回顾一下<a href="game-of-life/../reference/debugging.html">参考页列出了可用来调试Rust生成的WebAssembly的工具和方法</a>.</p>
<h2 id="为-panics-启用日志记录"><a class="header" href="#为-panics-启用日志记录">为 Panics 启用日志记录</a></h2>
<p><a href="game-of-life/../reference/debugging.html#%E8%AE%B0%E5%BD%95-panics">如果我们的代码出现混乱，我们希望在开发者控制台中显示信息性错误消息。</a></p>
<p>我们的 <code>wasm-pack-template</code> 带有一个可选的、默认启用的对 <a href="https://github.com/rustwasm/console_error_panic_hook"><code>console_error_panic_hook</code> crate</a> 的依赖，该依赖被配置在 <code>wasm-game-of-life/src/utils.rs</code> 中。我们需要做的就是在初始化函数或公共代码路径中安装这个钩子。我们可以在 <code>wasm-ame-of-life/src/lib.rs</code> 中的 <code>Universe::new</code> 构造函数中调用它。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Universe {
    utils::set_panic_hook();

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="在我们的生活游戏中加入记录的内容"><a class="header" href="#在我们的生活游戏中加入记录的内容">在我们的生活游戏中加入记录的内容</a></h2>
<p>让我们<a href="game-of-life/../reference/debugging.html#logging-with-the-console-apis">通过<code>web-sys</code> crate 使用 <code>console.log</code> 函数来添加一些关于我们 <code>Universe::tick</code> 函数中每个单元的日志</a>。</p>
<p>首先，添加 <code>web-sys</code> 作为依赖，并在 <code>wasm-game-of-life/Cargo.toml</code> 中启用其<code>&quot;console&quot;</code>功能:</p>
<pre><code class="language-toml">[dependencies]

# ...

[dependencies.web-sys]
version = &quot;0.3&quot;
features = [
  &quot;console&quot;,
]
</code></pre>
<p>为了符合人体工程学，我们将把<code>console.log</code>函数包装成一个<code>println!</code>风格的宏:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

// A macro to provide `println!(..)`-style syntax for `console.log` logging.
macro_rules! log {
    ( $( $t:tt )* ) =&gt; {
        web_sys::console::log_1(&amp;format!( $( $t )* ).into());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，我们可以通过在Rust代码中插入对<code>log</code>的调用来开始将信息记录到控制台。例如，为了记录每个单元格的状态、活的邻居数和下一个状态，我们可以这样修改<code>wasm-game-of-life/src/lib.rs</code>:</p>
<pre><code class="language-diff">diff --git a/src/lib.rs b/src/lib.rs
index f757641..a30e107 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -123,6 +122,14 @@ impl Universe {
                 let cell = self.cells[idx];
                 let live_neighbors = self.live_neighbor_count(row, col);

+                log!(
+                    &quot;cell[{}, {}] is initially {:?} and has {} live neighbors&quot;,
+                    row,
+                    col,
+                    cell,
+                    live_neighbors
+                );
+
                 let next_cell = match (cell, live_neighbors) {
                     // Rule 1: Any live cell with fewer than two live neighbours
                     // dies, as if caused by underpopulation.
@@ -140,6 +147,8 @@ impl Universe {
                     (otherwise, _) =&gt; otherwise,
                 };

+                log!(&quot;    it becomes {:?}&quot;, next_cell);
+
                 next[idx] = next_cell;
             }
         }
</code></pre>
<h2 id="使用调试器在每个-tick-之间进行停顿"><a class="header" href="#使用调试器在每个-tick-之间进行停顿">使用调试器在每个 Tick 之间进行停顿</a></h2>
<p><a href="game-of-life/../reference/debugging.html#using-a-debugger">浏览器的步进调试器对于检查我们的 Rust 生成的 WebAssembly 与之交互的 JavaScript 很有用。</a></p>
<p>例如，我们可以使用调试器通过将 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger">一个 JavaScript <code>debugger;</code> 语句</a> 放在我们对 <code>universe.tick()</code> 的调用上方来暂停 <code>renderLoop</code> 函数的每次迭代。</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  debugger;
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>这为我们提供了一个方便的检查点，用于检查记录的消息，并将当前渲染的帧与前一帧进行比较。</p>
<p><a href="game-of-life/../images/game-of-life/debugging.png"><img src="game-of-life/../images/game-of-life/debugging.png" alt="Screenshot of debugging the Game of Life" /></a></p>
<h2 id="练习-3"><a class="header" href="#练习-3">练习</a></h2>
<ul>
<li>
<p>向 <code>tick</code> 函数添加日志记录，记录每个单元格的行和列，这些单元格将状态从活动状态转换为死状态，反之亦然。</p>
</li>
<li>
<p>在 <code>Universe::new</code> 方法中引入 <code>panic!()</code>。 在 Web 浏览器的 JavaScript 调试器中检查恐慌的回溯。 禁用调试符号，在没有 <code>console_error_panic_hook</code> 可选依赖项的情况下重建，并再次检查堆栈跟踪。 不是那么有用吗？ </p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="添加交互性"><a class="header" href="#添加交互性">添加交互性</a></h1>
<p>我们将继续探索 JavaScript 和 WebAssembly 界面，为我们的 Game of Life 实现添加一些交互功能。 我们将使用户能够通过单击来切换单元格是活的还是死的，并允许暂停游戏，这使得绘制单元格图案变得更加容易。 </p>
<h2 id="暂停和恢复游戏"><a class="header" href="#暂停和恢复游戏">暂停和恢复游戏</a></h2>
<p>让我们添加一个按钮来切换游戏是正在播放还是暂停。 在 <code>wasm-game-of-life/www/index.html</code> 中，在 <code>&lt;canvas&gt;</code> 正上方添加按钮：</p>
<pre><code class="language-html">&lt;button id=&quot;play-pause&quot;&gt;&lt;/button&gt;
</code></pre>
<p>在 <code>wasm-game-of-life/www/index.js</code> JavaScript 中，我们将进行以下更改：</p>
<ul>
<li>
<p>跟踪最近一次调用<code>requestAnimationFrame</code> 返回的标识符，以便我们可以通过使用该标识符调用<code>cancelAnimationFrame</code> 来取消动画。</p>
</li>
<li>
<p>当播放/暂停按钮被点击时，检查我们是否有排队动画帧的标识符。如果我们这样做，那么游戏当前正在播放，我们想要取消动画帧，以便不再调用 <code>renderLoop</code>，从而有效地暂停游戏。如果我们没有排队动画帧的标识符，那么我们当前处于暂停状态，我们想调用<code>requestAnimationFrame</code> 来恢复游戏。</p>
</li>
</ul>
<p>因为 JavaScript 正在驱动 Rust 和 WebAssembly，这就是我们需要做的所有事情，我们不需要更改 Rust 源。</p>
<p>我们引入了<code>animationId</code> 变量来跟踪<code>requestAnimationFrame</code> 返回的标识符。当没有排队的动画帧时，我们将此变量设置为 <code>null</code>。</p>
<pre><code class="language-js">let animationId = null;

// This function is the same as before, except the
// result of `requestAnimationFrame` is assigned to
// `animationId`.
const renderLoop = () =&gt; {
  drawGrid();
  drawCells();

  universe.tick();

  animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>在任何时候，我们都可以通过检查 <code>animationId</code> 的值来判断游戏是否暂停：</p>
<pre><code class="language-js">const isPaused = () =&gt; {
  return animationId === null;
};
</code></pre>
<p>现在，当点击播放/暂停按钮时，我们检查游戏当前是否暂停或播放，并分别恢复<code>renderLoop</code>动画或取消下一动画帧。 此外，我们更新按钮的文本图标以反映按钮在下一次单击时将采取的操作。</p>
<pre><code class="language-js">const playPauseButton = document.getElementById(&quot;play-pause&quot;);

const play = () =&gt; {
  playPauseButton.textContent = &quot;⏸&quot;;
  renderLoop();
};

const pause = () =&gt; {
  playPauseButton.textContent = &quot;▶&quot;;
  cancelAnimationFrame(animationId);
  animationId = null;
};

playPauseButton.addEventListener(&quot;click&quot;, event =&gt; {
  if (isPaused()) {
    play();
  } else {
    pause();
  }
});
</code></pre>
<p>最后，我们之前通过直接调用 <code>requestAnimationFrame(renderLoop)</code> 来启动游戏及其动画，但我们想用对 <code>play</code> 的调用替换它，以便按钮获得正确的初始文本图标。</p>
<pre><code class="language-diff">// This used to be `requestAnimationFrame(renderLoop)`.
play();
</code></pre>
<p>刷新 <a href="http://localhost:8080/">http://localhost:8080/</a> 我们现在应该可以通过点击按钮暂停和恢复游戏了！ </p>
<h2 id="在-click-事件上切换单元格的状态"><a class="header" href="#在-click-事件上切换单元格的状态">在 <code>&quot;click&quot;</code> 事件上切换单元格的状态</a></h2>
<p>现在我们可以暂停游戏了，是时候添加通过单击单元格来变异单元格的功能了。</p>
<p>切换一个单元格就是将它的状态从活着变为死亡或从死亡变为活着。 向 <code>wasm-game-of-life/src/lib.rs</code> 中的 <code>Cell</code> 添加 <code>toggle</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cell {
    fn toggle(&amp;mut self) {
        *self = match *self {
            Cell::Dead =&gt; Cell::Alive,
            Cell::Alive =&gt; Cell::Dead,
        };
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>要在给定的行和列处切换单元格的状态，我们将行和列对转换为单元格向量的索引，并在该索引处的单元格上调用 toggle 方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn toggle_cell(&amp;mut self, row: u32, column: u32) {
        let idx = self.get_index(row, column);
        self.cells[idx].toggle();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个方法被定义在<code>impl</code>块中，该块被注释为<code>#[wasm_bindgen]</code>，这样它就可以被JavaScript调用。</p>
<p>在<code>wasm-game-of-life/www/index.js</code>中，我们监听<code>&lt;canvas&gt;</code>元素上的点击事件，将点击事件的页面相对坐标转换为画布相对坐标，然后转换为行和列，调用<code>toggle_cell</code>方法，最后重新绘制场景。</p>
<pre><code class="language-js">canvas.addEventListener(&quot;click&quot;, event =&gt; {
  const boundingRect = canvas.getBoundingClientRect();

  const scaleX = canvas.width / boundingRect.width;
  const scaleY = canvas.height / boundingRect.height;

  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;
  const canvasTop = (event.clientY - boundingRect.top) * scaleY;

  const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1);
  const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1);

  universe.toggle_cell(row, col);

  drawGrid();
  drawCells();
});
</code></pre>
<p>在<code>wasm-game-of-life</code>中用<code>wasm-pack build</code>重新构建，然后再次刷新<a href="http://localhost:8080/">http://localhost:8080/</a>，现在我们可以通过点击单元格并切换其状态来绘制我们自己的图案。s</p>
<h2 id="练习-4"><a class="header" href="#练习-4">练习</a></h2>
<ul>
<li>
<p>引入一个<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range"><code>&lt;input type=&quot;range&quot;&gt;</code></a>小部件来控制每一帧动画发生多少次。</p>
</li>
<li>
<p>添加一个按钮，当点击时将宇宙重置到一个随机的初始状态。另一个按钮可以将宇宙重设为所有死单元。</p>
</li>
<li>
<p>在 <code>Ctrl + Click</code> 时，插入一个 <a href="https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)">glider</a>，以目标单元为中心。在<code>Shift + Click</code>上，插入一个脉冲星。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间分析"><a class="header" href="#时间分析">时间分析</a></h1>
<p>在本章中，我们将提高生命游戏实现的性能。 我们将使用时间分析来指导我们的工作。</p>
<p>在继续之前熟悉 <a href="game-of-life/../reference/time-profiling.html">用于时间分析 Rust 和 WebAssembly 代码的可用工具</a>。 </p>
<h2 id="使用-windowperformancenow-函数创建每秒帧数计时器"><a class="header" href="#使用-windowperformancenow-函数创建每秒帧数计时器">使用 <code>window.performance.now</code> 函数创建每秒帧数计时器</a></h2>
<p>当我们研究加速生命游戏的渲染时，这个 FPS 计时器将非常有用。</p>
<p>我们首先向 <code>wasm-game-of-life/www/index.js</code> 添加一个 <code>fps</code> 对象： </p>
<pre><code class="language-js">const fps = new class {
  constructor() {
    this.fps = document.getElementById(&quot;fps&quot;);
    this.frames = [];
    this.lastFrameTimeStamp = performance.now();
  }

  render() {
    // Convert the delta time since the last frame render into a measure
    // of frames per second.
    const now = performance.now();
    const delta = now - this.lastFrameTimeStamp;
    this.lastFrameTimeStamp = now;
    const fps = 1 / delta * 1000;

    // Save only the latest 100 timings.
    this.frames.push(fps);
    if (this.frames.length &gt; 100) {
      this.frames.shift();
    }

    // Find the max, min, and mean of our 100 latest timings.
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    for (let i = 0; i &lt; this.frames.length; i++) {
      sum += this.frames[i];
      min = Math.min(this.frames[i], min);
      max = Math.max(this.frames[i], max);
    }
    let mean = sum / this.frames.length;

    // Render the statistics.
    this.fps.textContent = `
Frames per Second:
         latest = ${Math.round(fps)}
avg of last 100 = ${Math.round(mean)}
min of last 100 = ${Math.round(min)}
max of last 100 = ${Math.round(max)}
`.trim();
  }
};
</code></pre>
<p>接下来我们在 <code>renderLoop</code> 的每次迭代中调用 <code>fps</code> <code>render</code> 函数：</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
    fps.render(); //new

    universe.tick();
    drawGrid();
    drawCells();

    animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>最后，不要忘记将 <code>fps</code> 元素添加到 <code>wasm-game-of-life/www/index.html</code>，就在 <code>&lt;canvas&gt;</code> 的上方:</p>
<pre><code class="language-html">&lt;div id=&quot;fps&quot;&gt;&lt;/div&gt;
</code></pre>
<p>并添加 CSS 以使其格式更好：</p>
<pre><code class="language-css">#fps {
  white-space: pre;
  font-family: monospace;
}
</code></pre>
<p>瞧！ 刷新 <a href="http://localhost:8080">http://localhost:8080</a> 现在我们有了一个 FPS 计数器！ </p>
<h3 id="使用-consoletime-和-consoletimeend-为每个-universetick-计时"><a class="header" href="#使用-consoletime-和-consoletimeend-为每个-universetick-计时">使用 <code>console.time</code> 和 <code>console.timeEnd</code> 为每个 <code>Universe::tick</code> 计时</a></h3>
<p>为了测量每次调用 <code>Universe::tick</code> 需要多长时间，我们可以通过 <code>web-sys</code> crate 使用 <code>console.time</code> 和 <code>console.timeEnd</code>。</p>
<p>首先，将 <code>web-sys</code> 作为依赖添加到 <code>wasm-game-of-life/Cargo.toml</code>：</p>
<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3&quot;
features = [
  &quot;console&quot;,
]
</code></pre>
<p>因为每个 <code>console.time</code> 调用都应该有一个相应的 <code>console.timeEnd</code> 调用，所以将它们都包装在 <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> 类型中会很方便：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;
use web_sys::console;

pub struct Timer&lt;'a&gt; {
    name: &amp;'a str,
}

impl&lt;'a&gt; Timer&lt;'a&gt; {
    pub fn new(name: &amp;'a str) -&gt; Timer&lt;'a&gt; {
        console::time_with_label(name);
        Timer { name }
    }
}

impl&lt;'a&gt; Drop for Timer&lt;'a&gt; {
    fn drop(&amp;mut self) {
        console::time_end_with_label(self.name);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，我们可以通过将此代码段添加到方法的顶部来计算每个 <code>Universe::tick</code> 花费的时间：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _timer = Timer::new(&quot;Universe::tick&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>每次调用 <code>Universe::tick</code> 花费的时间现在记录在控制台中：</p>
<p><a href="game-of-life/../images/game-of-life/console-time.png"><img src="game-of-life/../images/game-of-life/console-time.png" alt="Screenshot of console.time logs" /></a></p>
<p>此外，<code>console.time</code> 和 <code>console.timeEnd</code> 对将显示在浏览器的分析器的 “时间轴” 或“ 瀑布” 视图中：</p>
<p><a href="game-of-life/../images/game-of-life/console-time-in-profiler.png"><img src="game-of-life/../images/game-of-life/console-time-in-profiler.png" alt="Screenshot of console.time logs" /></a></p>
<h2 id="发展我们的生命游戏宇宙"><a class="header" href="#发展我们的生命游戏宇宙">发展我们的生命游戏宇宙</a></h2>
<blockquote>
<p>⚠️ 本节使用来自 Firefox 的示例屏幕截图。 
虽然所有现代浏览器都有类似的工具，但使用不同的开发人员工具可能会有细微的差别。 
您提取的配置文件信息将基本相同，但您所看到的视图和不同工具的命名可能会有所不同。</p>
</blockquote>
<p>如果我们让生命游戏的宇宙更大，会发生什么？ 用 128 x 128 Universe 替换 64 x 64 Universe（通过修改 <code>wasm-game-of-life/src/lib.rs</code> 中的 <code>Universe::new</code>）导致 FPS 从平滑的 60 下降到不稳定的 40-ish 在我的机器上。</p>
<p>如果我们记录一个配置文件并查看瀑布视图，我们会看到每个动画帧花费了 20 毫秒以上。 回想一下，每秒 60 帧为渲染一帧的整个过程留下了 16 毫秒。 这不仅仅是我们的 JavaScript 和 WebAssembly，还有浏览器正在做的所有其他事情，比如绘画。</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-waterfall.png"><img src="game-of-life/../images/game-of-life/drawCells-before-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame" /></a></p>
<p>如果我们查看单个动画帧内发生的情况，我们会发现<code>CanvasRenderingContext2D.fillStyle</code> setter 非常昂贵！ </p>
<blockquote>
<p>⚠️ 在 Firefox 中，如果您看到一行简单地说“DOM”
而不是上面提到的“CanvasRenderingContext2D.fillStyle”，
则可能需要在性能开发人员工具选项中打开“显示 Gecko 平台数据”选项： </p>
<p><a href="game-of-life/../images/game-of-life/profiler-firefox-show-gecko-platform.png"><img src="game-of-life/../images/game-of-life/profiler-firefox-show-gecko-platform.png" alt="Turning on Show Gecko Platform Data" /></a></p>
</blockquote>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-before-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>我们可以通过查看调用树的许多帧的聚合来确认这不是异常：</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-calltree.png"><img src="game-of-life/../images/game-of-life/drawCells-before-calltree.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>我们将近 40% 的时间都花在了这个 setter 上！</p>
<blockquote>
<p>⚡ 我们可能已经预料到 <code>tick</code> 方法中的某些东西会成为性能瓶颈，
但事实并非如此。 始终让分析引导您的注意力，因为时间可能会花在您不期望的地方。</p>
</blockquote>
<p>在 <code>wasm-game-of-life/www/index.js</code> 的 <code>drawCells</code> 函数中，<code>fillStyle</code> 属性为 Universe 中的每个单元格在每个动画帧上设置一次： </p>
<pre><code class="language-js">for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);

    ctx.fillStyle = cells[idx] === DEAD
      ? DEAD_COLOR
      : ALIVE_COLOR;

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>既然我们已经发现设置<code>fillStyle</code>是如此昂贵，那么我们该如何做才能避免频繁地设置它？我们需要根据一个单元格是活的还是死的来改变<code>fillStyle</code>。如果我们设置<code>fillStyle = ALIVE_COLOR</code>，然后在一次绘制所有活着的单元格，然后设置<code>fillStyle = DEAD_COLOR</code>，在另一次绘制所有死亡的单元格，那么我们只需要设置<code>fillStyle</code>两次，而不是对每个单元格设置一次。</p>
<pre><code class="language-js">// Alive cells.
ctx.fillStyle = ALIVE_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Alive) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}

// Dead cells.
ctx.fillStyle = DEAD_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Dead) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>保存这些变化并刷新<a href="http://localhost:8080/">http://localhost:8080/</a>后，渲染又恢复到每秒60帧的平稳状态。</p>
<p>如果我们再拍一张剖面图，我们可以看到现在每个动画帧只花了大约10毫秒。</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-after-waterfall.png"><img src="game-of-life/../images/game-of-life/drawCells-after-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame after the drawCells changes" /></a></p>
<p>分解一个单一的框架，我们看到<code>fillStyle</code>的成本已经没有了，我们框架的大部分时间是在<code>fillRect</code>中度过的，绘制每个单元格的矩形。</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame after the drawCells changes" /></a></p>
<h2 id="让时间跑得更快"><a class="header" href="#让时间跑得更快">让时间跑得更快</a></h2>
<p>有些人不喜欢等待，他们希望每一帧动画不是发生一次宇宙的跳动，而是发生九次跳动。我们可以修改<code>wasm-game-of-life/www/index.js</code>中的<code>renderLoop</code>函数来实现这个目的。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 9; i++) {
  universe.tick();
}
</code></pre>
<p>在我的机器上，这使我们回落到每秒只有35帧。这可不好。我们要的是奶油般的60帧!</p>
<p>现在我们知道时间是在 <code>Universe::tick</code> 中度过的，所以让我们添加一些 <code>Timer</code>，在 <code>console.time</code> 和 <code>console.timeEnd</code> 的调用中包住它的各个部分，看看这将会给我们带来什么。我的假设是，在每个tick上分配一个新的单元格向量并释放旧的向量是昂贵的，并且占用了我们时间预算的很大一部分。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn tick(&amp;mut self) {
    let _timer = Timer::new(&quot;Universe::tick&quot;);

    let mut next = {
        let _timer = Timer::new(&quot;allocate next cells&quot;);
        self.cells.clone()
    };

    {
        let _timer = Timer::new(&quot;new generation&quot;);
        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }
    }

    let _timer = Timer::new(&quot;free old cells&quot;);
    self.cells = next;
}
<span class="boring">}
</span></code></pre></pre>
<p>看一下时间，很明显我的假设是不正确的：绝大部分时间都花在了实际计算下一代的单元上。令人惊讶的是，在每次勾选时分配和释放一个载体的成本似乎可以忽略不计。又一次提醒我们要始终用剖析来指导我们的工作!</p>
<p><a href="game-of-life/../images/game-of-life/console-time-in-universe-tick.png"><img src="game-of-life/../images/game-of-life/console-time-in-universe-tick.png" alt="Screenshot of a Universe::tick timer results" /></a></p>
<p>下一节要求使用<code>nightly</code>编译器。之所以需要它，是因为我们要用<a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">test feature gate</a>来做基准测试。我们要安装的另一个工具是<a href="https://github.com/BurntSushi/cargo-benchcmp">cargo benchcmp</a>。它是一个小工具，用于比较由<code>cargo bench</code>产生的微观基准。</p>
<p>让我们写一个本地代码<code>#[bench]</code>，做与我们的WebAssembly相同的事情，但在这里我们可以使用更成熟的剖析工具。这里是新的<code>wasm-game-of-life/benches/bench.rs</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate test;
extern crate wasm_game_of_life;

#[bench]
fn universe_ticks(b: &amp;mut test::Bencher) {
    let mut universe = wasm_game_of_life::Universe::new();

    b.iter(|| {
        universe.tick();
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>我们还必须注释掉所有的<code>#[wasm_bindgen]</code>注释，以及<code>Cargo.toml</code>中的<code>&quot;dylib&quot;</code>位，否则构建本地代码会失败，并出现链接错误。</p>
<p>有了这些，我们就可以运行<code>cargo bench | tee before.txt</code>来编译和运行我们的基准测试了 <code>| tee before.txt</code>部分将从<code>cargo bench</code>中获取输出，并放入一个名为<code>before.txt</code>的文件。</p>
<pre><code>$ cargo bench | tee before.txt
    Finished release [optimized + debuginfo] target(s) in 0.0 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>This also tells us where the binary lives, and we can run the benchmarks again,
but this time under our operating system's profiler. In my case, I'm running
Linux, so <a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code></a> is the profiler I'll use:</p>
<pre><code>$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench
running 1 test
test universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out

[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]
</code></pre>
<p>用 <code>perf report </code> 加载配置文件显示，我们所有的时间都花在了 <code>Universe::tick</code> 上，正如预期：</p>
<p><a href="game-of-life/../images/game-of-life/bench-perf-report.png"><img src="game-of-life/../images/game-of-life/bench-perf-report.png" alt="Screenshot of perf report" /></a></p>
<p>如果你按下<code>a</code>，<code>perf</code> 将注解函数中的哪些指令正在花费时间：</p>
<p><a href="game-of-life/../images/game-of-life/bench-perf-annotate.png"><img src="game-of-life/../images/game-of-life/bench-perf-annotate.png" alt="Screenshot of perf's instruction annotation" /></a></p>
<p>这告诉我们，26.67%的时间花在相邻单元格的数值相加上，23.41%的时间花在获取相邻的列索引上，另外15.42%的时间花在获取相邻的行索引上。在这前三个最昂贵的指令中，第二和第三条都是昂贵的<code>div</code>指令。这些<code>div</code>实现了<code>Universe::live_neighbor_count</code>中的模数索引逻辑。</p>
<p>回顾一下<code>wasm-game-of-life/src/lib.rs</code>中的<code>live_neighbor_count</code>定义:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;
    for delta_row in [self.height - 1, 0, 1].iter().cloned() {
        for delta_col in [self.width - 1, 0, 1].iter().cloned() {
            if delta_row == 0 &amp;&amp; delta_col == 0 {
                continue;
            }

            let neighbor_row = (row + delta_row) % self.height;
            let neighbor_col = (column + delta_col) % self.width;
            let idx = self.get_index(neighbor_row, neighbor_col);
            count += self.cells[idx] as u8;
        }
    }
    count
}
<span class="boring">}
</span></code></pre></pre>
<p>我们使用模数的原因是为了避免在第一或最后一行或一列的边缘情况下用<code>if</code>分支使代码变得混乱。但是，即使在最常见的情况下，我们也要付出<code>div</code>指令的代价，当<code>row</code>和<code>column</code>都不在宇宙的边缘，它们不需要模数包装处理。相反，如果我们使用<code>if</code>s来处理边缘情况，并解开这个循环，分支<em>应该</em>被CPU的分支预测器很好地预测到。</p>
<p>让我们这样重写<code>live_neighbor_count</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;

    let north = if row == 0 {
        self.height - 1
    } else {
        row - 1
    };

    let south = if row == self.height - 1 {
        0
    } else {
        row + 1
    };

    let west = if column == 0 {
        self.width - 1
    } else {
        column - 1
    };

    let east = if column == self.width - 1 {
        0
    } else {
        column + 1
    };

    let nw = self.get_index(north, west);
    count += self.cells[nw] as u8;

    let n = self.get_index(north, column);
    count += self.cells[n] as u8;

    let ne = self.get_index(north, east);
    count += self.cells[ne] as u8;

    let w = self.get_index(row, west);
    count += self.cells[w] as u8;

    let e = self.get_index(row, east);
    count += self.cells[e] as u8;

    let sw = self.get_index(south, west);
    count += self.cells[sw] as u8;

    let s = self.get_index(south, column);
    count += self.cells[s] as u8;

    let se = self.get_index(south, east);
    count += self.cells[se] as u8;

    count
}
<span class="boring">}
</span></code></pre></pre>
<p>现在让我们再运行一次基准测试! 这次把它输出到<code>after.txt</code>。</p>
<pre><code>$ cargo bench | tee after.txt
   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)
    Finished release [optimized + debuginfo] target(s) in 0.82 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>这看起来好了很多! 我们可以通过<code>benchcmp</code>工具和我们之前创建的两个文本文件看到它有多好：</p>
<pre><code>$ cargo benchcmp before.txt after.txt
 name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup
 universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61
</code></pre>
<p>哇！7.61倍的速度</p>
<p>WebAssembly有意与常见的硬件架构紧密映射，但我们确实需要确保这种本地代码的速度也能转化为WebAssembly的速度。</p>
<p>让我们用<code>wasm-pack build</code>重建<code>.wasm</code>并刷新[http://localhost:8080/]（http://localhost:8080/）。在我的机器上，该页面再次以每秒60帧的速度运行，用浏览器的剖析器记录另一个剖析，发现每个动画帧大约需要10毫秒。</p>
<p>成功了!</p>
<p><a href="game-of-life/../images/game-of-life/waterfall-after-branches-and-unrolling.png"><img src="game-of-life/../images/game-of-life/waterfall-after-branches-and-unrolling.png" alt="Screenshot of a waterfall view of rendering a frame after replacing modulos with branches" /></a></p>
<h2 id="练习-5"><a class="header" href="#练习-5">练习</a></h2>
<ul>
<li>
<p>在这一点上，加快<code>Universe::tick</code>的下一个最低的目标是取消分配和释放。实现单元格的双重缓冲，即<code>Universe</code>维护两个向量，不释放其中任何一个，并且不在<code>tick</code>中分配新的缓冲。</p>
</li>
<li>
<p>实现 &quot;实现生命 &quot;一章中的另一种基于delta的设计，Rust代码将改变状态的单元格的列表返回给JavaScript。这是否使渲染到<code>&lt;canvas&gt;</code>的速度更快？你能实现这种设计而不在每次勾选时分配一个新的deltas列表吗？</p>
</li>
<li>
<p>正如我们的分析所显示的，2D <code>&lt;canvas&gt;</code>的渲染不是特别快。用<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a>渲染器取代2D画布渲染器。WebGL版本的速度有多大？在WebGL渲染成为瓶颈之前，你能把宇宙做得多大？</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="缩小wasm-大小"><a class="header" href="#缩小wasm-大小">缩小<code>.wasm</code> 大小</a></h1>
<p>对于我们通过网络发送给客户端的 <code>.wasm</code> 二进制文件，例如我们的 Game of Life Web 应用程序，我们希望关注代码大小。 我们的 <code>.wasm</code> 越小，我们的页面加载速度就越快，我们的用户就越开心。</p>
<h2 id="我们可以通过构建配置获得我们的-game-of-life-wasm-二进制文件有多小"><a class="header" href="#我们可以通过构建配置获得我们的-game-of-life-wasm-二进制文件有多小">我们可以通过构建配置获得我们的 Game of Life <code>.wasm</code> 二进制文件有多小？</a></h2>
<p><a href="game-of-life/../reference/code-size.html#%E9%92%88%E5%AF%B9%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E6%9E%84%E5%BB%BA">花点时间查看我们可以调整的构建配置选项以获得更小的 <code>.wasm</code> 代码大小。</a></p>
<p>使用默认的发布构建配置（没有调试符号），我们的 WebAssembly 二进制文件是 29,410 字节： </p>
<pre><code>$ wc -c pkg/wasm_game_of_life_bg.wasm
29410 pkg/wasm_game_of_life_bg.wasm
</code></pre>
<p>在启用 LTO、设置 <code>opt-level = &quot;z&quot;</code> 并运行 <code>wasm-opt -Oz</code> 后，生成的 <code>.wasm</code> 二进制文件缩小到只有 17,317 个字节： </p>
<pre><code>$ wc -c pkg/wasm_game_of_life_bg.wasm
17317 pkg/wasm_game_of_life_bg.wasm
</code></pre>
<p>如果我们用 <code>gzip</code> 压缩它（几乎每个 HTTP 服务器都会这样做），我们会减少到 9,045 字节！ </p>
<pre><code>$ gzip -9 &lt; pkg/wasm_game_of_life_bg.wasm | wc -c
9045
</code></pre>
<h2 id="练习-6"><a class="header" href="#练习-6">练习</a></h2>
<ul>
<li>
<p>使用 <a href="game-of-life/../reference/code-size.html#%E4%BD%BF%E7%94%A8-wasm-snip-%E5%B7%A5%E5%85%B7"><code>wasm-snip</code> 工具</a> 从我们的生命游戏的 <code>.wasm</code> 二进制文件中删除恐慌的基础设施功能。 它节省了多少字节？</p>
</li>
<li>
<p>使用和不使用 <a href="https://github.com/rustwasm/wee_alloc"><code>wee_alloc</code> 作为其全局分配器</a> 构建我们的游戏生命箱。 我们克隆来启动这个项目的 <code>rustwasm/wasm-pack-template</code> 模板有一个“wee_alloc”货物特性，您可以通过将其添加到 <code>wasm-game-of-life/Cargo.toml</code> 的 <code>[features]</code> 部分中的 <code>default</code> 键来启用：</p>
<pre><code class="language-toml">[features]
default = [&quot;wee_alloc&quot;]
</code></pre>
<p>使用 <code>wee_alloc</code> 可以减少 <code>.wasm</code> 二进制文件的大小吗？ </p>
</li>
<li>
<p>我们只实例化一个 <code>Universe</code>，因此我们可以导出操作单个 <code>static mut</code> 全局实例的操作，而不是提供构造函数。 如果这个全局实例也使用了前面章节中讨论过的双缓冲技术，我们可以使这些缓冲区也成为 <code>static mut</code> 全局变量。 这从我们的生命游戏实现中删除了所有动态分配，我们可以使它成为一个不包含分配器的 <code>#![no_std]</code> crate。 通过完全删除分配器依赖，从 <code>.wasm</code> 中删除了多少大小？ </p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="发布到-npm"><a class="header" href="#发布到-npm">发布到 npm</a></h1>
<p>现在我们有了一个有效的、快速的、<em>和</em>小的 <code>wasm-game-of-life</code> 包，我们可以将它发布到 npm 以便其他 JavaScript 开发人员可以重用它，如果他们需要一个现成的游戏 生活执行。</p>
<h2 id="先决条件"><a class="header" href="#先决条件">先决条件</a></h2>
<p>首先，<a href="https://www.npmjs.com/signup">确保您有一个 npm 帐户</a>。</p>
<p>其次，通过运行以下命令确保您在本地登录到您的帐户： </p>
<pre><code>wasm-pack login
</code></pre>
<h2 id="发布"><a class="header" href="#发布">发布</a></h2>
<p>通过在 <code>wasm-game-of-life</code> 目录中运行 <code>wasm-pack</code>，确保 <code>wasm-game-of-life/pkg</code> 构建是最新的： </p>
<pre><code>wasm-pack build
</code></pre>
<p>现在花点时间查看一下 <code>wasm-game-of-life/pkg</code> 的内容，这就是我们下一步要发布到 npm 的内容！</p>
<p>准备好后，运行 <code>wasm-pack publish</code> 将包上传到 npm： </p>
<pre><code>wasm-pack publish
</code></pre>
<p>这就是发布到 npm 所需的全部内容！</p>
<p>...除了其他人也完成了本教程，因此在 npm 上使用了 <code>wasm-game-of-life</code> 名称，最后一个命令可能不起作用。</p>
<p>打开 <code>wasm-game-of-life/Cargo.toml</code> 并将您的用户名添加到 <code>name</code> 的末尾，以独特的方式消除包的歧义：</p>
<pre><code class="language-toml">[package]
name = &quot;wasm-game-of-life-my-username&quot;
</code></pre>
<p>然后，重建并再次发布：</p>
<pre><code>wasm-pack build
wasm-pack publish
</code></pre>
<p>这次应该可以了！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>本节包含 Rust 和 WebAssembly 开发的参考资料。 它的目的不是提供叙述，而是从头到尾阅读。 相反，每个小节都应该独立存在。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="你应该知道的crates"><a class="header" href="#你应该知道的crates">你应该知道的Crates</a></h1>
<p>这是您在进行 Rust 和 WebAssembly 开发时应该了解的很棒的 crate 的精选列表。 </p>
<p><a href="https://crates.io/categories/wasm">您还可以在 WebAssembly 类别中浏览所有发布到 crates.io 的 crate.</a></p>
<h2 id="与-javascript-和-dom-交互"><a class="header" href="#与-javascript-和-dom-交互">与 JavaScript 和 DOM 交互</a></h2>
<h3 id="wasm-bindgen--a-hrefhttpscratesiocrateswasm-bindgencratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgenrepositorya"><a class="header" href="#wasm-bindgen--a-hrefhttpscratesiocrateswasm-bindgencratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgenrepositorya"><code>wasm-bindgen</code> | <a href="https://crates.io/crates/wasm-bindgen">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen">repository</a></a></h3>
<p><code>wasm-bindgen</code> 促进了 Rust 和 JavaScript 之间的高级交互。 它允许将 JavaScript 内容导入 Rust 并将 Rust 内容导出到 JavaScript。 </p>
<h3 id="wasm-bindgen-futures--a-hrefhttpscratesiocrateswasm-bindgen-futurescratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesfuturesrepositorya"><a class="header" href="#wasm-bindgen-futures--a-hrefhttpscratesiocrateswasm-bindgen-futurescratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesfuturesrepositorya"><code>wasm-bindgen-futures</code> | <a href="https://crates.io/crates/wasm-bindgen-futures">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/futures">repository</a></a></h3>
<p><code>wasm-bindgen-futures</code> 是连接 JavaScript <code>Promise</code>s 和 Rust <code>Future</code>s 的桥梁。 它可以双向转换，在 Rust 中处理异步任务时很有用，并允许与 DOM 事件和 I/O 操作进行交互。</p>
<h3 id="js-sys--a-hrefhttpscratesiocratesjs-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesjs-sysrepositorya"><a class="header" href="#js-sys--a-hrefhttpscratesiocratesjs-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesjs-sysrepositorya"><code>js-sys</code> | <a href="https://crates.io/crates/js-sys">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys">repository</a></a></h3>
<p>所有 JavaScript 全局类型和方法的原始 <code>wasm-bindgen</code> 导入，例如 <code>Object</code>、<code>Function</code>、<code>eval</code> 等。这些 API 可以在所有标准 ECMAScript 环境中移植，而不仅仅是 Web，例如 Node.js。</p>
<h3 id="web-sys--a-hrefhttpscratesiocratesweb-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesweb-sysrepositorya"><a class="header" href="#web-sys--a-hrefhttpscratesiocratesweb-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesweb-sysrepositorya"><code>web-sys</code> | <a href="https://crates.io/crates/web-sys">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/web-sys">repository</a></a></h3>
<p>所有 Web API 的原始 <code>wasm-bindgen</code> 导入，例如 DOM 操作、<code>setTimeout</code>、Web GL、Web Audio 等。</p>
<h2 id="错误报告和日志记录"><a class="header" href="#错误报告和日志记录">错误报告和日志记录</a></h2>
<h3 id="console_error_panic_hook--a-hrefhttpscratesiocratesconsole_error_panic_hookcratesioa--a-hrefhttpsgithubcomrustwasmconsole_error_panic_hookrepositorya"><a class="header" href="#console_error_panic_hook--a-hrefhttpscratesiocratesconsole_error_panic_hookcratesioa--a-hrefhttpsgithubcomrustwasmconsole_error_panic_hookrepositorya"><code>console_error_panic_hook</code> | <a href="https://crates.io/crates/console_error_panic_hook">crates.io</a> | <a href="https://github.com/rustwasm/console_error_panic_hook">repository</a></a></h3>
<p>这个 crate 允许你通过提供一个将 panic 消息转发到 <code>console.error</code> 的 panic 钩子来调试 <code>wasm32-unknown-unknown</code> 上的 panics。</p>
<h3 id="console_log--a-hrefhttpscratesiocratesconsole_logcratesioa--a-hrefhttpsgithubcomiamcodemakerconsole_logrepositorya"><a class="header" href="#console_log--a-hrefhttpscratesiocratesconsole_logcratesioa--a-hrefhttpsgithubcomiamcodemakerconsole_logrepositorya"><code>console_log</code> | <a href="https://crates.io/crates/console_log">crates.io</a> | <a href="https://github.com/iamcodemaker/console_log">repository</a></a></h3>
<p>此 crate 为 <a href="https://crates.io/crates/log">the <code>log</code> crate</a> 提供后端，将记录的消息路由到 devtools 控制台。</p>
<h2 id="动态分配"><a class="header" href="#动态分配">动态分配</a></h2>
<h3 id="wee_alloc--a-hrefhttpscratesiocrateswee_alloccratesioa--a-hrefhttpsgithubcomrustwasmwee_allocrepositorya"><a class="header" href="#wee_alloc--a-hrefhttpscratesiocrateswee_alloccratesioa--a-hrefhttpsgithubcomrustwasmwee_allocrepositorya"><code>wee_alloc</code> | <a href="https://crates.io/crates/wee_alloc">crates.io</a> | <a href="https://github.com/rustwasm/wee_alloc">repository</a></a></h3>
<p><strong>W</strong>asm-<strong>E</strong>nabled，<strong>E</strong>lfin 分配器。 当代码大小比分配性能更受关注时，一个小的（~1K 未压缩的<code>.wasm</code>）分配器实现。 </p>
<h2 id="解析和生成-wasm-二进制文件"><a class="header" href="#解析和生成-wasm-二进制文件">解析和生成 <code>.wasm</code> 二进制文件</a></h2>
<h3 id="parity-wasm--a-hrefhttpscratesiocratesparity-wasmcratesioa--a-hrefhttpsgithubcomparitytechparity-wasmrepositorya"><a class="header" href="#parity-wasm--a-hrefhttpscratesiocratesparity-wasmcratesioa--a-hrefhttpsgithubcomparitytechparity-wasmrepositorya"><code>parity-wasm</code> | <a href="https://crates.io/crates/parity-wasm">crates.io</a> | <a href="https://github.com/paritytech/parity-wasm">repository</a></a></h3>
<p>用于序列化、反序列化和构建 <code>.wasm</code> 二进制文件的低级 WebAssembly 格式库。 对众所周知的自定义部分的良好支持，例如 &quot;names&quot; 部分和 &quot;reloc.WHATEVER&quot; 部分。 </p>
<h3 id="wasmparser--a-hrefhttpscratesiocrateswasmparsercratesioa--a-hrefhttpsgithubcomyurydelendikwasmparserrsrepositorya"><a class="header" href="#wasmparser--a-hrefhttpscratesiocrateswasmparsercratesioa--a-hrefhttpsgithubcomyurydelendikwasmparserrsrepositorya"><code>wasmparser</code> | <a href="https://crates.io/crates/wasmparser">crates.io</a> | <a href="https://github.com/yurydelendik/wasmparser.rs">repository</a></a></h3>
<p>一个简单的、事件驱动的库，用于解析 WebAssembly 二进制文件。 提供每个已解析事物的字节偏移量，例如在解释 relocs 时这是必需的。</p>
<h2 id="解释和编译-webassembly"><a class="header" href="#解释和编译-webassembly">解释和编译 WebAssembly</a></h2>
<h3 id="wasmi--a-hrefhttpscratesiocrateswasmicratesioa--a-hrefhttpsgithubcomparitytechwasmirepositorya"><a class="header" href="#wasmi--a-hrefhttpscratesiocrateswasmicratesioa--a-hrefhttpsgithubcomparitytechwasmirepositorya"><code>wasmi</code> | <a href="https://crates.io/crates/wasmi">crates.io</a> | <a href="https://github.com/paritytech/wasmi">repository</a></a></h3>
<p>Parity 的可嵌入 WebAssembly 解释器。</p>
<h3 id="cranelift-wasm--a-hrefhttpscratesiocratescranelift-wasmcratesioa--a-hrefhttpsgithubcombytecodealliancewasmtimetreemastercraneliftrepositorya"><a class="header" href="#cranelift-wasm--a-hrefhttpscratesiocratescranelift-wasmcratesioa--a-hrefhttpsgithubcombytecodealliancewasmtimetreemastercraneliftrepositorya"><code>cranelift-wasm</code> | <a href="https://crates.io/crates/cranelift-wasm">crates.io</a> | <a href="https://github.com/bytecodealliance/wasmtime/tree/master/cranelift">repository</a></a></h3>
<p>将 WebAssembly 编译为本机主机的机器代码。 Cranelift (né Cretonne) 代码生成器项目的一部分。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="你应该知道的工具"><a class="header" href="#你应该知道的工具">你应该知道的工具</a></h1>
<p>这是在进行 Rust 和 WebAssembly 开发时你应该知道的一些很棒的工具的精选列表。</p>
<h2 id="开发构建和工作流编排"><a class="header" href="#开发构建和工作流编排">开发、构建和工作流编排</a></h2>
<h3 id="wasm-pack--a-hrefhttpsgithubcomrustwasmwasm-packrepositorya"><a class="header" href="#wasm-pack--a-hrefhttpsgithubcomrustwasmwasm-packrepositorya"><code>wasm-pack</code> | <a href="https://github.com/rustwasm/wasm-pack">repository</a></a></h3>
<p><code>wasm-pack</code> 旨在成为构建和使用 Rust 生成的 WebAssembly 的一站式商店，您希望与 JavaScript、Web 或 Node.js 进行互操作。 <code>wasm-pack</code> 可帮助您构建 Rust 生成的 WebAssembly 并将其发布到 npm 仓库，以便与您已经使用的工作流中的任何其他 JavaScript 包一起使用。 </p>
<h2 id="优化和操作-wasm-二进制文件"><a class="header" href="#优化和操作-wasm-二进制文件">优化和操作 <code>.wasm</code> 二进制文件</a></h2>
<h3 id="wasm-opt--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><a class="header" href="#wasm-opt--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><code>wasm-opt</code> | <a href="https://github.com/WebAssembly/binaryen">repository</a></a></h3>
<p><code>wasm-opt</code> 工具将 WebAssembly 读取为输入，对其运行转换、优化和/或检测传递，然后将转换后的 WebAssembly 作为输出发出。 在 LLVM 通过 <code>rustc</code> 生成的 <code>.wasm</code> 二进制文件上运行它通常会创建更小且执行速度更快的 <code>.wasm</code> 二进制文件。 这个工具是<code>binaryen</code> 项目的一部分。 </p>
<h3 id="wasm2js--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><a class="header" href="#wasm2js--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><code>wasm2js</code> | <a href="https://github.com/WebAssembly/binaryen">repository</a></a></h3>
<p><code>wasm2js</code> 工具将 WebAssembly 编译成“几乎是 asm.js”。 这非常适合支持没有 WebAssembly 实现的浏览器，例如 Internet Explorer 11。这个工具是 <code>binaryen</code> 项目的一部分。</p>
<h3 id="wasm-gc--a-hrefhttpsgithubcomalexcrichtonwasm-gcrepositorya"><a class="header" href="#wasm-gc--a-hrefhttpsgithubcomalexcrichtonwasm-gcrepositorya"><code>wasm-gc</code> | <a href="https://github.com/alexcrichton/wasm-gc">repository</a></a></h3>
<p>一个垃圾收集 WebAssembly 模块并删除所有不需要的导出、导入、函数等的小工具。这实际上是 WebAssembly 的一个 <code>--gc-sections</code> 链接器标志。</p>
<p>由于两个原因，您通常不需要自己使用此工具：</p>
<ol>
<li><code>rustc</code> 现在有一个足够新的 <code>lld</code> 版本，它支持 WebAssembly 的 <code>--gc-sections</code> 标志。 这会自动为 LTO 构建启用。</li>
<li><code>wasm-bindgen</code> CLI 工具会自动为你运行 <code>wasm-gc</code>。</li>
</ol>
<h3 id="wasm-snip--a-hrefhttpsgithubcomrustwasmwasm-sniprepositorya"><a class="header" href="#wasm-snip--a-hrefhttpsgithubcomrustwasmwasm-sniprepositorya"><code>wasm-snip</code> | <a href="https://github.com/rustwasm/wasm-snip">repository</a></a></h3>
<p><code>wasm-snip</code> 用 <code>unreachable</code> 指令替换了 WebAssembly 函数的主体。</p>
<p>也许您知道某些函数在运行时永远不会被调用，但是编译器无法在编译时证明这一点？ 剪吧！ 然后再次运行<code>wasm-gc</code>，它传递调用的所有函数（在运行时也永远不会被调用）也将被删除。</p>
<p>这对于在非调试生产版本中强行删除 Rust 的恐慌基础架构很有用。</p>
<h2 id="检查-wasm-二进制文件"><a class="header" href="#检查-wasm-二进制文件">检查 <code>.wasm</code> 二进制文件</a></h2>
<h3 id="twiggy--a-hrefhttpsgithubcomrustwasmtwiggyrepositorya"><a class="header" href="#twiggy--a-hrefhttpsgithubcomrustwasmtwiggyrepositorya"><code>twiggy</code> | <a href="https://github.com/rustwasm/twiggy">repository</a></a></h3>
<p><code>twiggy</code> 是 <code>.wasm</code> 二进制文件的代码大小分析器。 它分析二进制的调用图来回答以下问题：</p>
<ul>
<li>为什么这个函数首先包含在二进制文件中？ IE。 哪些导出的函数正在传递调用它？</li>
<li>这个函数的保留大小是多少？ IE。 如果我删除它以及删除后成为死代码的所有函数，将节省多少空间。</li>
</ul>
<p>使用 <code>twiggy</code> 使你的二进制文件变得苗条！</p>
<h3 id="wasm-objdump--a-hrefhttpsgithubcomwebassemblywabtrepositorya"><a class="header" href="#wasm-objdump--a-hrefhttpsgithubcomwebassemblywabtrepositorya"><code>wasm-objdump</code> | <a href="https://github.com/WebAssembly/wabt">repository</a></a></h3>
<p>打印有关 <code>.wasm</code> 二进制文件及其每个部分的低级详细信息。 还支持反汇编成 WAT 文本格式。 它就像<code>objdump</code>，但用于WebAssembly。 这是 WABT 项目的一部分。</p>
<h3 id="wasm-nm--a-hrefhttpsgithubcomfitzgenwasm-nmrepositorya"><a class="header" href="#wasm-nm--a-hrefhttpsgithubcomfitzgenwasm-nmrepositorya"><code>wasm-nm</code> | <a href="https://github.com/fitzgen/wasm-nm">repository</a></a></h3>
<p>列出在 <code>.wasm</code> 二进制文件中定义的导入、导出和私有函数符号。 它就像 <code>nm</code> 但对于 WebAssembly。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目模板"><a class="header" href="#项目模板">项目模板</a></h1>
<p>Rust 和 WebAssembly 工作组策划和维护各种项目模板，以帮助您启动新项目并开始运行。</p>
<h2 id="wasm-pack-template"><a class="header" href="#wasm-pack-template"><code>wasm-pack-template</code></a></h2>
<p><a href="https://github.com/rustwasm/wasm-pack-template">此模板</a> 用于启动 Rust 和 WebAssembly 项目，与 <a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a> 一起使用。</p>
<p>使用 <code>cargo generate</code> 来克隆这个项目模板：</p>
<pre><code>cargo install cargo-generate
cargo generate --git https://github.com/rustwasm/wasm-pack-template.git
</code></pre>
<h2 id="create-wasm-app"><a class="header" href="#create-wasm-app"><code>create-wasm-app</code></a></h2>
<p><a href="https://github.com/rustwasm/create-wasm-app">此模板</a> 适用于使用来自 npm 的包的 JavaScript 项目，这些包是使用 <a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a> 从 Rust 创建的。</p>
<p>与 <code>npm init</code> 一起使用：</p>
<pre><code>mkdir my-project
cd my-project/
npm init wasm-app
</code></pre>
<p>该模板通常与 <code>wasm-pack-template</code> 一起使用，其中 <code>wasm-pack-template</code> 项目通过 <code>npm link</code> 安装在本地，并作为 <code>create-wasm-app</code> 项目的依赖项引入。</p>
<h2 id="rust-webpack-template"><a class="header" href="#rust-webpack-template"><code>rust-webpack-template</code></a></h2>
<p><a href="https://github.com/rustwasm/rust-webpack-template">此模板</a> 预配置了所有样板，用于将 Rust 编译为 WebAssembly，并使用 Webpack 的 <a href="https://github.com/wasm-tool/rust-loader/"><code>rust-loader</code></a> 将其直接挂接到 Webpack 构建管道中。</p>
<p>与 <code>npm init</code> 一起使用：</p>
<pre><code>mkdir my-project
cd my-project/
npm init rust-webpack
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试-rust-生成的-webassembly"><a class="header" href="#调试-rust-生成的-webassembly">调试 Rust 生成的 WebAssembly</a></h1>
<p>本节包含调试 Rust 生成的 WebAssembly 的技巧。</p>
<h2 id="使用调试符号构建"><a class="header" href="#使用调试符号构建">使用调试符号构建</a></h2>
<blockquote>
<p>⚡ 调试时，请始终确保使用调试符号进行构建！</p>
</blockquote>
<p>如果你没有启用调试符号，那么在编译的 <code>.wasm</code> 二进制文件中将不会出现 <code>&quot;name&quot;</code> 自定义部分，并且堆栈跟踪将具有类似 <code>wasm-function[42]</code> 的函数名称，而不是函数的 Rust 名称，比如 <code>wasm_game_of_life::Universe::live_neighbor_count</code>。</p>
<p>当使用 &quot;debug&quot; 构建（又名 <code>wasm-pack build --debug</code> 或 <code>cargo build</code>）时，默认启用调试符号。</p>
<p>对于 &quot;release&quot; 版本，默认情况下不启用调试符号。 要启用调试符号，请确保在 <code>Cargo.toml</code> 的 <code>[profile.release]</code> 部分中设置 <code>debug = true</code>：</p>
<pre><code class="language-toml">[profile.release]
debug = true
</code></pre>
<h2 id="使用-console-api-进行日志记录"><a class="header" href="#使用-console-api-进行日志记录">使用 <code>console</code> API 进行日志记录</a></h2>
<p>日志记录是我们拥有的最有效的工具之一，用于证明和反驳关于我们的程序为什么有错误的假设。 在 Web 上，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/log"><code>console.log</code> 功能</a> 是将消息记录到浏览器的开发者工具控制台的方式 .</p>
<p>我们可以使用 <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html">the <code>web-sys</code> crate</a> 来访问 <code>console</code> 日志功能:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

web_sys::console::log_1(&amp;&quot;Hello, world!&quot;.into());
<span class="boring">}
</span></code></pre></pre>
<p>或者，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/error"><code>console.error</code> 函数</a> 具有与 <code>console.log</code> 相同的签名，但开发人员工具 当使用 <code>console.error</code> 时，往往还会在记录的消息旁边捕获和显示堆栈跟踪。</p>
<h3 id="references"><a class="header" href="#references">References</a></h3>
<ul>
<li>使用 <code>console.log</code> 和 <code>web-sys</code> crate:
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html"><code>web_sys::console::log</code> 取一个数组的值来记录</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html"><code>web_sys::console::log_1</code> 记录一个单一的值</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html"><code>web_sys::console::log_2</code> 记录了两个值</a></li>
<li>Etc...</li>
</ul>
</li>
<li>使用 <code>console.error</code> 与 <code>web-sys</code> crate:
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html"><code>web_sys::console::error</code> 取一个数组的值来记录</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html"><code>web_sys::console::error_1</code> 记录一个单一的值</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html"><code>web_sys::console::error_2</code> 记录了两个值</a></li>
<li>Etc...</li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console">MDN上的 <code>console</code> 对象</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Web_Console">火狐浏览器开发者工具 - 网络控制台</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/console">微软EDGE开发工具 - 控制台</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/console/get-started">开始使用 Chrome DevTools 控制台</a></li>
</ul>
<h2 id="记录-panics"><a class="header" href="#记录-panics">记录 Panics</a></h2>
<p><a href="https://github.com/rustwasm/console_error_panic_hook"><code>console_error_panic_hook</code> crate 通过 <code>console.error</code> 将意外的恐慌记录到开发者控制台。</a> 而不是获得神秘的、难以调试的 <code>RuntimeError: unreachable execution</code> 错误消息，这给你 Rust 的格式化 恐慌信息。</p>
<p>您需要做的就是通过在初始化函数或公共代码路径中调用 <code>console_error_panic_hook::set_once()</code> 来安装钩子： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn init_panic_hook() {
    console_error_panic_hook::set_once();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="使用调试器"><a class="header" href="#使用调试器">使用调试器</a></h2>
<p>不幸的是，WebAssembly 的调试故事仍然不成熟。 在大多数 Unix 系统上，<a href="http://dwarfstd.org/">DWARF</a> 用于对调试器提供正在运行的程序的源代码级检查所需的信息进行编码。 有一种替代格式可以对 Windows 上的类似信息进行编码。 目前，没有 WebAssembly 的等价物。 因此，调试器目前提供的实用程序有限，我们最终会逐步执行编译器发出的原始 WebAssembly 指令，而不是我们编写的 Rust 源文本。</p>
<blockquote>
<p>有一个<a href="https://github.com/WebAssembly/debugging">W3C WebAssembly 小组调试子章程</a>，所以期待这个故事在未来得到改进！ </p>
</blockquote>
<p>尽管如此，调试器对于检查与我们的 WebAssembly 交互的 JavaScript 和检查原始 wasm 状态仍然很有用。</p>
<h3 id="参考"><a class="header" href="#参考">参考</a></h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger">Firefox 开发者工具 — 调试器</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/debugger">Microsoft Edge 开发者工具 — 调试器</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/">在 Chrome DevTools 中开始调试 JavaScript</a></li>
</ul>
<h2 id="首先避免调试-webassembly"><a class="header" href="#首先避免调试-webassembly">首先避免调试 WebAssembly</a></h2>
<p>如果该错误特定于与 JavaScript 或 Web API 的交互，则 <a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html">使用 <code>wasm-bindgen-test</code> 编写测试。</a></p>
<p>如果错误<em>不</em>涉及与 JavaScript 或 Web API 的交互，那么尝试将其复制为普通的 Rust <code>#[test]</code> 函数，您可以在调试时利用操作系统成熟的本机工具。 使用像 <a href="https://crates.io/crates/quickcheck"><code>quickcheck</code></a> 和它的测试用例收缩器这样的测试箱来机械地减少测试用例。 最终，如果您可以在不需要与 JavaScript 交互的较小测试用例中隔离它们，您将更容易找到和修复错误。</p>
<p>请注意，为了在没有编译器和链接器错误的情况下运行本机 <code>#[test]</code>，您需要确保 <code>&quot;rlib&quot;</code> 包含在 <code>Cargo. toml</code> 文件。</p>
<pre><code class="language-toml">[lib]
crate-type [&quot;cdylib&quot;, &quot;rlib&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间分析-1"><a class="header" href="#时间分析-1">时间分析</a></h1>
<p>本节介绍如何使用 Rust 和 WebAssembly 分析网页，其目标是提高吞吐量或延迟。</p>
<blockquote>
<p>⚡ 始终确保在分析时使用优化的构建！ <code>wasm-pack build</code> 将默认进行优化构建。 </p>
</blockquote>
<h2 id="可用工具"><a class="header" href="#可用工具">可用工具</a></h2>
<h3 id="windowperformancenow-计时器"><a class="header" href="#windowperformancenow-计时器"><code>window.performance.now()</code> 计时器</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now"><code>performance.now()</code> 函数</a> 返回自网页加载以来以毫秒为单位的单调时间戳。</p>
<p>调用 <code>performance.now</code> 的开销很小，因此我们可以从中创建简单、细粒度的测量，而不会扭曲系统其余部分的性能并对我们的测量造成偏差。</p>
<p>我们可以用它来为各种操作计时，我们可以通过<a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html"><code>web-sys</code> crate</a> 访问<code>window.performance.now()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

fn now() -&gt; f64 {
    web_sys::window()
        .expect(&quot;should have a Window&quot;)
        .performance()
        .expect(&quot;should have a Performance&quot;)
        .now()
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/fn.window.html">The <code>web_sys::window</code> function</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.performance">The <code>web_sys::Window::performance</code> method</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Performance.html#method.now">The <code>web_sys::Performance::now</code> method</a></li>
</ul>
<h3 id="开发者工具分析器"><a class="header" href="#开发者工具分析器">开发者工具分析器</a></h3>
<p>所有 Web 浏览器的内置开发人员工具都包含一个分析器。 这些分析器通过调用树和火焰图等常见类型的可视化显示哪些函数占用的时间最多。</p>
<p>如果您 <a href="reference/./debugging.html#building-with-debug-symbols">使用调试符号构建</a> 以便“名称”自定义部分包含在 wasm 二进制文件中，那么这些分析器应该显示 Rust 函数名称，而不是像 <code>wasm-function[123]</code> 这样不透明的东西。</p>
<p>请注意，这些分析器<em>不会</em>显示内联函数，并且由于 Rust 和 LLVM 非常依赖内联，因此结果可能仍然有点令人困惑。</p>
<p><a href="reference/../images/game-of-life/profiler-with-rust-names.png"><img src="reference/../images/game-of-life/profiler-with-rust-names.png" alt="Screenshot of profiler with Rust symbols" /></a></p>
<h4 id="资源"><a class="header" href="#资源">资源</a></h4>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Performance">Firefox 开发者工具——性能</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/performance">Microsoft Edge 开发者工具——性能</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution">Chrome DevTools JavaScript Profiler</a></li>
</ul>
<h3 id="consoletime-和-consoletimeend-函数"><a class="header" href="#consoletime-和-consoletimeend-函数"><code>console.time</code> 和 <code>console.timeEnd</code> 函数</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/time"><code>console.time</code> 和 <code>console.timeEnd</code> 函数</a> 允许您将命名操作的时间记录到浏览器的开发者工具控制台。 你在操作开始时调用<code>console.time(&quot;some operation&quot;)</code>，在操作结束时调用<code>console.timeEnd(&quot;some operation&quot;)</code>。 命名操作的字符串标签是可选的。</p>
<p>您可以直接通过 <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html"><code>web-sys</code> crate</a> 使用这些函数：</p>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_with_label.html"><code>web_sys::console::time_with_label(&quot;some operation&quot;)</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_end_with_label.html"><code>web_sys::console::time_end_with_label(&quot;some operation&quot;)</code></a></li>
</ul>
<p>这是浏览器控制台中 <code>console.time</code> 日志的屏幕截图：</p>
<p><a href="reference/../images/game-of-life/console-time.png"><img src="reference/../images/game-of-life/console-time.png" alt="Screenshot of console.time logs" /></a></p>
<p>此外，<code>console.time</code> 和 <code>console.timeEnd</code> 日志将显示在浏览器分析器的“时间轴”或“瀑布”视图中： </p>
<p><a href="reference/../images/game-of-life/console-time-in-profiler.png"><img src="reference/../images/game-of-life/console-time-in-profiler.png" alt="Screenshot of console.time logs" /></a></p>
<h3 id="在本机代码中使用-bench"><a class="header" href="#在本机代码中使用-bench">在本机代码中使用 <code>#[bench]</code></a></h3>
<p>与我们通常可以通过编写 <code>#[test]</code>s 而不是在 Web 上调试来利用操作系统的本机代码调试工具一样，我们可以通过编写 <code>#[bench]</code> 函数来利用操作系统的本机代码分析工具。</p>
<p>在 crate 的 <code>benches</code> 子目录中写入你的基准。 确保你的 <code>crate-type</code> 包含 <code>&quot;rlib&quot;</code>，否则 bench 二进制文件将无法链接你的主库。</p>
<p>然而！ 在投入大量精力进行本机代码分析之前，请确保您知道瓶颈在 WebAssembly 中！ 使用浏览器的分析器来确认这一点，否则您可能会浪费时间优化不热门的代码。 </p>
<h4 id="资源-1"><a class="header" href="#资源-1">资源</a></h4>
<ul>
<li><a href="http://www.brendangregg.com/perf.html">在Linux上使用<code>perf</code>剖析器</a></li>
<li><a href="https://help.apple.com/instruments/mac/current/">在MacOS上使用Instruments.app分析器</a></li>
<li><a href="https://software.intel.com/en-us/vtune">VTune剖析器支持Windows和Linux</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shrinking-wasm-code-size"><a class="header" href="#shrinking-wasm-code-size">Shrinking <code>.wasm</code> Code Size</a></h1>
<p>This section will teach you how to optimize your <code>.wasm</code> build for a small code
size footprint, and how to identify opportunities to change your Rust source
such that less <code>.wasm</code> code is emitted.</p>
<h2 id="why-care-about-code-size"><a class="header" href="#why-care-about-code-size">Why Care About Code Size?</a></h2>
<p>When serving a <code>.wasm</code> file over the network, the smaller it is, the faster the
client can download it. Faster <code>.wasm</code> downloads lead to faster page load times,
and that leads to happier users.</p>
<p>However, it's important to remember though that code size likely isn't the
end-all-be-all metric you're interested in, but rather something much more vague
and hard to measure like &quot;time to first interaction&quot;. While code size plays a
large factor in this measurement (can't do anything if you don't even have all
the code yet!) it's not the only factor.</p>
<p>WebAssembly is typically served to users gzip'd so you'll want to be sure to
compare differences in gzip'd size for transfer times over the wire. Also keep
in mind that the WebAssembly binary format is quite amenable to gzip
compression, often getting over 50% reductions in size.</p>
<p>Furthermore, WebAssembly's binary format is optimized for very fast parsing and
processing. Browsers nowadays have &quot;baseline compilers&quot; which parses WebAssembly
and emits compiled code as fast as wasm can come in over the network. This means
that <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">if you're using <code>instantiateStreaming</code></a> the second the Web request
is done the WebAssembly module is probably ready to go. JavaScript, on the other
hand, can often take longer to not only parse but also get up to speed with JIT
compilation and such.</p>
<p>And finally, remember that WebAssembly is also far more optimized than
JavaScript for execution speed. You'll want to be sure to measure for runtime
comparisons between JavaScript and WebAssembly to factor that in to how
important code size is.</p>
<p>All this to say basically don't dismay immediately if your <code>.wasm</code> file is
larger than expected! Code size may end up only being one of many factors in the
end-to-end story. Comparisons between JavaScript and WebAssembly that only look
at code size are missing the forest for the trees.</p>
<h2 id="针对代码大小优化构建"><a class="header" href="#针对代码大小优化构建">针对代码大小优化构建</a></h2>
<p>There are a bunch of configuration options we can use to get <code>rustc</code> to make
smaller <code>.wasm</code> binaries. In some cases, we are trading longer compile times for
smaller <code>.wasm</code> sizes. In other cases, we are trading runtime speed of the
WebAssembly for smaller code size. We should be cognizant of the trade offs of
each option, and in the cases where we trade runtime speed for code size,
profile and measure to make an informed decision about whether the trade is
worth it.</p>
<h3 id="compiling-with-link-time-optimizations-lto"><a class="header" href="#compiling-with-link-time-optimizations-lto">Compiling with Link Time Optimizations (LTO)</a></h3>
<p>In <code>Cargo.toml</code>, add <code>lto = true</code> in the <code>[profile.release]</code> section:</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<p>This gives LLVM many more opportunities to inline and prune functions. Not only
will it make the <code>.wasm</code> smaller, but it will also make it faster at runtime!
The downside is that compilation will take longer.</p>
<h3 id="tell-llvm-to-optimize-for-size-instead-of-speed"><a class="header" href="#tell-llvm-to-optimize-for-size-instead-of-speed">Tell LLVM to Optimize for Size Instead of Speed</a></h3>
<p>LLVM's optimization passes are tuned to improve speed, not size, by default. We
can change the goal to code size by modifying the <code>[profile.release]</code> section in
<code>Cargo.toml</code> to this:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>Or, to even more aggressively optimize for size, at further potential speed
costs:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<p>Note that, surprisingly enough, <code>opt-level = &quot;s&quot;</code> can sometimes result in
smaller binaries than <code>opt-level = &quot;z&quot;</code>. Always measure!</p>
<h3 id="use-the-wasm-opt-tool"><a class="header" href="#use-the-wasm-opt-tool">Use the <code>wasm-opt</code> Tool</a></h3>
<p>The <a href="https://github.com/WebAssembly/binaryen">Binaryen</a> toolkit is a collection of WebAssembly-specific compiler
tools. It goes much further than LLVM's WebAssembly backend does, and using its
<code>wasm-opt</code> tool to post-process a <code>.wasm</code> binary generated by LLVM can often get
another 15-20% savings on code size. It will often produce runtime speed ups at
the same time!</p>
<pre><code class="language-bash"># Optimize for size.
wasm-opt -Os -o output.wasm input.wasm

# Optimize aggressively for size.
wasm-opt -Oz -o output.wasm input.wasm

# Optimize for speed.
wasm-opt -O -o output.wasm input.wasm

# Optimize aggressively for speed.
wasm-opt -O3 -o output.wasm input.wasm
</code></pre>
<h3 id="notes-about-debug-information"><a class="header" href="#notes-about-debug-information">Notes about Debug Information</a></h3>
<p>One of the biggest contributors to wasm binary size can be debug information and
the <code>names</code> section of the wasm binary. The <code>wasm-pack</code> tool, however, removes
debuginfo by default. Additionally <code>wasm-opt</code> removes the <code>names</code> section by
default unless <code>-g</code> is also specified.</p>
<p>This means that if you follow the above steps you should by default not have
either debuginfo or the names section in the wasm binary. If, however, you are
manually otherwise preserving this debug information in the wasm binary be sure
to be mindful of this!</p>
<h2 id="size-profiling"><a class="header" href="#size-profiling">Size Profiling</a></h2>
<p>If tweaking build configurations to optimize for code size isn't resulting in a
small enough <code>.wasm</code> binary, it is time to do some profiling to see where the
remaining code size is coming from.</p>
<blockquote>
<p>⚡ Just like how we let time profiling guide our speed up efforts, we want to
let size profiling guide our code size shrinking efforts. Fail to do this and
you risk wasting your own time!</p>
</blockquote>
<h3 id="the-twiggy-code-size-profiler"><a class="header" href="#the-twiggy-code-size-profiler">The <code>twiggy</code> Code Size Profiler</a></h3>
<p><a href="https://github.com/rustwasm/twiggy"><code>twiggy</code> is a code size profiler</a> that supports WebAssembly as
input. It analyzes a binary's call graph to answer questions like:</p>
<ul>
<li>
<p>Why was this function included in the binary in the first place?</p>
</li>
<li>
<p>What is the <em>retained size</em> of this function? I.e. how much space would be
saved if I removed it and all the functions that become dead code after its
removal?</p>
</li>
</ul>
<style>
/* For whatever reason, the default mdbook fonts fonts break with the
   following box-drawing characters, hence the manual style. */
pre, code {
  font-family: "SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;
}
</style>
<pre><code class="language-text">$ twiggy top -n 20 pkg/wasm_game_of_life_bg.wasm
 Shallow Bytes │ Shallow % │ Item
───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────
          9158 ┊    19.65% ┊ &quot;function names&quot; subsection
          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8
          2510 ┊     5.39% ┊ &lt;str as core::fmt::Debug&gt;::fmt::he0d87479d1c208ea
          1737 ┊     3.73% ┊ data[0]
          1574 ┊     3.38% ┊ data[3]
          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5
          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d
          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced
          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b
          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605
           931 ┊     2.00% ┊ data[4]
           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05
           841 ┊     1.80% ┊ &lt;char as core::fmt::Debug&gt;::fmt::h07742d9f4a8c56f2
           813 ┊     1.74% ┊ __rust_realloc
           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85
           678 ┊     1.45% ┊ &lt;core::fmt::builders::PadAdapter&lt;'a&gt; as core::fmt::Write&gt;::write_str::h96b72fb7457d3062
           631 ┊     1.35% ┊ universe_tick
           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8
           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5
           503 ┊     1.08% ┊ &lt;&amp;'a T as core::fmt::Debug&gt;::fmt::hba207e4f7abaece6
</code></pre>
<h3 id="manually-inspecting-llvm-ir"><a class="header" href="#manually-inspecting-llvm-ir">Manually Inspecting LLVM-IR</a></h3>
<p>LLVM-IR is the final intermediate representation in the compiler toolchain
before LLVM generates WebAssembly. Therefore, it is very similar to the
WebAssembly that is ultimately emitted. More LLVM-IR generally means more
<code>.wasm</code> size, and if a function takes up 25% of the LLVM-IR, then it generally
will take up 25% of the <code>.wasm</code>. While these numbers only hold in general, the
LLVM-IR has crucial information that is not present in the <code>.wasm</code> (because of
WebAssembly's lack of a debugging format like DWARF): which subroutines were
inlined into a given function.</p>
<p>You can generate LLVM-IR with this <code>cargo</code> command:</p>
<pre><code>cargo rustc --release -- --emit llvm-ir
</code></pre>
<p>Then, you can use <code>find</code> to locate the <code>.ll</code> file containing the LLVM-IR in
<code>cargo</code>'s <code>target</code> directory:</p>
<pre><code>find target/release -type f -name '*.ll'
</code></pre>
<h4 id="references-1"><a class="header" href="#references-1">References</a></h4>
<ul>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM Language Reference Manual</a></li>
</ul>
<h2 id="more-invasive-tools-and-techniques"><a class="header" href="#more-invasive-tools-and-techniques">More Invasive Tools and Techniques</a></h2>
<p>Tweaking build configurations to get smaller <code>.wasm</code> binaries is pretty hands
off. When you need to go the extra mile, however, you are prepared to use more
invasive techniques, like rewriting source code to avoid bloat. What follows is
a collection of get-your-hands-dirty techniques you can apply to get smaller
code sizes.</p>
<h3 id="avoid-string-formatting"><a class="header" href="#avoid-string-formatting">Avoid String Formatting</a></h3>
<p><code>format!</code>, <code>to_string</code>, etc... can bring in a lot of code bloat. If possible,
only do string formatting in debug mode, and in release mode use static strings.</p>
<h3 id="avoid-panicking"><a class="header" href="#avoid-panicking">Avoid Panicking</a></h3>
<p>This is definitely easier said than done, but tools like <code>twiggy</code> and manually
inspecting LLVM-IR can help you figure out which functions are panicking.</p>
<p>Panics do not always appear as a <code>panic!()</code> macro invocation. They arise
implicitly from many constructs, such as:</p>
<ul>
<li>
<p>Indexing a slice panics on out of bounds indices: <code>my_slice[i]</code></p>
</li>
<li>
<p>Division will panic if the divisor is zero: <code>dividend / divisor</code></p>
</li>
<li>
<p>Unwrapping an <code>Option</code> or <code>Result</code>: <code>opt.unwrap()</code> or <code>res.unwrap()</code></p>
</li>
</ul>
<p>The first two can be translated into the third. Indexing can be replaced with
fallible <code>my_slice.get(i)</code> operations. Division can be replaced with
<code>checked_div</code> calls. Now we only have a single case to contend with.</p>
<p>Unwrapping an <code>Option</code> or <code>Result</code> without panicking comes in two flavors: safe
and unsafe.</p>
<p>The safe approach is to <code>abort</code> instead of panicking when encountering a <code>None</code>
or an <code>Error</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub fn unwrap_abort&lt;T&gt;(o: Option&lt;T&gt;) -&gt; T {
    use std::process;
    match o {
        Some(t) =&gt; t,
        None =&gt; process::abort(),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ultimately, panics translate into aborts in <code>wasm32-unknown-unknown</code> anyways, so
this gives you the same behavior but without the code bloat.</p>
<p>Alternatively, the <a href="https://crates.io/crates/unreachable"><code>unreachable</code> crate</a> provides an unsafe
<a href="https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap"><code>unchecked_unwrap</code> extension method</a> for <code>Option</code> and
<code>Result</code> which tells the Rust compiler to <em>assume</em> that the <code>Option</code> is <code>Some</code>
or the <code>Result</code> is <code>Ok</code>. It is undefined behavior what happens if that
assumption does not hold. You really only want to use this unsafe approach when
you 110% <em>know</em> that the assumption holds, and the compiler just isn't smart
enough to see it. Even if you go down this route, you should have a debug build
configuration that still does the checking, and only use unchecked operations in
release builds.</p>
<h3 id="avoid-allocation-or-switch-to-wee_alloc"><a class="header" href="#avoid-allocation-or-switch-to-wee_alloc">Avoid Allocation or Switch to <code>wee_alloc</code></a></h3>
<p>Rust's default allocator for WebAssembly is a port of <code>dlmalloc</code> to Rust. It
weighs in somewhere around ten kilobytes. If you can completely avoid dynamic
allocation, then you should be able to shed those ten kilobytes.</p>
<p>Completely avoiding dynamic allocation can be very difficult. But removing
allocation from hot code paths is usually much easier (and usually helps make
those hot code paths faster, as well). In these cases, <a href="https://github.com/rustwasm/wee_alloc">replacing the default
global allocator with <code>wee_alloc</code></a> should save you most (but not
quite all) of those ten kilobytes. <code>wee_alloc</code> is an allocator designed for
situations where you need <em>some</em> kind of allocator, but do not need a
particularly fast allocator, and will happily trade allocation speed for smaller
code size.</p>
<h3 id="use-trait-objects-instead-of-generic-type-parameters"><a class="header" href="#use-trait-objects-instead-of-generic-type-parameters">Use Trait Objects Instead of Generic Type Parameters</a></h3>
<p>When you create generic functions that use type parameters, like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whatever&lt;T: MyTrait&gt;(t: T) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>Then <code>rustc</code> and LLVM will create a new copy of the function for each <code>T</code> type
that the function is used with. This presents many opportunities for compiler
optimizations based on which particular <code>T</code> each copy is working with, but these
copies add up quickly in terms of code size.</p>
<p>If you use trait objects instead of type parameters, like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whatever(t: Box&lt;MyTrait&gt;) { ... }
// or
fn whatever(t: &amp;MyTrait) { ... }
// etc...
<span class="boring">}
</span></code></pre></pre>
<p>Then dynamic dispatch via virtual calls is used, and only a single version of
the function is emitted in the <code>.wasm</code>. The downside is the loss of the compiler
optimization opportunities and the added cost of indirect, dynamically
dispatched function calls.</p>
<h3 id="使用-wasm-snip-工具"><a class="header" href="#使用-wasm-snip-工具">使用 wasm-snip 工具</a></h3>
<p><a href="https://github.com/fitzgen/wasm-snip"><code>wasm-snip</code> replaces a WebAssembly function's body with an <code>unreachable</code>
instruction.</a> This is a rather heavy, blunt hammer for functions that kind
of look like nails if you squint hard enough.</p>
<p>Maybe you know that some function will never be called at runtime, but the
compiler can't prove that at compile time? Snip it! Afterwards, run <code>wasm-opt</code>
again with the <code>--dce</code> flag, and all the functions that the snipped function
transitively called (which could also never be called at runtime) will get
removed too.</p>
<p>This tool is particularly useful for removing the panicking infrastructure,
since panics ultimately translate into traps anyways.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-interoperation"><a class="header" href="#javascript-interoperation">JavaScript Interoperation</a></h1>
<h2 id="importing-and-exporting-js-functions"><a class="header" href="#importing-and-exporting-js-functions">Importing and Exporting JS Functions</a></h2>
<h3 id="from-the-rust-side"><a class="header" href="#from-the-rust-side">From the Rust Side</a></h3>
<p>When using wasm within a JS host, importing and exporting functions from the
Rust side is straightforward: it works very similarly to C.</p>
<p>WebAssembly modules declare a sequence of imports, each with a <em>module name</em>
and an <em>import name</em>. The module name for an <code>extern { ... }</code> block can be
specified using <a href="https://github.com/rust-lang/rust/issues/52090"><code>#[link(wasm_import_module)]</code></a>, currently
it defaults to &quot;env&quot;.</p>
<p>Exports have only a single name. In addition to any <code>extern</code> functions the
WebAssembly instance's default linear memory is exported as &quot;memory&quot;.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// import a JS function called `foo` from the module `mod`
#[link(wasm_import_module = &quot;mod&quot;)]
extern { fn foo(); }

// export a Rust function called `bar`
#[no_mangle]
pub extern fn bar() { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>Because of wasm's limited value types, these functions must operate only on
primitive numeric types.</p>
<h3 id="from-the-js-side"><a class="header" href="#from-the-js-side">From the JS Side</a></h3>
<p>Within JS, a wasm binary turns into an ES6 module. It must be <em>instantiated</em>
with linear memory and have a set of JS functions matching the expected
imports.  The details of instantiation are available on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">MDN</a>.</p>
<p>The resulting ES6 module will contain all of the functions exported from Rust, now
available as JS functions.</p>
<p><a href="https://www.hellorust.com/demos/add/index.html">Here</a> is a very simple example of the whole setup in action.</p>
<h2 id="going-beyond-numerics"><a class="header" href="#going-beyond-numerics">Going Beyond Numerics</a></h2>
<p>When using wasm within JS, there is a sharp split between the wasm module's
memory and the JS memory:</p>
<ul>
<li>
<p>Each wasm module has a linear memory (described at the top of this document),
which is initialized during instantiation. <strong>JS code can freely read and write
to this memory</strong>.</p>
</li>
<li>
<p>By contrast, wasm code has no <em>direct</em> access to JS objects.</p>
</li>
</ul>
<p>Thus, sophisticated interop happens in two main ways:</p>
<ul>
<li>
<p>Copying in or out binary data to the wasm memory. For example, this is one way
to provide an owned <code>String</code> to the Rust side.</p>
</li>
<li>
<p>Setting up an explicit &quot;heap&quot; of JS objects which are then given
&quot;addresses&quot;. This allows wasm code to refer to JS objects indirectly (using
integers), and operate on those objects by invoking imported JS functions.</p>
</li>
</ul>
<p>Fortunately, this interop story is very amenable to treatment through a generic
&quot;bindgen&quot;-style framework: <a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a>. The framework makes it possible to
write idiomatic Rust function signatures that map to idiomatic JS functions,
automatically.</p>
<h2 id="custom-sections"><a class="header" href="#custom-sections">Custom Sections</a></h2>
<p>Custom sections allow embedding named arbitrary data into a wasm module. The
section data is set at compile time and is read directly from the wasm module,
it cannot be modified at runtime.</p>
<p>In Rust, custom sections are static arrays (<code>[T; size]</code>) exposed with the
<code>#[link_section]</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link_section = &quot;hello&quot;]
pub static SECTION: [u8; 24] = *b&quot;This is a custom section&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>This adds a custom section named <code>hello</code> to the wasm file, the rust variable
name <code>SECTION</code> is arbitrary, changing it wouldn't alter the behaviour. The
contents are bytes of text here but could be any arbitrary data.</p>
<p>The custom sections can be read on the JS side using the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections"><code>WebAssembly.Module.customSections</code></a> function, it takes a wasm Module and the
section name as arguments and returns an Array of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>s. Multiple
sections may be specified using the same name, in which case they will all
appear in this array.</p>
<pre><code class="language-js">WebAssembly.compileStreaming(fetch(&quot;sections.wasm&quot;))
.then(mod =&gt; {
  const sections = WebAssembly.Module.customSections(mod, &quot;hello&quot;);

  const decoder = new TextDecoder();
  const text = decoder.decode(sections[0]);

  console.log(text); // -&gt; &quot;This is a custom section&quot;
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="which-crates-will-work-off-the-shelf-with-webassembly"><a class="header" href="#which-crates-will-work-off-the-shelf-with-webassembly">Which Crates Will Work Off-the-Shelf with WebAssembly?</a></h1>
<p>It is easiest to list the things that do <em>not</em> currently work with WebAssembly;
crates which avoid these things tend to be portable to WebAssembly and usually
<em>Just Work</em>. A good rule of thumb is that if a crate supports embedded and
<code>#![no_std]</code> usage, it probably also supports WebAssembly.</p>
<h2 id="things-a-crate-might-do-that-wont-work-with-webassembly"><a class="header" href="#things-a-crate-might-do-that-wont-work-with-webassembly">Things a Crate Might do that Won't Work with WebAssembly</a></h2>
<h3 id="c-and-system-library-dependencies"><a class="header" href="#c-and-system-library-dependencies">C and System Library Dependencies</a></h3>
<p>There are no system libraries in wasm, so any crate that tries to bind to a
system library won't work.</p>
<p>Using C libraries will also probably fail to work, since wasm doesn't have a
stable ABI for cross-language communication, and cross-language linking for wasm
is very finicky. Everyone wants this to work eventually, especially since
<code>clang</code> is shipping their <code>wasm32</code> target by default now, but the story isn't
quite there yet.</p>
<h3 id="file-io"><a class="header" href="#file-io">File I/O</a></h3>
<p>WebAssembly does not have access to a file system, so crates that assume the
existence of a file system — and don't have wasm-specific workarounds
— will not work.</p>
<h3 id="spawning-threads"><a class="header" href="#spawning-threads">Spawning Threads</a></h3>
<p>There are <a href="https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html">plans to add threading to WebAssembly</a>, but it isn't
shipping yet. Attempts to spawn on a thread on the <code>wasm32-unknown-unknown</code>
target will panic, which triggers a wasm trap.</p>
<h2 id="so-which-general-purpose-crates-tend-to-work-off-the-shelf-with-webassembly"><a class="header" href="#so-which-general-purpose-crates-tend-to-work-off-the-shelf-with-webassembly">So Which General Purpose Crates Tend to Work Off-the-Shelf with WebAssembly?</a></h2>
<h3 id="algorithms-and-data-structures"><a class="header" href="#algorithms-and-data-structures">Algorithms and Data Structures</a></h3>
<p>Crates that provide the implementation of a particular
<a href="https://crates.io/categories/algorithms">algorithm</a> or <a href="https://crates.io/categories/data-structures">data
structure</a>, for example A* graph
search or splay trees, tend to work well with WebAssembly.</p>
<h3 id="no_std"><a class="header" href="#no_std"><code>#![no_std]</code></a></h3>
<p><a href="https://crates.io/categories/no-std">Crates that do not rely on the standard
library</a> tend to work well with
WebAssembly.</p>
<h3 id="parsers"><a class="header" href="#parsers">Parsers</a></h3>
<p><a href="https://crates.io/categories/parser-implementations">Parsers</a> — so long
as they just take input and don't perform their own I/O — tend to work
well with WebAssembly.</p>
<h3 id="text-processing"><a class="header" href="#text-processing">Text Processing</a></h3>
<p><a href="https://crates.io/categories/text-processing">Crates that deal with the complexities of human language when expressed in
textual form</a> tend to work well
with WebAssembly.</p>
<h3 id="rust-patterns"><a class="header" href="#rust-patterns">Rust Patterns</a></h3>
<p><a href="https://crates.io/categories/rust-patterns">Shared solutions for particular situations specific to programming in
Rust</a> tend to work well with WebAssembly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-add-webassembly-support-to-a-general-purpose-crate"><a class="header" href="#how-to-add-webassembly-support-to-a-general-purpose-crate">How to Add WebAssembly Support to a General-Purpose Crate</a></h1>
<p>This section is for general-purpose crate authors who want to support
WebAssembly.</p>
<h2 id="maybe-your-crate-already-supports-webassembly"><a class="header" href="#maybe-your-crate-already-supports-webassembly">Maybe Your Crate Already Supports WebAssembly!</a></h2>
<p>Review the information about <a href="reference/./which-crates-work-with-wasm.html">what kinds of things can make a general-purpose
crate <em>not</em> portable for WebAssembly</a>. If
your crate doesn't have any of those things, it likely already supports
WebAssembly!</p>
<p>You can always check by running <code>cargo build</code> for the WebAssembly target:</p>
<pre><code>cargo build --target wasm32-unknown-unknown
</code></pre>
<p>If that command fails, then your crate doesn't support WebAssembly right now. If
it doesn't fail, then your crate <em>might</em> support WebAssembly. You can be 100%
sure that it does (and continues to do so!) by <a href="reference/add-wasm-support-to-crate.html#maintaining-ongoing-support-for-webassembly">adding tests for wasm and
running those tests in CI.</a></p>
<h2 id="adding-support-for-webassembly"><a class="header" href="#adding-support-for-webassembly">Adding Support for WebAssembly</a></h2>
<h3 id="avoid-performing-io-directly"><a class="header" href="#avoid-performing-io-directly">Avoid Performing I/O Directly</a></h3>
<p>On the Web, I/O is always asynchronous, and there isn't a file system. Factor
I/O out of your library, let users perform the I/O and then pass the input
slices to your library instead.</p>
<p>For example, refactor this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::path::Path;

pub fn parse_thing(path: &amp;Path) -&gt; Result&lt;MyThing, MyError&gt; {
    let contents = fs::read(path)?;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Into this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse_thing(contents: &amp;[u8]) -&gt; Result&lt;MyThing, MyError&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="add-wasm-bindgen-as-a-dependency"><a class="header" href="#add-wasm-bindgen-as-a-dependency">Add <code>wasm-bindgen</code> as a Dependency</a></h3>
<p>If you need to interact with the outside world (i.e. you can't have library
consumers drive that interaction for you) then you'll need to add <code>wasm-bindgen</code>
(and <code>js-sys</code> and <code>web-sys</code> if you need them) as a dependency for when
compilation is targeting WebAssembly:</p>
<pre><code class="language-toml">[target.'cfg(target_arch = &quot;wasm32&quot;)'.dependencies]
wasm-bindgen = &quot;0.2&quot;
js-sys = &quot;0.3&quot;
web-sys = &quot;0.3&quot;
</code></pre>
<h3 id="avoid-synchronous-io"><a class="header" href="#avoid-synchronous-io">Avoid Synchronous I/O</a></h3>
<p>If you must perform I/O in your library, then it cannot be synchronous. There is
only asynchronous I/O on the Web. Use <a href="https://crates.io/crates/futures">the <code>futures</code>
crate</a> and <a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/">the <code>wasm-bindgen-futures</code>
crate</a> to
manage asynchronous I/O. If your library functions are generic over some
future type <code>F</code>, then that future can be implemented via <code>fetch</code> on the Web or
via non-blocking I/O provided by the operating system.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_stuff&lt;F&gt;(future: F) -&gt; impl Future&lt;Item = MyOtherThing&gt;
where
    F: Future&lt;Item = MyThing&gt;,
{
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>You can also define a trait and implement it for WebAssembly and the Web and
also for native targets:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ReadMyThing {
    type F: Future&lt;Item = MyThing&gt;;
    fn read(&amp;self) -&gt; Self::F;
}

#[cfg(target_arch = &quot;wasm32&quot;)]
struct WebReadMyThing {
    // ...
}

#[cfg(target_arch = &quot;wasm32&quot;)]
impl ReadMyThing for WebReadMyThing {
    // ...
}

#[cfg(not(target_arch = &quot;wasm32&quot;))]
struct NativeReadMyThing {
    // ...
}

#[cfg(not(target_arch = &quot;wasm32&quot;))]
impl ReadMyThing for NativeReadMyThing {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="avoid-spawning-threads"><a class="header" href="#avoid-spawning-threads">Avoid Spawning Threads</a></h3>
<p>Wasm doesn't support threads yet (but <a href="https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html">experimental work is
ongoing</a>),
so attempts to spawn threads in wasm will panic.</p>
<p>You can use <code>#[cfg(..)]</code>s to enable threaded and non-threaded code paths
depending on if the target is WebAssembly or not:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg(target_arch = &quot;wasm32&quot;)]
<span class="boring">fn main() {
</span>fn do_work() {
    // Do work with only this thread...
}

#![cfg(not(target_arch = &quot;wasm32&quot;))]
fn do_work() {
    use std::thread;

    // Spread work to helper threads....
    thread::spawn(|| {
        // ...
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>Another option is to factor out thread spawning from your library and allow
users to &quot;bring their own threads&quot; similar to factoring out file I/O and
allowing users to bring their own I/O. This has the side effect of playing nice
with applications that want to own their own custom thread pool.</p>
<h2 id="maintaining-ongoing-support-for-webassembly"><a class="header" href="#maintaining-ongoing-support-for-webassembly">Maintaining Ongoing Support for WebAssembly</a></h2>
<h3 id="building-for-wasm32-unknown-unknown-in-ci"><a class="header" href="#building-for-wasm32-unknown-unknown-in-ci">Building for <code>wasm32-unknown-unknown</code> in CI</a></h3>
<p>Ensure that compilation doesn't fail when targeting WebAssembly by having your
CI script run these commands:</p>
<pre><code>rustup target add wasm32-unknown-unknown
cargo check --target wasm32-unknown-unknown
</code></pre>
<p>For example, you can add this to your <code>.travis.yml</code> configuration for Travis CI:</p>
<pre><code class="language-yaml">
matrix:
  include:
    - language: rust
      rust: stable
      name: &quot;check wasm32 support&quot;
      install: rustup target add wasm32-unknown-unknown
      script: cargo check --target wasm32-unknown-unknown
</code></pre>
<h3 id="testing-in-nodejs-and-headless-browsers"><a class="header" href="#testing-in-nodejs-and-headless-browsers">Testing in Node.js and Headless Browsers</a></h3>
<p>You can use <code>wasm-bindgen-test</code> and the <code>wasm-pack test</code> subcommand to run wasm
tests in either Node.js or a headless browser. You can even integrate these
tests into your CI.</p>
<p><a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html">Learn more about testing wasm
here.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-rust-and-webassembly-to-production"><a class="header" href="#deploying-rust-and-webassembly-to-production">Deploying Rust and WebAssembly to Production</a></h1>
<blockquote>
<p><strong>⚡ Deploying Web applications built with Rust and WebAssembly is nearly
identical to deploying any other Web application!</strong></p>
</blockquote>
<p>To deploy a Web application that uses Rust-generated WebAssembly on the client,
copy the built Web application's files to your production server's file system
and configure your HTTP server to make them accessible.</p>
<h2 id="ensure-that-your-http-server-uses-the-applicationwasm-mime-type"><a class="header" href="#ensure-that-your-http-server-uses-the-applicationwasm-mime-type">Ensure that Your HTTP Server Uses the <code>application/wasm</code> MIME Type</a></h2>
<p>For the fastest page loads, you'll want to use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">the
<code>WebAssembly.instantiateStreaming</code> function</a> to pipeline
wasm compilation and instantiation with network transfer (or make sure your
bundler is able to use that function). However, <code>instantiateStreaming</code> requires
that the HTTP response has the <code>application/wasm</code> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a> set, or else it
will throw an error.</p>
<ul>
<li><a href="https://httpd.apache.org/docs/2.4/mod/mod_mime.html#addtype">How to configure MIME types for the Apache HTTP server</a></li>
<li><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#types">How to configure MIME types for the NGINX HTTP server</a></li>
</ul>
<h2 id="more-resources"><a class="header" href="#more-resources">More Resources</a></h2>
<ul>
<li><a href="https://webpack.js.org/guides/production/">Best Practices for Webpack in Production.</a> Many Rust and
WebAssembly projects use Webpack to bundle their Rust-generated WebAssembly,
JavaScript, CSS, and HTML. This guide has tips for getting the most out of
Webpack when deploying to production environments.</li>
<li><a href="https://httpd.apache.org/docs/">Apache documentation.</a> Apache is a popular HTTP server for use in
production.</li>
<li><a href="https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/">NGINX documentation.</a> NGINX is a popular HTTP server for use in
production.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
