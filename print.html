<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust and WebAssembly</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="why-rust-and-webassembly.html"><strong aria-hidden="true">2.</strong> 为什么是Rust和WebAssembly?</a></li><li class="chapter-item expanded "><a href="background-and-concepts.html"><strong aria-hidden="true">3.</strong> 背景和概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-webassembly.html"><strong aria-hidden="true">3.1.</strong> 什么是WebAssembly?</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="game-of-life/introduction.html"><strong aria-hidden="true">4.</strong> 教程 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="game-of-life/setup.html"><strong aria-hidden="true">4.1.</strong> 设置</a></li><li class="chapter-item expanded "><a href="game-of-life/hello-world.html"><strong aria-hidden="true">4.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="game-of-life/rules.html"><strong aria-hidden="true">4.3.</strong> 规则</a></li><li class="chapter-item expanded "><a href="game-of-life/implementing.html"><strong aria-hidden="true">4.4.</strong> 实现康威的生命游戏 </a></li><li class="chapter-item expanded "><a href="game-of-life/testing.html"><strong aria-hidden="true">4.5.</strong> Testing Life</a></li><li class="chapter-item expanded "><a href="game-of-life/debugging.html"><strong aria-hidden="true">4.6.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="game-of-life/interactivity.html"><strong aria-hidden="true">4.7.</strong> Adding Interactivity</a></li><li class="chapter-item expanded "><a href="game-of-life/time-profiling.html"><strong aria-hidden="true">4.8.</strong> Time Profiling</a></li><li class="chapter-item expanded "><a href="game-of-life/code-size.html"><strong aria-hidden="true">4.9.</strong> Shrinking .wasm Size</a></li><li class="chapter-item expanded "><a href="game-of-life/publishing-to-npm.html"><strong aria-hidden="true">4.10.</strong> Publishing to npm</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">5.</strong> Reference</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/crates.html"><strong aria-hidden="true">5.1.</strong> Crates You Should Know</a></li><li class="chapter-item expanded "><a href="reference/tools.html"><strong aria-hidden="true">5.2.</strong> Tools You Should Know</a></li><li class="chapter-item expanded "><a href="reference/project-templates.html"><strong aria-hidden="true">5.3.</strong> Project Templates</a></li><li class="chapter-item expanded "><a href="reference/debugging.html"><strong aria-hidden="true">5.4.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="reference/time-profiling.html"><strong aria-hidden="true">5.5.</strong> Time Profiling</a></li><li class="chapter-item expanded "><a href="reference/code-size.html"><strong aria-hidden="true">5.6.</strong> Shrinking .wasm Size</a></li><li class="chapter-item expanded "><a href="reference/js-ffi.html"><strong aria-hidden="true">5.7.</strong> JavaScript Interoperation</a></li><li class="chapter-item expanded "><a href="reference/which-crates-work-with-wasm.html"><strong aria-hidden="true">5.8.</strong> Which Crates Will Work Off-the-Shelf with WebAssembly?</a></li><li class="chapter-item expanded "><a href="reference/add-wasm-support-to-crate.html"><strong aria-hidden="true">5.9.</strong> How to Add WebAssembly Support to a General-Purpose Crate</a></li><li class="chapter-item expanded "><a href="reference/deploying-to-production.html"><strong aria-hidden="true">5.10.</strong> Deploying Rust and WebAssembly to Production</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust and WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust--and-webassembly-"><a class="header" href="#rust--and-webassembly-">Rust 🦀 and WebAssembly 🕸</a></h1>
<p>这本小书描述了如何将<a href="https://www.rust-lang.org">Rust</a>和<a href="https://webassembly.org/">WebAssembly</a>一起使用。</p>
<h2 id="这本书是为谁写的"><a class="header" href="#这本书是为谁写的">这本书是为谁写的?</a></h2>
<p>本书是为那些对将Rust编译成 WebAssembly 以实现快速、可靠的网络代码感兴趣的人编写的。汇编成WebAssembly，以便在网络上获得快速可靠的代码。你应该了解一些Rust，并熟悉 JavaScript，HTML，和 CSS。你不需要成为其中任何一个方面的专家。</p>
<p>还不了解Rust吗？ <a href="https://doc.rust-lang.org/book/">先从 <em>The Rust Programming Language</em> 开始</a></p>
<p>不懂JavaScript、HTML或CSS？<a href="https://developer.mozilla.org/en-US/docs/Learn">在MDN上了解他们的情况</a></p>
<h2 id="如何阅读此书"><a class="header" href="#如何阅读此书">如何阅读此书</a></h2>
<p>你应该先阅读<a href="./why-rust-and-webassembly.html">一起使用Rust和WebAssembly的动机</a>，以及熟悉<a href="./background-and-concepts.html">背景和概念</a>。</p>
<p><a href="./game-of-life/introduction.html">教程</a>是为了从头到尾阅读而写的。你应该跟随：自己编写、编译和运行教程中的代码。如果你以前没有一起使用过Rust和WebAssembly，那就从教程开始吧!</p>
<p><a href="./reference/index.html">参考章节</a> 可以按任何顺序进行阅读。</p>
<blockquote>
<p><strong>💡 Tip:</strong> 你可以通过点击页面上面的搜索 🔍 图标或按下 <code>s</code> 键 进行搜索</p>
</blockquote>
<h2 id="参与完善本书"><a class="header" href="#参与完善本书">参与完善本书</a></h2>
<p>这本书是开放源代码的! 发现一个错别字？我们是否忽略了什么？</p>
<ul>
<li>中文版本: <a href="https://github.com/Orefa/rustwasm"><strong>Send us a pull request!</strong></a></li>
<li>英文版本: <a href="https://github.com/rustwasm/book"><strong>Send us a pull request!</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为什么是rust和webassembly"><a class="header" href="#为什么是rust和webassembly">为什么是Rust和WebAssembly?</a></h1>
<h2 id="低水平控制与高水平的人机工程学"><a class="header" href="#低水平控制与高水平的人机工程学">低水平控制与高水平的人机工程学</a></h2>
<p>JavaScript网络应用程序很难达到并保持可靠的性能。JavaScript的动态类型系统和垃圾收集的暂停并没有帮助。看似很小的代码改动，如果你不小心偏离了JIT的快乐路径，就会导致性能的急剧下降。你不小心偏离了JIT的快乐路径。</p>
<p>Rust 为程序员提供了低级控制和可靠的性能。 它没有困扰 JavaScript 的非确定性垃圾收集暂停。 程序员可以控制间接、单态化和内存布局。 </p>
<h2 id="小的-wasm-尺寸"><a class="header" href="#小的-wasm-尺寸">小的 <code>.wasm</code> 尺寸</a></h2>
<p>代码大小非常重要，因为 <code>.wasm</code> 必须通过网络下载。 Rust 缺少运行时，支持较小的 <code>.wasm</code> 大小，因为没有像垃圾收集器那样包含额外的膨胀。 您只需为实际使用的功能付费（按代码大小）。 </p>
<h2 id="不需要-重写一切"><a class="header" href="#不需要-重写一切"><em>不需要</em> 重写一切</a></h2>
<p>不需要丢弃现有的代码库。 您可以首先将您对性能最敏感的 JavaScript 函数移植到 Rust，以获得直接的好处。 如果您愿意，你甚至可以到此为止。 </p>
<h2 id="与其程序可以很好的结合"><a class="header" href="#与其程序可以很好的结合">与其程序可以很好的结合</a></h2>
<p>Rust 和 WebAssembly 与现有的 JavaScript 工具集成。它支持 ECMAScript 模块，你可以继续使用你已经喜欢的工具，如 npm 和 Webpack。</p>
<h2 id="您期待的便利设施"><a class="header" href="#您期待的便利设施">您期待的便利设施</a></h2>
<p>Rust 拥有开发人员所期望的现代设施，例如： </p>
<ul>
<li>
<p>强大的包管理  <code>cargo</code>,</p>
</li>
<li>
<p>富有表现力（和零成本）的抽象， </p>
</li>
<li>
<p>和一个热情的社区！ 😊</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="背景和概念"><a class="header" href="#背景和概念">背景和概念</a></h1>
<p>本节提供了进入 Rust 和 WebAssembly 的必要背景。开发的必要背景。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是webassembly"><a class="header" href="#什么是webassembly">什么是WebAssembly?</a></h1>
<p>WebAssembly(wasm)是一种简单的机器模型和可执行格式，有一个<a href="https://webassembly.github.io/spec/">广泛的规范</a>。它被设计成可移植、紧凑，并以或接近原生速度执行。</p>
<p>作为一种编程语言，WebAssembly是由两种格式组成的。表示相同的结构，只是方式不同而已：</p>
<ol>
<li><code>.wat</code> 文本格式（称为<code>wat</code>，表示 &quot;<strong>W</strong>eb<strong>A</strong>ssembly <strong>T</strong>ext&quot;）使用 <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a>，与 Lisp 系列语言有一些相似之处  像 Scheme 和 Clojure。</li>
<li><code>.wasm</code> 二进制格式是较低级的，目的是让 wasm 虚拟机直接使用。它在概念上类似于 ELF 和 Mach-O</li>
</ol>
<p>作为参考，这里有一个阶乘函数，在 <code>wat</code>:</p>
<pre><code>(module
  (func $fac (param f64) (result f64)
    local.get 0
    f64.const 1
    f64.lt
    if (result f64)
      f64.const 1
    else
      local.get 0
      local.get 0
      f64.const 1
      f64.sub
      call $fac
      f64.mul
    end)
  (export &quot;fac&quot; (func $fac)))
</code></pre>
<p>如果您对 <code>wasm</code> 文件的外观感到好奇，可以将 <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">wat2wasm demo</a> 与上述代码一起使用。 </p>
<h2 id="线性内存"><a class="header" href="#线性内存">线性内存</a></h2>
<p>WebAssembly有一个非常简单的<a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem">内存模型</a>。一个wasm模块可以访问一个单一的 &quot;线性内存&quot;，这基本上是一个字节的平面阵列。这个[内存可以按页面大小（64K）的倍数增长。它不能被缩小。</p>
<h2 id="webassembly-只是用于-web-吗"><a class="header" href="#webassembly-只是用于-web-吗">WebAssembly 只是用于 Web 吗？</a></h2>
<p>尽管它目前在 JavaScript 和 Web 社区中普遍受到关注，但 wasm 对其主机环境不做任何假设。因此，推测 wasm 将成为一种 &quot;可移植的可执行 &quot;格式，在未来被用于各种情况下是有意义的。然而，截至<em>今天</em>，wasm 主要与JavaScript（JS）有关，而 JavaScrip t有很多种类（包括 Web 和<a href="https://nodejs.org">Node.js</a>上的）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="教程-康威生命游戏"><a class="header" href="#教程-康威生命游戏">教程: 康威生命游戏</a></h1>
<p>这是一个用 Rust 和 WebAssembly 实现<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">康威生命游戏</a>的教程。</p>
<h2 id="这个教程是为谁准备的"><a class="header" href="#这个教程是为谁准备的">这个教程是为谁准备的？</a></h2>
<p>本教程适用于已经有基本 Rust 和 JavaScript 经验的人，并希望学习如何一起使用 Rust、WebAssembly 和 JavaScript。</p>
<p>你应该能够自如地阅读和编写基本的Rust、JavaScript 和 HTML。你绝对不需要是一个专家。</p>
<h2 id="我将学到什么"><a class="header" href="#我将学到什么">我将学到什么？</a></h2>
<ul>
<li>
<p>如何设置Rust工具链以编译成WebAssembly。</p>
</li>
<li>
<p>一个用于开发由Rust、WebAssembly、JavaScript、HTML和CSS组成的多语言程序的工作流程。</p>
</li>
<li>
<p>如何设计 API 以最大限度地利用 Rust 和 WebAssembly 的优势，同时也是 JavaScript 的优势。</p>
</li>
<li>
<p>如何调试由Rust编译的WebAssembly模块。</p>
</li>
<li>
<p>如何对Rust和WebAssembly程序进行时间剖析以使其更快。</p>
</li>
<li>
<p>如何确定 Rust 和 WebAssembly 程序的大小，使<code>.wasm</code>二进制文件更小，更快通过网络下载。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设置"><a class="header" href="#设置">设置</a></h1>
<p>本节描述了如何设置工具链，将 Rust 程序编译为 WebAssembly，并将其集成到 JavaScript 中。到 WebAssembly，并将其集成到 JavaScript 中。</p>
<h2 id="rust-工具链"><a class="header" href="#rust-工具链">Rust 工具链</a></h2>
<p>你将需要标准的 Rust 工具链，包括 <code>rustup</code>, <code>rustc</code>, 和 <code>cargo</code>.</p>
<p><a href="https://www.rust-lang.org/tools/install">按照这些说明来安装Rust工具链。</a></p>
<p>Rust 和 WebAssembly 的经验是乘着 Rust 发布的列车到了稳定期! 这意味着我们不需要任何实验性功能标志。然而，我们确实 需要 Rust 1.30 或更新版本。</p>
<h2 id="wasm-pack"><a class="header" href="#wasm-pack"><code>wasm-pack</code></a></h2>
<p><code>wasm-pack</code> 是您构建、测试和发布 Rust 生成的 WebAssembly 的一站式商店。 </p>
<p><a href="https://rustwasm.github.io/wasm-pack/installer/">Get <code>wasm-pack</code> here!</a></p>
<h2 id="cargo-generate"><a class="header" href="#cargo-generate"><code>cargo-generate</code></a></h2>
<p><a href="https://github.com/ashleygwilliams/cargo-generate"><code>cargo-generate</code> 通过利用预先存在的 git 存储库作为模板，帮助您快速启动并运行新的 Rust 项目。</a></p>
<p>使用如下命令安装 <code>cargo-generate</code>:</p>
<pre><code>cargo install cargo-generate
</code></pre>
<h2 id="npm"><a class="header" href="#npm"><code>npm</code></a></h2>
<p><code>npm</code> 是 JavaScript 的包管理器。 我们将使用它来安装和运行 JavaScript 打包器和开发服务器。 在教程结束时，我们将把我们编译的 <code>.wasm</code> 发布到 <code>npm</code> 仓库。 </p>
<p><a href="https://www.npmjs.com/get-npm">按照这些说明进行安装 <code>npm</code>.</a></p>
<p>如果您已经安装了 <code>npm</code>，请使用以下命令确保它是最新的： </p>
<pre><code>npm install npm@latest -g
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p>本节将告诉你如何构建和运行你的第一个 Rust 和 WebAssembly 的程序：一个提醒 &quot;Hello, World!&quot; 的网页。</p>
<p>在开始之前，请确保你已经遵循了<a href="game-of-life/setup.html">设置说明</a>。</p>
<h2 id="克隆项目模板"><a class="header" href="#克隆项目模板">克隆项目模板</a></h2>
<p>该项目模板预先配置了合理的默认值，因此你可以快速构建、集成和打包你的代码用于 Web。</p>
<p>用这个命令克隆项目模板:</p>
<pre><code class="language-text">cargo generate --git https://github.com/rustwasm/wasm-pack-template
</code></pre>
<p>这将提示你新项目的名称。我们将使用 <strong>&quot;wasm-game-of-life&quot;</strong>.</p>
<pre><code class="language-text">wasm-game-of-life
</code></pre>
<h2 id="里面有什么"><a class="header" href="#里面有什么">里面有什么</a></h2>
<p>进入新的 <code>wasm-game-of-life</code> 项目</p>
<pre><code>cd wasm-game-of-life
</code></pre>
<p>并让我们看看它的内容。</p>
<pre><code class="language-text">wasm-game-of-life/
├── Cargo.toml
├── LICENSE_APACHE
├── LICENSE_MIT
├── README.md
└── src
    ├── lib.rs
    └── utils.rs
</code></pre>
<p>让我们详细看一下其中的几个文件。 </p>
<h3 id="wasm-game-of-lifecargotoml"><a class="header" href="#wasm-game-of-lifecargotoml"><code>wasm-game-of-life/Cargo.toml</code></a></h3>
<p><code>Cargo.toml</code> 文件为 <code>cargo</code>、Rust 的包管理器和构建工具指定依赖项和元数据。 这个预先配置了一个 <code>wasm-bindgen</code> 依赖项，一些我们稍后将深入研究的可选依赖项，以及正确初始化的 <code>crate-type</code> 以生成 <code>.wasm</code> 库。 </p>
<h3 id="wasm-game-of-lifesrclibrs"><a class="header" href="#wasm-game-of-lifesrclibrs"><code>wasm-game-of-life/src/lib.rs</code></a></h3>
<p><code>src/lib.rs</code> 文件是我们正在编译为 WebAssembly 的 Rust crate 的根目录。 它使用 <code>wasm-bindgen</code> 与 JavaScript 交互。 它导入了 <code>window.alert</code> JavaScript 函数，并导出了 <code>greet</code> Rust 函数，它会提醒一条问候消息。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod utils;

use wasm_bindgen::prelude::*;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = &quot;wee_alloc&quot;)]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet() {
    alert(&quot;Hello, wasm-game-of-life!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="wasm-game-of-lifesrcutilsrs"><a class="header" href="#wasm-game-of-lifesrcutilsrs"><code>wasm-game-of-life/src/utils.rs</code></a></h3>
<p><code>src/utils.rs</code> 模块提供了一些通用的工具来让 Rust 编译成 WebAssembly 变得更容易。 我们将在本教程后面更详细地了解其中一些实用程序，例如当我们查看 <a href="game-of-life/debugging.html">调试我们的 wasm 代码</a> 时，但我们现在可以忽略此文件。 </p>
<h2 id="构建项目"><a class="header" href="#构建项目">构建项目</a></h2>
<p>我们使用 <code>wasm-pack</code> 来编排以下构建步骤： </p>
<ul>
<li>确保我们有 Rust 1.30 或更新版本，并且通过 <code>rustup</code> 安装了 <code>wasm32-unknown-unknown</code> 目标，</li>
<li>通过 <code>cargo</code> 将我们的 Rust 源编译为 WebAssembly <code>.wasm</code> 二进制文件，</li>
<li>使用 <code>wasm-bindgen</code> 生成 JavaScript API，以便使用我们的 Rust 生成的 WebAssembly。 </li>
</ul>
<p>要做到这一切，在项目目录内运行这个命令。</p>
<pre><code>wasm-pack build
</code></pre>
<p>构建完成后，我们可以在 <code>pkg</code> 目录中找到它的工件，它应该有以下内容： </p>
<pre><code>pkg/
├── package.json
├── README.md
├── wasm_game_of_life_bg.wasm
├── wasm_game_of_life.d.ts
└── wasm_game_of_life.js
</code></pre>
<p><code>README.md</code> 文件是从主项目复制的，但其他文件是全新的。 </p>
<h3 id="wasm-game-of-lifepkgwasm_game_of_life_bgwasm"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_life_bgwasm"><code>wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm</code></a></h3>
<p><code>.wasm</code> 文件是由 Rust 编译器从我们的 Rust 源代码生成的 WebAssembly 二进制文件。 它包含我们所有 Rust 函数和数据的编译到 wasm 版本。 例如，它有一个导出的“问候”功能。 </p>
<h3 id="wasm-game-of-lifepkgwasm_game_of_lifejs"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_lifejs"><code>wasm-game-of-life/pkg/wasm_game_of_life.js</code></a></h3>
<p><code>.js</code> 文件由 <code>wasm-bindgen</code> 生成，包含用于将 DOM 和 JavaScript 函数导入 Rust 并将 WebAssembly 函数的良好 API 暴露给 JavaScript 的 JavaScript 胶水。 例如，有一个 JavaScript 的 <code>greet</code> 函数包装了从 WebAssembly 模块导出的 <code>greet</code> 函数。 现在，这种粘合剂并没有做太多事情，但是当我们开始在 wasm 和 JavaScript 之间来回传递更多有趣的值时，它将帮助引导这些值跨越边界。 </p>
<pre><code class="language-js">import * as wasm from './wasm_game_of_life_bg';

// ...

export function greet() {
    return wasm.greet();
}
</code></pre>
<h3 id="wasm-game-of-lifepkgwasm_game_of_lifedts"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_lifedts"><code>wasm-game-of-life/pkg/wasm_game_of_life.d.ts</code></a></h3>
<p><code>.d.ts</code> 文件包含 JavaScript 胶水的 <a href="http://www.typescriptlang.org/">TypeScript</a> 类型声明。 如果您使用的是 TypeScript，您可以检查对 WebAssembly 函数的调用类型，并且您的 IDE 可以提供自动完成和建议！ 如果您不使用 TypeScript，则可以放心地忽略此文件。 </p>
<pre><code class="language-typescript">export function greet(): void;
</code></pre>
<h3 id="wasm-game-of-lifepkgpackagejson"><a class="header" href="#wasm-game-of-lifepkgpackagejson"><code>wasm-game-of-life/pkg/package.json</code></a></h3>
<p><a href="https://docs.npmjs.com/files/package.json"><code>package.json</code> 文件包含有关生成的 JavaScript 和 WebAssembly 包的元数据。</a> npm 和 JavaScript 捆绑器使用它来确定包之间的依赖关系、包名称、版本和一堆其他东西。 它帮助我们与 JavaScript 工具集成，并允许我们将我们的包发布到 npm。 </p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;wasm-game-of-life&quot;,
  &quot;collaborators&quot;: [
    &quot;Your Name &lt;your.email@example.com&gt;&quot;
  ],
  &quot;description&quot;: null,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;license&quot;: null,
  &quot;repository&quot;: null,
  &quot;files&quot;: [
    &quot;wasm_game_of_life_bg.wasm&quot;,
    &quot;wasm_game_of_life.d.ts&quot;
  ],
  &quot;main&quot;: &quot;wasm_game_of_life.js&quot;,
  &quot;types&quot;: &quot;wasm_game_of_life.d.ts&quot;
}
</code></pre>
<h2 id="将其放入网页"><a class="header" href="#将其放入网页">将其放入网页</a></h2>
<p>为了获取我们的 <code>wasm-game-of-life</code> 包并在网页中使用它，我们使用 <a href="https://github.com/rustwasm/create-wasm-app"><code>create-wasm-app</code> JavaScript 项目模板</a>。 </p>
<p>在 <code>wasm-game-of-life</code> 目录中运行此命令： </p>
<pre><code>npm init wasm-app www
</code></pre>
<p>这是我们新的 <code>wasm-game-of-life/www</code> 子目录包含的内容： </p>
<pre><code>wasm-game-of-life/www/
├── bootstrap.js
├── index.html
├── index.js
├── LICENSE-APACHE
├── LICENSE-MIT
├── package.json
├── README.md
└── webpack.config.js
</code></pre>
<p>再一次，让我们仔细看看其中的一些文件。 </p>
<h3 id="wasm-game-of-lifewwwpackagejson"><a class="header" href="#wasm-game-of-lifewwwpackagejson"><code>wasm-game-of-life/www/package.json</code></a></h3>
<p>这个 <code>package.json</code> 预先配置了 <code>webpack</code> 和 <code>webpack-dev-server</code> 依赖，以及对 <code>hello-wasm-pack</code> 的依赖，它是已发布到 npm 的 <code>wasm-pack-template</code> 包。 </p>
<h3 id="wasm-game-of-lifewwwwebpackconfigjs"><a class="header" href="#wasm-game-of-lifewwwwebpackconfigjs"><code>wasm-game-of-life/www/webpack.config.js</code></a></h3>
<p>此文件配置 webpack 及其本地开发服务器。 它是预先配置的，你根本不需要调整它来让 webpack 和它的本地开发服务器工作。 </p>
<h3 id="wasm-game-of-lifewwwindexhtml"><a class="header" href="#wasm-game-of-lifewwwindexhtml"><code>wasm-game-of-life/www/index.html</code></a></h3>
<p>这是网页的根 HTML 文件。 除了加载 <code>bootstrap.js </code>之外，它没有做太多事情，<code>bootstrap.js</code> 是一个非常薄的 <code>index.js</code> 包装器。 </p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello wasm-pack!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;./bootstrap.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="wasm-game-of-lifewwwindexjs"><a class="header" href="#wasm-game-of-lifewwwindexjs"><code>wasm-game-of-life/www/index.js</code></a></h3>
<p><code>index.js</code> 是我们网页的 JavaScript 的主要入口点。 它导入 <code>hello-wasm-pack</code> npm 包，其中包含默认的 <code>wasm-pack-template</code> 编译的 WebAssembly 和 JavaScript 胶水，然后调用 <code>hello-wasm-pack</code> 的 <code>greet</code> 函数。 </p>
<pre><code class="language-js">import * as wasm from &quot;hello-wasm-pack&quot;;

wasm.greet();
</code></pre>
<h3 id="安装依赖项"><a class="header" href="#安装依赖项">安装依赖项</a></h3>
<p>首先，通过在 <code>wasm-game-of-life/www</code> 子目录中运行 <code>npm install</code> 来确保本地开发服务器及其依赖项已安装： </p>
<pre><code class="language-text">npm install
</code></pre>
<p>这个命令只需要运行一次，就会安装<code>webpack</code> JavaScript bundler 和它的开发服务器。</p>
<blockquote>
<p>请注意，使用 Rust 和 WebAssembly 不需要 <code>webpack</code>，
这里它只是我们为了方便而选择的打包器和开发服务器
Parcel 和 Rollup 还应该支持将 WebAssembly 导入为 ECMAScript 模块
你也可以使用 Rust 和 WebAssembly <a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html">没有捆绑器</a> 如果你愿意！ </p>
</blockquote>
<h3 id="在-www-中使用我们本地的-wasm-game-of-life-包"><a class="header" href="#在-www-中使用我们本地的-wasm-game-of-life-包">在 <code>www</code> 中使用我们本地的 <code>wasm-game-of-life</code> 包</a></h3>
<p>我们不想使用 npm 中的 <code>hello-wasm-pack</code> 包，而是想使用我们本地的 <code>wasm-game-of-life</code> 包。 这将使我们能够逐步开发我们的生命游戏程序。</p>
<p>打开 <code>wasm-game-of-life/www/package.json</code> 并在 <code>&quot;devDependencies&quot;</code> 旁边添加 <code>&quot;dependencies&quot;</code> 字段，包括一个 <code>&quot;wasm-game-of-life&quot;: &quot;file :../pkg&quot;</code> 条目： </p>
<pre><code class="language-js">{
  // ...
  &quot;dependencies&quot;: {                     // Add this three lines block!
    &quot;wasm-game-of-life&quot;: &quot;file:../pkg&quot;
  },
  &quot;devDependencies&quot;: {
    //...
  }
}
</code></pre>
<p>接下来，修改 <code>wasm-game-of-life/www/index.js</code> 以导入 <code>wasm-game-of-life</code> 而不是 <code>hello-wasm-pack</code> 包： </p>
<pre><code class="language-js">import * as wasm from &quot;wasm-game-of-life&quot;;

wasm.greet();
</code></pre>
<p>由于我们声明了一个新的依赖项，我们需要安装它：</p>
<pre><code class="language-text">npm install
</code></pre>
<p>我们的网页现在可以在本地提供服务了！ </p>
<h2 id="本地服务"><a class="header" href="#本地服务">本地服务</a></h2>
<p>接下来，为开发服务器打开一个新终端。 在新终端中运行服务器让我们让它在后台运行，同时不会阻止我们运行其他命令。 在新终端中，从 <code>wasm-game-of-life/www</code> 目录中运行以下命令： </p>
<pre><code>npm run start
</code></pre>
<p>将您的 Web 浏览器导航到 <a href="http://localhost:8080/">http://localhost:8080/</a>，您应该会看到一条警告消息： </p>
<p><a href="game-of-life/../images/game-of-life/hello-world.png"><img src="game-of-life/../images/game-of-life/hello-world.png" alt="Screenshot of the &quot;Hello, wasm-game-of-life!&quot; Web page alert" /></a></p>
<p>任何时候进行更改并希望它们反映在 <a href="http://localhost:8080/">http://localhost:8080/</a> 上，只需在 <code>wasm-game-of-life</code> 目录中运行 <code>wasm-pack build</code> 命令.</p>
<p>Anytime you make changes and want them reflected on
<a href="http://localhost:8080/">http://localhost:8080/</a>, just re-run the <code>wasm-pack build</code> command within the <code>wasm-game-of-life</code> directory.</p>
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<ul>
<li>
<p>修改 <code>wasm-game-of-life/src/lib.rs</code> 中的 <code>greet</code> 函数，采用 <code>name: &amp;str</code> 参数来自定义警报消息，并将你的名字从内部传递给 <code>greet</code> 函数 <code>wasm-game-of-life/www/index.js</code>。 使用 <code>wasm-pack build</code> 重新构建 <code>.wasm</code> 二进制文件，然后在 Web 浏览器中刷新 <a href="http://localhost:8080/">http://localhost:8080/</a>，你应该会看到一个自定义的问候语！ </p>
<details>
  <summary>答案</summary>
<p><code>wasm-game-of-life/src/lib.rs</code> 中的 <code>greet</code> 函数的新版本:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
<span class="boring">}
</span></code></pre></pre>
<p><code>wasm-game-of-life/www/index.js</code> 中对 <code>greet</code> 的新调用：</p>
<pre><code class="language-js">wasm.greet(&quot;Your Name&quot;);
</code></pre>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="康威生命游戏规则"><a class="header" href="#康威生命游戏规则">康威生命游戏规则</a></h1>
<p><em>注：如果你已经熟悉了康威的生命游戏及其规则。请随意跳到下一节！</em>。</p>
<p><a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">维基百科对康威生命游戏的规则做了一个很好的描述:</a></p>
<blockquote>
<p>生命游戏的宇宙是一个无限的二维正交方格网格，
每个方格都处于两种可能状态中的一种，活或死，（或分别为有人居住和无人居住）。
每个单元格与其八个相邻单元格相互作用，这些单元格是水平、垂直或对角相邻的单元格。
在时间的每一步，都会发生以下转换：</p>
<ol>
<li>任何具有少于两个活邻居的活细胞都会死亡，就像人口不足一样。</li>
<li>任何有两个或三个活邻居的活细胞都会传给下一代。</li>
<li>任何拥有三个以上活邻居的活细胞都会死亡，就像人口过多一样。</li>
<li>任何只有三个活邻居的死细胞都会变成活细胞，就像通过繁殖一样。</li>
</ol>
<p>这些将自动机的行为与现实生活进行比较的规则可以浓缩为以下内容：</p>
<ol>
<li>任何有两个或三个活邻居的活细胞都能存活。</li>
<li>任何具有三个活邻居的死细胞都会成为活细胞。</li>
<li>所有其他活细胞在下一代中死亡。同样，所有其他死细胞保持死亡。 </li>
</ol>
<p>初始模式构成了系统的种子。 
第一代是通过将上述规则同时应用于种子中的每个细胞，
无论是活的还是死的； 出生和死亡同时发生，
发生这种情况的离散时刻有时称为滴答声。 每
一代都是前一代的纯函数。 这些规则不断被反复应用以创造更多的世代。</p>
</blockquote>
<p>考虑以下初始宇宙:</p>
<img src='../images/game-of-life/initial-universe.png' alt='Initial Universe' width=80 />
<p>我们可以通过考虑每个细胞来计算下一代。左上角的单元格已死。规则 (4) 是唯一适用于死细胞的转换规则。然而，因为左上角的单元格没有正好三个活着的邻居，所以转换规则不适用，它在下一代中仍然是死的。第一行中的每个其他单元格也是如此。</p>
<p>当我们考虑第二行第三列的顶部活细胞时，事情变得有趣了。对于活细胞，前三个规则中的任何一个都可能适用。在这个单元格的情况下，它只有一个活着的邻居，因此规则（1）适用：这个单元格将在下一代死亡。同样的命运等待着底部的活细胞。</p>
<p>中间的活细胞有两个活的邻居：顶部和底部的活细胞。这意味着规则 (2) 适用，并且它在下一代中仍然存在。</p>
<p>最后一个有趣的例子是中间活细胞左侧和右侧的死细胞。三个活细胞都是这两个细胞的邻居，这意味着规则（4）适用，这些细胞将在下一代变得活跃。</p>
<p>把它们放在一起，我们在下一个滴答后得到这个宇宙：</p>
<img src='../images/game-of-life/next-universe.png' alt='Next Universe' width=80 />
<p>从这些简单的、确定性的规则中，出现了奇怪而令人兴奋的行为:</p>
<table><thead><tr><th>Gosper's glider gun</th><th>Pulsar</th><th>Space ship</th></tr></thead><tbody>
<tr><td><img src="game-of-life/../images/wiki/Gospers_glider_gun.gif" alt="Gosper's glider gun" /></td><td><img src="game-of-life/../images/wiki/Game_of_life_pulsar.gif" alt="Pulsar" /></td><td><img src="game-of-life/../images/wiki/Game_of_life_animated_LWSS.gif" alt="Lighweight space ship" /></td></tr>
</tbody></table>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/C2vgICfQawE?rel=0&amp;start=65" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</center>
<h2 id="练习-1"><a class="header" href="#练习-1">练习</a></h2>
<ul>
<li>
<p>用手计算我们的例子宇宙的下一个刻度。注意到任何熟悉的东西吗？</p>
<details>
  <summary>答案</summary>
<p>它应该是例子宇宙的初始状态。</p>
<img src='../images/game-of-life/initial-universe.png' alt='Initial Universe' width=80 />
<p>这种模式是<em>周期性的</em>：它在每两个ticks之后返回到初始状态。</p>
</details>
</li>
<li>
<p>你能找到一个稳定的初始宇宙吗？就是说，一个每一代都是一样的宇宙。</p>
<details>
  <summary>答案</summary>
<p>有无限多的稳定的宇宙! 琐碎稳定的宇宙是空宇宙。一个由活细胞组成的2乘2的正方形也是一个稳定的宇宙。</p>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现康威的生命游戏"><a class="header" href="#实现康威的生命游戏">实现康威的生命游戏</a></h1>
<h2 id="设计"><a class="header" href="#设计">设计</a></h2>
<p>在我们深入研究之前，我们需要考虑一些设计选择。 </p>
<h3 id="无限宇宙"><a class="header" href="#无限宇宙">无限宇宙</a></h3>
<p>生命游戏是在一个无限的宇宙中进行的，但我们没有无限的内存和计算能力。 解决这个相当烦人的限制通常有以下三种方式之一： </p>
<ol>
<li>
<p>跟踪宇宙的哪个子集发生了有趣的事情，并根据需要扩展该区域。 在最坏的情况下，这种扩展是无界的，实现会越来越慢，最终会耗尽内存。 </p>
</li>
<li>
<p>创建一个固定大小的宇宙，其中边缘的单元格比中间的单元格具有更少的邻居。 这种方法的缺点是，像滑翔机一样到达宇宙尽头的无限模式被扼杀了。 </p>
</li>
<li>
<p>创建一个固定大小的周期性宇宙，其中边缘的细胞有环绕宇宙另一侧的邻居。 因为邻居环绕着宇宙的边缘，所以滑翔机可以永远运行。 </p>
</li>
</ol>
<p>我们将实施第三个选项。</p>
<h3 id="rust-和-javascript-的接口"><a class="header" href="#rust-和-javascript-的接口">Rust 和 JavaScript 的接口</a></h3>
<blockquote>
<p>⚡ 这是本教程中需要理解和掌握的最重要的概念之一！</p>
</blockquote>
<p>JavaScript 的垃圾收集堆——其中分配了“对象”、“数组”和 DOM 节点——与 WebAssembly 的线性内存空间不同，我们的 Rust 值存在于其中。 WebAssembly 目前无法直接访问垃圾收集堆（截至 2018 年 4 月，这预计会随着 <a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">“接口类型”提案</a> 的出现而改变）。 另一方面，JavaScript可以读写WebAssembly的线性内存空间，但只能作为标量值的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>（<code>u8</code>，<code>i32</code>，<code>f64</code>，等等）。 WebAssembly 函数也接受和返回标量值。 这些是构成所有 WebAssembly 和 JavaScript 通信的构建块。 </p>
<p><code>wasm_bindgen</code> 定义了如何跨这个边界处理复合结构的共同理解。 它涉及装箱 Rust 结构，并将指针包装在 JavaScript 类中以提高可用性，或者从 Rust 索引到 JavaScript 对象表。 <code>wasm_bindgen</code> 非常方便，但它并没有消除考虑我们的数据表示的需要，以及跨越这个边界传递的值和结构。 相反，将其视为实现您选择的界面设计的工具。</p>
<p>在设计 WebAssembly 和 JavaScript 之间的接口时，我们希望针对以下属性进行优化： </p>
<ol>
<li>
<p><strong>最大限度地减少进出 WebAssembly 线性内存的复制。</strong> 不必要的副本会带来不必要的开销。 </p>
</li>
<li>
<p><strong>最小化序列化和反序列化。</strong> 与副本类似，序列化和反序列化也会产生开销，并且通常也会产生复制。 如果我们可以将不透明的句柄传递给数据结构——而不是在一侧序列化它，将它复制到 WebAssembly 线性内存中的某个已知位置，然后在另一侧反序列化——我们通常可以减少很多开销。 <code>wasm_bindgen</code> 帮助我们定义和使用 JavaScript 对象或盒装 Rust 结构的不透明句柄。 </p>
</li>
</ol>
<h3 id="在我们的生活游戏中连接-rust-和-javascript"><a class="header" href="#在我们的生活游戏中连接-rust-和-javascript">在我们的生活游戏中连接 Rust 和 JavaScript</a></h3>
<p>让我们首先列举一些要避免的危险。 我们不想在每个滴答声中将整个宇宙复制到 WebAssembly 线性内存中。 我们不想为宇宙中的每个单元格分配对象，也不想强加跨界调用来读取和写入每个单元格。</p>
<p>这让我们何去何从？ 我们可以将宇宙表示为一个平面数组，它存在于 WebAssembly 线性内存中，每个单元格都有一个字节。 <code>0</code> 是死细胞，<code>1</code> 是活细胞。</p>
<p>以下是 4 x 4 宇宙在内存中的样子： </p>
<p><img src="game-of-life/../images/game-of-life/universe.png" alt="Screenshot of a 4 by 4 universe" /></p>
<p>为了找到宇宙中某一行和某一列的单元格的阵列索引，我们可以使用这个公式：</p>
<pre><code class="language-text">index(row, column, universe) = row * width(universe) + column
</code></pre>
<p>我们有几种方法可以将宇宙的单元格暴露给 JavaScript。首先，我们将为 &quot;宇宙 &quot;实现<a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>std::fmt::Display</code></a>，我们可以用它来生成一个渲染为文本字符的单元格的Rust<code>String</code>。然后这个Rust字符串从WebAssembly的线性内存中复制到JavaScript的垃圾收集堆中的一个JavaScript字符串，然后通过设置HTML<code>textContent</code>来显示。在本章的后面，我们将发展这个实现，以避免在堆之间复制宇宙的单元，并渲染到<code>&lt;canvas&gt;</code>。</p>
<p><em>另一个可行的设计方案是让Rust在每次打勾后返回一个改变状态的单元格的列表，而不是将整个宇宙暴露给JavaScript。这样一来，JavaScript就不需要在渲染时遍历整个宇宙，只需要遍历相关的子集。这样做的好处是，这种基于delta的设计在实现上稍显困难。</em></p>
<h2 id="rust-实现"><a class="header" href="#rust-实现">Rust 实现</a></h2>
<p>在上一章中，我们克隆了一个初始项目模板。 我们现在将修改该项目模板。</p>
<p>让我们首先从 <code>wasm-game-of-life/src/lib.rs</code> 中删除 <code>alert</code> 导入和 <code>greet</code> 函数，并将它们替换为单元格的类型定义： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
<span class="boring">}
</span></code></pre></pre>
<p>重要的是我们有<code>#[repr(u8)]</code>，这样每个单元格都表示为一个字节。 同样重要的是，<code>Dead</code> 变体为 <code>0</code>，<code>Alive</code> 变体为 <code>1</code>，以便我们可以轻松地通过加法计算单元格的活邻居。</p>
<p>接下来，让我们定义宇宙。 宇宙有宽度和高度，以及长度为 <code>width * height</code> 的单元向量。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec&lt;Cell&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>为了访问给定行和列的单元格，我们将行和列转换为单元格向量的索引，如前所述：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    fn get_index(&amp;self, row: u32, column: u32) -&gt; usize {
        (row * self.width + column) as usize
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>为了计算一个细胞的下一个状态，我们需要计算它的邻居有多少是活着的。 让我们编写一个 <code>live_neighbor_count</code> 方法来做到这一点！ </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    // ...

    fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 &amp;&amp; delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>live_neighbor_count</code> 方法使用 deltas 和 modulo 来避免使用 <code>if</code> 对宇宙边缘进行特殊外壳。 当应用 <code>-1</code> 的增量时，我们<em>添加</em> <code>self.height - 1</code> 并让模数做它的事情，而不是尝试减去 <code>1</code>。 <code>row</code> 和 <code>column</code> 可以是 <code>0</code>，如果我们试图从它们中减去 <code>1</code>，就会出现一个无符号整数下溢。</p>
<p>现在我们拥有了从当前计算下一代所需的一切！ 游戏的每条规则都直接转换为“匹配”表达式的条件。 此外，因为我们希望 JavaScript 控制滴答发生的时间，我们将把这个方法放在一个 <code>#[wasm_bindgen]</code> 块中，以便它暴露给 JavaScript。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&amp;mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>So far, the state of the universe is represented as a vector of cells. To make
this human readable, let's implement a basic text renderer. The idea is to write
the universe line by line as text, and for each cell that is alive, print the
Unicode character <code>◼</code> (&quot;black medium square&quot;). For dead cells, we'll print <code>◻</code>
(a &quot;white medium square&quot;).</p>
<p>By implementing the <a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>Display</code></a> trait from Rust's standard library, we can add a
way to format a structure in a user-facing manner. This will also automatically
give us a <a href="https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html"><code>to_string</code></a> method.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &amp;cell in line {
                let symbol = if cell == Cell::Dead { '◻' } else { '◼' };
                write!(f, &quot;{}&quot;, symbol)?;
            }
            write!(f, &quot;\n&quot;)?;
        }

        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we define a constructor that initializes the universe with an
interesting pattern of live and dead cells, as well as a <code>render</code> method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -&gt; Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&amp;self) -&gt; String {
        self.to_string()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>With that, the Rust half of our Game of Life implementation is complete!</p>
<p>Recompile it to WebAssembly by running <code>wasm-pack build</code> within the
<code>wasm-game-of-life</code> directory.</p>
<h2 id="rendering-with-javascript"><a class="header" href="#rendering-with-javascript">Rendering with JavaScript</a></h2>
<p>First, let's add a <code>&lt;pre&gt;</code> element to <code>wasm-game-of-life/www/index.html</code> to
render the universe into, just above the <code>&lt;script&gt;</code> tag:</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;pre id=&quot;game-of-life-canvas&quot;&gt;&lt;/pre&gt;
  &lt;script src=&quot;./bootstrap.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>Additionally, we want the <code>&lt;pre&gt;</code> centered in the middle of the Web page. We can
use CSS flex boxes to accomplish this task. Add the following <code>&lt;style&gt;</code> tag
inside <code>wasm-game-of-life/www/index.html</code>'s <code>&lt;head&gt;</code>:</p>
<pre><code class="language-html">&lt;style&gt;
  body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
&lt;/style&gt;
</code></pre>
<p>At the top of <code>wasm-game-of-life/www/index.js</code>, let's fix our import to bring in
the <code>Universe</code> rather than the old <code>greet</code> function:</p>
<pre><code class="language-js">import { Universe } from &quot;wasm-game-of-life&quot;;
</code></pre>
<p>Also, let's get that <code>&lt;pre&gt;</code> element we just added and instantiate a new
universe:</p>
<pre><code class="language-js">const pre = document.getElementById(&quot;game-of-life-canvas&quot;);
const universe = Universe.new();
</code></pre>
<p>The JavaScript runs in <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">a <code>requestAnimationFrame</code>
loop</a>. On each iteration, it draws the current universe
to the <code>&lt;pre&gt;</code>, and then calls <code>Universe::tick</code>.</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  pre.textContent = universe.render();
  universe.tick();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>To start the rendering process, all we have to do is make the initial call for
the first iteration of the rendering loop:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<p>Make sure your development server is still running (run <code>npm run start</code> inside
<code>wasm-game-of-life/www</code>) and this is what
<a href="http://localhost:8080/">http://localhost:8080/</a> should look like:</p>
<p><a href="game-of-life/../images/game-of-life/initial-game-of-life-pre.png"><img src="game-of-life/../images/game-of-life/initial-game-of-life-pre.png" alt="Screenshot of the Game of Life implementation with text rendering" /></a></p>
<h2 id="rendering-to-canvas-directly-from-memory"><a class="header" href="#rendering-to-canvas-directly-from-memory">Rendering to Canvas Directly from Memory</a></h2>
<p>Generating (and allocating) a <code>String</code> in Rust and then having <code>wasm-bindgen</code>
convert it to a valid JavaScript string makes unnecessary copies of the
universe's cells. As the JavaScript code already knows the width and
height of the universe, and can read WebAssembly's linear memory that make up
the cells directly, we'll modify the <code>render</code> method to return a pointer to the
start of the cells array.</p>
<p>Also, instead of rendering Unicode text, we'll switch to using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas
API</a>. We will use this design in the rest of the tutorial.</p>
<p>Inside <code>wasm-game-of-life/www/index.html</code>, let's replace the <code>&lt;pre&gt;</code> we added
earlier with a <code>&lt;canvas&gt;</code> we will render into (it too should be within the
<code>&lt;body&gt;</code>, before the <code>&lt;script&gt;</code> that loads our JavaScript):</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;canvas id=&quot;game-of-life-canvas&quot;&gt;&lt;/canvas&gt;
  &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>To get the necessary information from the Rust implementation, we'll need to add
some more getter functions for a universe's width, height, and pointer to its
cells array. All of these are exposed to JavaScript as well. Make these
additions to <code>wasm-game-of-life/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn width(&amp;self) -&gt; u32 {
        self.width
    }

    pub fn height(&amp;self) -&gt; u32 {
        self.height
    }

    pub fn cells(&amp;self) -&gt; *const Cell {
        self.cells.as_ptr()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, in <code>wasm-game-of-life/www/index.js</code>, let's also import <code>Cell</code> from
<code>wasm-game-of-life</code>, and define some constants that we will use when rendering
to the canvas:</p>
<pre><code class="language-js">import { Universe, Cell } from &quot;wasm-game-of-life&quot;;

const CELL_SIZE = 5; // px
const GRID_COLOR = &quot;#CCCCCC&quot;;
const DEAD_COLOR = &quot;#FFFFFF&quot;;
const ALIVE_COLOR = &quot;#000000&quot;;
</code></pre>
<p>Now, let's rewrite the rest of this JavaScript code to no longer write to the
<code>&lt;pre&gt;</code>'s <code>textContent</code> but instead draw to the <code>&lt;canvas&gt;</code>:</p>
<pre><code class="language-js">// Construct the universe, and get its width and height.
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// Give the canvas room for all of our cells and a 1px border
// around each of them.
const canvas = document.getElementById(&quot;game-of-life-canvas&quot;);
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () =&gt; {
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>To draw the grid between cells, we draw a set of equally-spaced horizontal
lines, and a set of equally-spaced vertical lines. These lines criss-cross to
form the grid.</p>
<pre><code class="language-js">const drawGrid = () =&gt; {
  ctx.beginPath();
  ctx.strokeStyle = GRID_COLOR;

  // Vertical lines.
  for (let i = 0; i &lt;= width; i++) {
    ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
    ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
  }

  // Horizontal lines.
  for (let j = 0; j &lt;= height; j++) {
    ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);
    ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
  }

  ctx.stroke();
};
</code></pre>
<p>We can directly access WebAssembly's linear memory via <code>memory</code>, which is
defined in the raw wasm module <code>wasm_game_of_life_bg</code>. To draw the cells, we
get a pointer to the universe's cells, construct a <code>Uint8Array</code> overlaying the
cells buffer, iterate over each cell, and draw a white or black rectangle
depending on whether the cell is dead or alive, respectively. By working with
pointers and overlays, we avoid copying the cells across the boundary on every
tick.</p>
<pre><code class="language-js">// Import the WebAssembly memory at the top of the file.
import { memory } from &quot;wasm-game-of-life/wasm_game_of_life_bg&quot;;

// ...

const getIndex = (row, column) =&gt; {
  return row * width + column;
};

const drawCells = () =&gt; {
  const cellsPtr = universe.cells();
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      ctx.fillStyle = cells[idx] === Cell.Dead
        ? DEAD_COLOR
        : ALIVE_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
<p>To start the rendering process, we'll use the same code as above to start the
first iteration of the rendering loop:</p>
<pre><code class="language-js">drawGrid();
drawCells();
requestAnimationFrame(renderLoop);
</code></pre>
<p>Note that we call <code>drawGrid()</code> and <code>drawCells()</code> here <em>before</em> we call
<code>requestAnimationFrame()</code>. The reason we do this is so that the <em>initial</em> state
of the universe is drawn before we make modifications. If we instead simply
called <code>requestAnimationFrame(renderLoop)</code>, we'd end up with a situation where
the first frame that was drawn would actually be <em>after</em> the first call to
<code>universe.tick()</code>, which is the second &quot;tick&quot; of the life of these cells.</p>
<h2 id="it-works"><a class="header" href="#it-works">It Works!</a></h2>
<p>Rebuild the WebAssembly and bindings glue by running this command from within
the root <code>wasm-game-of-life</code> directory:</p>
<pre><code>wasm-pack build
</code></pre>
<p>Make sure your development server is still running. If it isn't, start it again
from within the <code>wasm-game-of-life/www</code> directory:</p>
<pre><code>npm run start
</code></pre>
<p>If you refresh <a href="http://localhost:8080/">http://localhost:8080/</a>, you should be
greeted with an exciting display of life!</p>
<p><a href="game-of-life/../images/game-of-life/initial-game-of-life.png"><img src="game-of-life/../images/game-of-life/initial-game-of-life.png" alt="Screenshot of the Game of Life implementation" /></a></p>
<p>As an aside, there is also a really neat algorithm for implementing the Game of
Life called <a href="https://en.wikipedia.org/wiki/Hashlife">hashlife</a>. It uses
aggressive memoizing and can actually get <em>exponentially faster</em> to compute
future generations the longer it runs! Given that, you might be wondering why we
didn't implement hashlife in this tutorial. It is out of scope for this text,
where we are focusing on Rust and WebAssembly integration, but we highly
encourage you to go learn about hashlife on your own!</p>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ul>
<li>
<p>Initialize the universe with a single space ship.</p>
</li>
<li>
<p>Instead of hard-coding the initial universe, generate a random one, where each
cell has a fifty-fifty chance of being alive or dead.</p>
<p><em>Hint: use <a href="https://crates.io/crates/js-sys">the <code>js-sys</code> crate</a> to import
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random">the <code>Math.random</code> JavaScript
function</a>.</em></p>
<details>
  <summary>Answer</summary>
  *First, add `js-sys` as a dependency in `wasm-game-of-life/Cargo.toml`:*
<pre><code class="language-toml"># ...
[dependencies]
js-sys = &quot;0.3&quot;
# ...
</code></pre>
<p><em>Then, use the <code>js_sys::Math::random</code> function to flip a coin:</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate js_sys;

// ...

if js_sys::Math::random() &lt; 0.5 {
    // Alive...
} else {
    // Dead...
}
<span class="boring">}
</span></code></pre></pre>
</details>
</li>
<li>
<p>Representing each cell with a byte makes iterating over cells easy, but it
comes at the cost of wasting memory. Each byte is eight bits, but we only
require a single bit to represent whether each cell is alive or dead. Refactor
the data representation so that each cell uses only a single bit of space.</p>
<details>
  <summary>Answer</summary>
<p>In Rust, you can use <a href="https://crates.io/crates/fixedbitset">the <code>fixedbitset</code> crate and its <code>FixedBitSet</code>
type</a> to represent cells instead of
<code>Vec&lt;Cell&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make sure you also added the dependency to Cargo.toml!
extern crate fixedbitset;
use fixedbitset::FixedBitSet;

// ...

#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: FixedBitSet,
}
<span class="boring">}
</span></code></pre></pre>
<p>The Universe constructor can be adjusted the following way:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Universe {
    let width = 64;
    let height = 64;

    let size = (width * height) as usize;
    let mut cells = FixedBitSet::with_capacity(size);

    for i in 0..size {
        cells.set(i, i % 2 == 0 || i % 7 == 0);
    }

    Universe {
        width,
        height,
        cells,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To update a cell in the next tick of the universe, we use the <code>set</code> method
of <code>FixedBitSet</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>next.set(idx, match (cell, live_neighbors) {
    (true, x) if x &lt; 2 =&gt; false,
    (true, 2) | (true, 3) =&gt; true,
    (true, x) if x &gt; 3 =&gt; false,
    (false, 3) =&gt; true,
    (otherwise, _) =&gt; otherwise
});
<span class="boring">}
</span></code></pre></pre>
<p>To pass a pointer to the start of the bits to JavaScript, you can convert
the <code>FixedBitSet</code> to a slice and then convert the slice to a pointer:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Universe {
    // ...

    pub fn cells(&amp;self) -&gt; *const u32 {
        self.cells.as_slice().as_ptr()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In JavaScript, constructing a <code>Uint8Array</code> from Wasm memory is the same as
before, except that the length of the array is not <code>width * height</code> anymore,
but <code>width * height / 8</code> since we have a cell per bit rather than per byte:</p>
<pre><code class="language-js">const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);
</code></pre>
<p>Given an index and <code>Uint8Array</code>, you can determine whether the
<em>n<sup>th</sup></em> bit is set with the following function:</p>
<pre><code class="language-js">const bitIsSet = (n, arr) =&gt; {
  const byte = Math.floor(n / 8);
  const mask = 1 &lt;&lt; (n % 8);
  return (arr[byte] &amp; mask) === mask;
};
</code></pre>
<p>Given all that, the new version of <code>drawCells</code> looks like this:</p>
<pre><code class="language-js">const drawCells = () =&gt; {
  const cellsPtr = universe.cells();

  // This is updated!
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      // This is updated!
      ctx.fillStyle = bitIsSet(idx, cells)
        ? ALIVE_COLOR
        : DEAD_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-conways-game-of-life"><a class="header" href="#testing-conways-game-of-life">Testing Conway's Game of Life</a></h1>
<p>Now that we have our Rust implementation of the Game of Life rendering in the 
browser with JavaScript, let's talk about testing our Rust-generated 
WebAssembly functions.</p>
<p>We are going to test our <code>tick</code> function to make sure that it gives us the 
output that we expect.</p>
<p>Next, we'll want to create some setter and getter 
functions inside our existing <code>impl Universe</code> block in the
<code>wasm_game_of_life/src/lib.rs</code> file. We are going to create a <code>set_width</code>
and a <code>set_height</code> function so we can create <code>Universe</code>s of different sizes.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Universe { 
    // ...

    /// Set the width of the universe.
    ///
    /// Resets all cells to the dead state.
    pub fn set_width(&amp;mut self, width: u32) {
        self.width = width;
        self.cells = (0..width * self.height).map(|_i| Cell::Dead).collect();
    }

    /// Set the height of the universe.
    ///
    /// Resets all cells to the dead state.
    pub fn set_height(&amp;mut self, height: u32) {
        self.height = height;
        self.cells = (0..self.width * height).map(|_i| Cell::Dead).collect();
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>We are going to create another <code>impl Universe</code> block inside our
<code>wasm_game_of_life/src/lib.rs</code> file without the <code>#[wasm_bindgen]</code> attribute.
There are a few functions we need for testing that we don't want to expose to
our JavaScript. Rust-generated WebAssembly functions cannot return
borrowed references. Try compiling the Rust-generated WebAssembly with the
attribute and take a look at the errors you get.</p>
<p>We are going to write the implementation of <code>get_cells</code> to get the contents of
the <code>cells</code> of a <code>Universe</code>. We'll also write a <code>set_cells</code> function so we can
set <code>cells</code> in a specific row and column of a <code>Universe</code> to be <code>Alive.</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    /// Get the dead and alive values of the entire universe.
    pub fn get_cells(&amp;self) -&gt; &amp;[Cell] {
        &amp;self.cells
    }

    /// Set cells to be alive in a universe by passing the row and column
    /// of each cell as an array.
    pub fn set_cells(&amp;mut self, cells: &amp;[(u32, u32)]) {
        for (row, col) in cells.iter().cloned() {
            let idx = self.get_index(row, col);
            self.cells[idx] = Cell::Alive;
        }
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>Now we're going to create our test in the <code>wasm_game_of_life/tests/web.rs</code> file.</p>
<p>Before we do that, there is already one working test in the file. You can
confirm that the Rust-generated WebAssembly test is working by running
<code>wasm-pack test --chrome --headless</code> in the <code>wasm-game-of-life</code> directory.
You can also use the <code>--firefox</code>, <code>--safari</code>, and <code>--node</code> options to
test your code in those browsers.</p>
<p>In the <code>wasm_game_of_life/tests/web.rs</code> file, we need to export our
<code>wasm_game_of_life</code> crate and the <code>Universe</code> type.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate wasm_game_of_life;
use wasm_game_of_life::Universe;
<span class="boring">}
</span></code></pre></pre>
<p>In the <code>wasm_game_of_life/tests/web.rs</code> file we'll want to create some
spaceship builder functions.</p>
<p>We'll want one for our input spaceship that we'll call the <code>tick</code> function on
and we'll want the expected spaceship we will get after one tick. We picked the
cells that we want to initialize as <code>Alive</code> to create our spaceship in the
<code>input_spaceship</code> function. The position of the spaceship in the
<code>expected_spaceship</code> function after the tick of the <code>input_spaceship</code> was
calculated manually. You can confirm for yourself that the cells of the input
spaceship after one tick is the same as the expected spaceship.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
pub fn input_spaceship() -&gt; Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&amp;[(1,2), (2,3), (3,1), (3,2), (3,3)]);
    universe
}

#[cfg(test)]
pub fn expected_spaceship() -&gt; Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&amp;[(2,1), (2,3), (3,2), (3,3), (4,2)]);
    universe
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we will write the implementation for our <code>test_tick</code> function. First, we
create an instance of our <code>input_spaceship()</code> and our <code>expected_spaceship()</code>.
Then, we call <code>tick</code> on the <code>input_universe</code>. Finally, we use the <code>assert_eq!</code>
macro to call <code>get_cells()</code> to ensure that <code>input_universe</code> and
<code>expected_universe</code> have the same <code>Cell</code> array values. We add the
<code>#[wasm_bindgen_test]</code> attribute to our code block so we can test our
Rust-generated WebAssembly code and use <code>wasm-pack test</code> to test the
WebAssembly code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen_test]
pub fn test_tick() {
    // Let's create a smaller Universe with a small spaceship to test!
    let mut input_universe = input_spaceship();

    // This is what our spaceship should look like
    // after one tick in our universe.
    let expected_universe = expected_spaceship();

    // Call `tick` and then see if the cells in the `Universe`s are the same.
    input_universe.tick();
    assert_eq!(&amp;input_universe.get_cells(), &amp;expected_universe.get_cells());
}
<span class="boring">}
</span></code></pre></pre>
<p>Run the tests within the <code>wasm-game-of-life</code> directory by running
<code>wasm-pack test --firefox --headless</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>Before we write much more code, we will want to have some debugging tools in our
belt for when things go wrong. Take a moment to review the <a href="game-of-life/../reference/debugging.html">reference page
listing tools and approaches available for debugging Rust-generated
WebAssembly</a>.</p>
<h2 id="enable-logging-for-panics"><a class="header" href="#enable-logging-for-panics">Enable Logging for Panics</a></h2>
<p><a href="game-of-life/../reference/debugging.html#logging-panics">If our code panics, we want informative error messages to appear in the
developer console.</a></p>
<p>Our <code>wasm-pack-template</code> comes with an optional, enabled-by-default dependency
on <a href="https://github.com/rustwasm/console_error_panic_hook">the <code>console_error_panic_hook</code> crate</a> that is configured in
<code>wasm-game-of-life/src/utils.rs</code>. All we need to do is install the hook in an
initialization function or common code path. We can call it inside the
<code>Universe::new</code> constructor in <code>wasm-game-of-life/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Universe {
    utils::set_panic_hook();

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="add-logging-to-our-game-of-life"><a class="header" href="#add-logging-to-our-game-of-life">Add Logging to our Game of Life</a></h2>
<p>Let's <a href="game-of-life/../reference/debugging.html#logging-with-the-console-apis">use the <code>console.log</code> function via the <code>web-sys</code> crate to add some
logging</a> about each cell in our <code>Universe::tick</code> function.</p>
<p>First, add <code>web-sys</code> as a dependency and enable its <code>&quot;console&quot;</code> feature in
<code>wasm-game-of-life/Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]

# ...

[dependencies.web-sys]
version = &quot;0.3&quot;
features = [
  &quot;console&quot;,
]
</code></pre>
<p>For ergonomics, we'll wrap the <code>console.log</code> function up in a <code>println!</code>-style
macro:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

// A macro to provide `println!(..)`-style syntax for `console.log` logging.
macro_rules! log {
    ( $( $t:tt )* ) =&gt; {
        web_sys::console::log_1(&amp;format!( $( $t )* ).into());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now, we can start logging messages to the console by inserting calls to <code>log</code> in
Rust code. For example, to log each cell's state, live neighbors count, and next
state, we could modify <code>wasm-game-of-life/src/lib.rs</code> like this:</p>
<pre><code class="language-diff">diff --git a/src/lib.rs b/src/lib.rs
index f757641..a30e107 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -123,6 +122,14 @@ impl Universe {
                 let cell = self.cells[idx];
                 let live_neighbors = self.live_neighbor_count(row, col);

+                log!(
+                    &quot;cell[{}, {}] is initially {:?} and has {} live neighbors&quot;,
+                    row,
+                    col,
+                    cell,
+                    live_neighbors
+                );
+
                 let next_cell = match (cell, live_neighbors) {
                     // Rule 1: Any live cell with fewer than two live neighbours
                     // dies, as if caused by underpopulation.
@@ -140,6 +147,8 @@ impl Universe {
                     (otherwise, _) =&gt; otherwise,
                 };

+                log!(&quot;    it becomes {:?}&quot;, next_cell);
+
                 next[idx] = next_cell;
             }
         }
</code></pre>
<h2 id="using-a-debugger-to-pause-between-each-tick"><a class="header" href="#using-a-debugger-to-pause-between-each-tick">Using a Debugger to Pause Between Each Tick</a></h2>
<p><a href="game-of-life/../reference/debugging.html#using-a-debugger">Browser's stepping debuggers are useful for inspecting the JavaScript that our
Rust-generated WebAssembly interacts
with.</a></p>
<p>For example, we can use the debugger to pause on each iteration of our
<code>renderLoop</code> function by placing <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger">a JavaScript <code>debugger;</code> statement</a>
above our call to <code>universe.tick()</code>.</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  debugger;
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>This provides us with a convenient checkpoint for inspecting logged messages,
and comparing the currently rendered frame to the previous one.</p>
<p><a href="game-of-life/../images/game-of-life/debugging.png"><img src="game-of-life/../images/game-of-life/debugging.png" alt="Screenshot of debugging the Game of Life" /></a></p>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ul>
<li>
<p>Add logging to the <code>tick</code> function that records the row and column of each
cell that transitioned states from live to dead or vice versa.</p>
</li>
<li>
<p>Introduce a <code>panic!()</code> in the <code>Universe::new</code> method. Inspect the panic's
backtrace in your Web browser's JavaScript debugger. Disable debug symbols,
rebuild without the <code>console_error_panic_hook</code> optional dependency, and
inspect the stack trace again. Not as useful is it?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adding-interactivity"><a class="header" href="#adding-interactivity">Adding Interactivity</a></h1>
<p>We will continue to explore the JavaScript and WebAssembly interface by adding
some interactive features to our Game of Life implementation. We will enable
users to toggle whether a cell is alive or dead by clicking on it, and
allow pausing the game, which makes drawing cell patterns a lot easier.</p>
<h2 id="pausing-and-resuming-the-game"><a class="header" href="#pausing-and-resuming-the-game">Pausing and Resuming the Game</a></h2>
<p>Let's add a button to toggle whether the game is playing or paused. To
<code>wasm-game-of-life/www/index.html</code>, add the button right above the <code>&lt;canvas&gt;</code>:</p>
<pre><code class="language-html">&lt;button id=&quot;play-pause&quot;&gt;&lt;/button&gt;
</code></pre>
<p>In the <code>wasm-game-of-life/www/index.js</code> JavaScript, we will make the following
changes:</p>
<ul>
<li>
<p>Keep track of the identifier returned by the latest call to
<code>requestAnimationFrame</code>, so that we can cancel the animation by calling
<code>cancelAnimationFrame</code> with that identifier.</p>
</li>
<li>
<p>When the play/pause button is clicked, check for whether we have the
identifier for a queued animation frame. If we do, then the game is currently
playing, and we want to cancel the animation frame so that <code>renderLoop</code> isn't
called again, effectively pausing the game. If we do not have an identifier
for a queued animation frame, then we are currently paused, and we would like
to call <code>requestAnimationFrame</code> to resume the game.</p>
</li>
</ul>
<p>Because the JavaScript is driving the Rust and WebAssembly, this is all we need
to do, and we don't need to change the Rust sources.</p>
<p>We introduce the <code>animationId</code> variable to keep track of the identifier returned
by <code>requestAnimationFrame</code>. When there is no queued animation frame, we set this
variable to <code>null</code>.</p>
<pre><code class="language-js">let animationId = null;

// This function is the same as before, except the
// result of `requestAnimationFrame` is assigned to
// `animationId`.
const renderLoop = () =&gt; {
  drawGrid();
  drawCells();

  universe.tick();

  animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>At any instant in time, we can tell whether the game is paused or not by
inspecting the value of <code>animationId</code>:</p>
<pre><code class="language-js">const isPaused = () =&gt; {
  return animationId === null;
};
</code></pre>
<p>Now, when the play/pause button is clicked, we check whether the game is
currently paused or playing, and resume the <code>renderLoop</code> animation or cancel the
next animation frame respectively. Additionally, we update the button's text
icon to reflect the action that the button will take when clicked next.</p>
<pre><code class="language-js">const playPauseButton = document.getElementById(&quot;play-pause&quot;);

const play = () =&gt; {
  playPauseButton.textContent = &quot;⏸&quot;;
  renderLoop();
};

const pause = () =&gt; {
  playPauseButton.textContent = &quot;▶&quot;;
  cancelAnimationFrame(animationId);
  animationId = null;
};

playPauseButton.addEventListener(&quot;click&quot;, event =&gt; {
  if (isPaused()) {
    play();
  } else {
    pause();
  }
});
</code></pre>
<p>Finally, we were previously kick-starting the game and its animation by calling
<code>requestAnimationFrame(renderLoop)</code> directly, but we want to replace that with a
call to <code>play</code> so that the button gets the correct initial text icon.</p>
<pre><code class="language-diff">// This used to be `requestAnimationFrame(renderLoop)`.
play();
</code></pre>
<p>Refresh <a href="http://localhost:8080/">http://localhost:8080/</a> and we should now be
able to pause and resume the game by clicking on the button!</p>
<h2 id="toggling-a-cells-state-on-click-events"><a class="header" href="#toggling-a-cells-state-on-click-events">Toggling a Cell's State on <code>&quot;click&quot;</code> Events</a></h2>
<p>Now that we can pause the game, it's time to add the ability to mutate the cells
by clicking on them.</p>
<p>To toggle a cell is to flip its state from alive to dead or from dead to
alive. Add a <code>toggle</code> method to <code>Cell</code> in <code>wasm-game-of-life/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cell {
    fn toggle(&amp;mut self) {
        *self = match *self {
            Cell::Dead =&gt; Cell::Alive,
            Cell::Alive =&gt; Cell::Dead,
        };
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To toggle the state of a cell at given row and column, we translate the row and
column pair into an index into the cells vector and call the toggle method on
the cell at that index:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn toggle_cell(&amp;mut self, row: u32, column: u32) {
        let idx = self.get_index(row, column);
        self.cells[idx].toggle();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This method is defined within the <code>impl</code> block that is annotated with
<code>#[wasm_bindgen]</code> so that it can be called by JavaScript.</p>
<p>In <code>wasm-game-of-life/www/index.js</code>, we listen to click events on the <code>&lt;canvas&gt;</code>
element, translate the click event's page-relative coordinates into
canvas-relative coordinates, and then into a row and column, invoke the
<code>toggle_cell</code> method, and finally redraw the scene.</p>
<pre><code class="language-js">canvas.addEventListener(&quot;click&quot;, event =&gt; {
  const boundingRect = canvas.getBoundingClientRect();

  const scaleX = canvas.width / boundingRect.width;
  const scaleY = canvas.height / boundingRect.height;

  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;
  const canvasTop = (event.clientY - boundingRect.top) * scaleY;

  const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1);
  const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1);

  universe.toggle_cell(row, col);

  drawGrid();
  drawCells();
});
</code></pre>
<p>Rebuild with <code>wasm-pack build</code> in <code>wasm-game-of-life</code>, then refresh
<a href="http://localhost:8080/">http://localhost:8080/</a> again and we can now draw our
own patterns by clicking on the cells and toggling their state.</p>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ul>
<li>
<p>Introduce an <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range"><code>&lt;input type=&quot;range&quot;&gt;</code></a> widget to control how many
ticks occur per animation frame.</p>
</li>
<li>
<p>Add a button that resets the universe to a random initial state when
clicked. Another button that resets the universe to all dead cells.</p>
</li>
<li>
<p>On <code>Ctrl + Click</code>, insert a
<a href="https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)">glider</a> centered on
the target cell. On <code>Shift + Click</code>, insert a pulsar.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-profiling"><a class="header" href="#time-profiling">Time Profiling</a></h1>
<p>In this chapter, we will improve the performance of our Game of Life
implementation. We will use time profiling to guide our efforts.</p>
<p>Familiarize yourself with <a href="game-of-life/../reference/time-profiling.html">the available tools for time profiling Rust and
WebAssembly code</a> before continuing.</p>
<h2 id="creating-a-frames-per-second-timer-with-the-windowperformancenow-function"><a class="header" href="#creating-a-frames-per-second-timer-with-the-windowperformancenow-function">Creating a Frames Per Second Timer with the <code>window.performance.now</code> Function</a></h2>
<p>This FPS timer will be useful as we investigate speeding up our Game of Life's
rendering.</p>
<p>We start by adding an <code>fps</code> object to <code>wasm-game-of-life/www/index.js</code>:</p>
<pre><code class="language-js">const fps = new class {
  constructor() {
    this.fps = document.getElementById(&quot;fps&quot;);
    this.frames = [];
    this.lastFrameTimeStamp = performance.now();
  }

  render() {
    // Convert the delta time since the last frame render into a measure
    // of frames per second.
    const now = performance.now();
    const delta = now - this.lastFrameTimeStamp;
    this.lastFrameTimeStamp = now;
    const fps = 1 / delta * 1000;

    // Save only the latest 100 timings.
    this.frames.push(fps);
    if (this.frames.length &gt; 100) {
      this.frames.shift();
    }

    // Find the max, min, and mean of our 100 latest timings.
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    for (let i = 0; i &lt; this.frames.length; i++) {
      sum += this.frames[i];
      min = Math.min(this.frames[i], min);
      max = Math.max(this.frames[i], max);
    }
    let mean = sum / this.frames.length;

    // Render the statistics.
    this.fps.textContent = `
Frames per Second:
         latest = ${Math.round(fps)}
avg of last 100 = ${Math.round(mean)}
min of last 100 = ${Math.round(min)}
max of last 100 = ${Math.round(max)}
`.trim();
  }
};
</code></pre>
<p>Next we call the <code>fps</code> <code>render</code> function on each iteration of <code>renderLoop</code>:</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
    fps.render(); //new

    universe.tick();
    drawGrid();
    drawCells();

    animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>Finally, don't forget to add the <code>fps</code> element to
<code>wasm-game-of-life/www/index.html</code>, just above the <code>&lt;canvas&gt;</code>:</p>
<pre><code class="language-html">&lt;div id=&quot;fps&quot;&gt;&lt;/div&gt;
</code></pre>
<p>And add CSS to make its formatting nice:</p>
<pre><code class="language-css">#fps {
  white-space: pre;
  font-family: monospace;
}
</code></pre>
<p>And voila! Refresh <a href="http://localhost:8080">http://localhost:8080</a> and now we
have an FPS counter!</p>
<h3 id="time-each-universetick-with-consoletime-and-consoletimeend"><a class="header" href="#time-each-universetick-with-consoletime-and-consoletimeend">Time Each <code>Universe::tick</code> with <code>console.time</code> and <code>console.timeEnd</code></a></h3>
<p>To measure how long each invocation of <code>Universe::tick</code> takes, we can use
<code>console.time</code> and <code>console.timeEnd</code> via the <code>web-sys</code> crate.</p>
<p>First, add <code>web-sys</code> as a dependency to <code>wasm-game-of-life/Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3&quot;
features = [
  &quot;console&quot;,
]
</code></pre>
<p>Because there should be a corresponding <code>console.timeEnd</code> invocation for every
<code>console.time</code> call, it is convenient to wrap them both up in an <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;
use web_sys::console;

pub struct Timer&lt;'a&gt; {
    name: &amp;'a str,
}

impl&lt;'a&gt; Timer&lt;'a&gt; {
    pub fn new(name: &amp;'a str) -&gt; Timer&lt;'a&gt; {
        console::time_with_label(name);
        Timer { name }
    }
}

impl&lt;'a&gt; Drop for Timer&lt;'a&gt; {
    fn drop(&amp;mut self) {
        console::time_end_with_label(self.name);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then, we can time how long each <code>Universe::tick</code> takes by adding this snippet to
the top of the method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _timer = Timer::new(&quot;Universe::tick&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The time of how long each call to <code>Universe::tick</code> took are now logged in the
console:</p>
<p><a href="game-of-life/../images/game-of-life/console-time.png"><img src="game-of-life/../images/game-of-life/console-time.png" alt="Screenshot of console.time logs" /></a></p>
<p>Additionally, <code>console.time</code> and <code>console.timeEnd</code> pairs will show up in your
browser's profiler's &quot;timeline&quot; or &quot;waterfall&quot; view:</p>
<p><a href="game-of-life/../images/game-of-life/console-time-in-profiler.png"><img src="game-of-life/../images/game-of-life/console-time-in-profiler.png" alt="Screenshot of console.time logs" /></a></p>
<h2 id="growing-our-game-of-life-universe"><a class="header" href="#growing-our-game-of-life-universe">Growing our Game of Life Universe</a></h2>
<blockquote>
<p>⚠️ This section utilizes example screenshots from Firefox. While all modern
browsers have similar tools, there might be slight nuances to working with
different developer tools. The profile information you extract will be
essentially the same, but your mileage might vary in terms of the views you
see and the naming of different tools.</p>
</blockquote>
<p>What happens if we make our Game of Life universe larger? Replacing the 64 by 64
universe with a 128 by 128 universe (by modifying <code>Universe::new</code> in
<code>wasm-game-of-life/src/lib.rs</code>) results in FPS dropping from a smooth 60 to a
choppy 40-ish on my machine.</p>
<p>If we record a profile and look at the waterfall view, we see that each
animation frame is taking over 20 milliseconds. Recall that 60 frames per second
leaves sixteen milliseconds for the whole process of rendering a frame. That's
not just our JavaScript and WebAssembly, but also everything else the browser is
doing, such as painting.</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-waterfall.png"><img src="game-of-life/../images/game-of-life/drawCells-before-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame" /></a></p>
<p>If we look at what happens within a single animation frame, we see that the
<code>CanvasRenderingContext2D.fillStyle</code> setter is very expensive!</p>
<blockquote>
<p>⚠️ In Firefox, if you see a line that simply says &quot;DOM&quot; instead of the
<code>CanvasRenderingContext2D.fillStyle</code> mentioned above, you may need to turn on
the option for &quot;Show Gecko Platform Data&quot; in your performance developer tools
options:</p>
<p><a href="game-of-life/../images/game-of-life/profiler-firefox-show-gecko-platform.png"><img src="game-of-life/../images/game-of-life/profiler-firefox-show-gecko-platform.png" alt="Turning on Show Gecko Platform Data" /></a></p>
</blockquote>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-before-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>And we can confirm that this isn't an abnormality by looking at the call tree's
aggregation of many frames:</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-calltree.png"><img src="game-of-life/../images/game-of-life/drawCells-before-calltree.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>Nearly 40% of our time is spent in this setter!</p>
<blockquote>
<p>⚡ We might have expected something in the <code>tick</code> method to be the performance
bottleneck, but it wasn't. Always let profiling guide your focus, since time
may be spent in places you don't expect it to be.</p>
</blockquote>
<p>In the <code>drawCells</code> function in <code>wasm-game-of-life/www/index.js</code>, the <code>fillStyle</code>
property is set once for every cell in the universe, on every animation frame:</p>
<pre><code class="language-js">for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);

    ctx.fillStyle = cells[idx] === DEAD
      ? DEAD_COLOR
      : ALIVE_COLOR;

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>Now that we have discovered that setting <code>fillStyle</code> is so expensive, what can
we do to avoid setting it so often? We need to change <code>fillStyle</code> depending on
whether a cell is alive or dead. If we set <code>fillStyle = ALIVE_COLOR</code> and then
draw every alive cell in one pass, and then set <code>fillStyle = DEAD_COLOR</code> and
draw every dead cell in another pass, then we only end setting <code>fillStyle</code>
twice, rather than once for every cell.</p>
<pre><code class="language-js">// Alive cells.
ctx.fillStyle = ALIVE_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Alive) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}

// Dead cells.
ctx.fillStyle = DEAD_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Dead) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>After saving these changes and refreshing
<a href="http://localhost:8080/">http://localhost:8080/</a>, rendering is back to a smooth
60 frames per second.</p>
<p>If we take another profile, we can see that only about ten milliseconds are
spent in each animation frame now.</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-after-waterfall.png"><img src="game-of-life/../images/game-of-life/drawCells-after-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame after the drawCells changes" /></a></p>
<p>Breaking down a single frame, we see that the <code>fillStyle</code> cost is gone, and most
of our frame's time is spent within <code>fillRect</code>, drawing each cell's rectangle.</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame after the drawCells changes" /></a></p>
<h2 id="making-time-run-faster"><a class="header" href="#making-time-run-faster">Making Time Run Faster</a></h2>
<p>Some folks don't like waiting around, and would prefer if instead of one tick of
the universe occurred per animation frame, nine ticks did. We can modify the
<code>renderLoop</code> function in <code>wasm-game-of-life/www/index.js</code> to do this quite
easily:</p>
<pre><code class="language-js">for (let i = 0; i &lt; 9; i++) {
  universe.tick();
}
</code></pre>
<p>On my machine, this brings us back down to only 35 frames per second. No
good. We want that buttery 60!</p>
<p>Now we know that time is being spent in <code>Universe::tick</code>, so let's add some
<code>Timer</code>s to wrap various bits of it in <code>console.time</code> and <code>console.timeEnd</code>
calls, and see where that leads us. My hypothesis is that allocating a new
vector of cells and freeing the old vector on every tick is costly, and taking
up a significant portion of our time budget.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn tick(&amp;mut self) {
    let _timer = Timer::new(&quot;Universe::tick&quot;);

    let mut next = {
        let _timer = Timer::new(&quot;allocate next cells&quot;);
        self.cells.clone()
    };

    {
        let _timer = Timer::new(&quot;new generation&quot;);
        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }
    }

    let _timer = Timer::new(&quot;free old cells&quot;);
    self.cells = next;
}
<span class="boring">}
</span></code></pre></pre>
<p>Looking at the timings, it is clear that my hypothesis is incorrect: the vast
majority of time is spent actually calculating the next generation of
cells. Allocating and freeing a vector on every tick appears to have negligible
cost, surprisingly. Another reminder to always guide our efforts with profiling!</p>
<p><a href="game-of-life/../images/game-of-life/console-time-in-universe-tick.png"><img src="game-of-life/../images/game-of-life/console-time-in-universe-tick.png" alt="Screenshot of a Universe::tick timer results" /></a></p>
<p>The next section requires the <code>nightly</code> compiler. It's required because of
the <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">test feature gate</a>
we're going to use for the benchmarks. Another tool we will install is <a href="https://github.com/BurntSushi/cargo-benchcmp">cargo benchcmp</a>.
It's a small utility for comparing micro-benchmarks produced by <code>cargo bench</code>.</p>
<p>Let's write a native code <code>#[bench]</code> doing the same thing that our WebAssembly
is doing, but where we can use more mature profiling tools. Here is the new
<code>wasm-game-of-life/benches/bench.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate test;
extern crate wasm_game_of_life;

#[bench]
fn universe_ticks(b: &amp;mut test::Bencher) {
    let mut universe = wasm_game_of_life::Universe::new();

    b.iter(|| {
        universe.tick();
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>We also have to comment out all the <code>#[wasm_bindgen]</code> annotations, and the
<code>&quot;cdylib&quot;</code> bits from <code>Cargo.toml</code> or else building native code will fail and
have link errors.</p>
<p>With all that in place, we can run <code>cargo bench | tee before.txt</code> to compile and run our
benchmark! The <code>| tee before.txt</code> part will take the output from <code>cargo bench</code> and put in a file
called <code>before.txt</code>.</p>
<pre><code>$ cargo bench | tee before.txt
    Finished release [optimized + debuginfo] target(s) in 0.0 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>This also tells us where the binary lives, and we can run the benchmarks again,
but this time under our operating system's profiler. In my case, I'm running
Linux, so <a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code></a> is the profiler I'll use:</p>
<pre><code>$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench
running 1 test
test universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out

[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]
</code></pre>
<p>Loading up the profile with <code>perf report</code> shows that all of our time is spent in
<code>Universe::tick</code>, as expected:</p>
<p><a href="game-of-life/../images/game-of-life/bench-perf-report.png"><img src="game-of-life/../images/game-of-life/bench-perf-report.png" alt="Screenshot of perf report" /></a></p>
<p><code>perf</code> will annotate which instructions in a function time is being spent at if
you press <code>a</code>:</p>
<p><a href="game-of-life/../images/game-of-life/bench-perf-annotate.png"><img src="game-of-life/../images/game-of-life/bench-perf-annotate.png" alt="Screenshot of perf's instruction annotation" /></a></p>
<p>This tells us that 26.67% of time is being spent summing neighboring cells'
values, 23.41% of time is spent getting the neighbor's column index, and another
15.42% of time is spent getting the neighbor's row index. Of these top three
most expensive instructions, the second and third are both costly <code>div</code>
instructions. These <code>div</code>s implement the modulo indexing logic in
<code>Universe::live_neighbor_count</code>.</p>
<p>Recall the <code>live_neighbor_count</code> definition inside
<code>wasm-game-of-life/src/lib.rs</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;
    for delta_row in [self.height - 1, 0, 1].iter().cloned() {
        for delta_col in [self.width - 1, 0, 1].iter().cloned() {
            if delta_row == 0 &amp;&amp; delta_col == 0 {
                continue;
            }

            let neighbor_row = (row + delta_row) % self.height;
            let neighbor_col = (column + delta_col) % self.width;
            let idx = self.get_index(neighbor_row, neighbor_col);
            count += self.cells[idx] as u8;
        }
    }
    count
}
<span class="boring">}
</span></code></pre></pre>
<p>The reason we used modulo was to avoid cluttering up the code with <code>if</code> branches
for the first or last row or column edge cases. But we are paying the cost of a
<code>div</code> instruction even for the most common case, when neither <code>row</code> nor <code>column</code>
is on the edge of the universe and they don't need the modulo wrapping
treatment. Instead, if we use <code>if</code>s for the edge cases and unroll this loop, the
branches <em>should</em> be very well-predicted by the CPU's branch predictor.</p>
<p>Let's rewrite <code>live_neighbor_count</code> like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;

    let north = if row == 0 {
        self.height - 1
    } else {
        row - 1
    };

    let south = if row == self.height - 1 {
        0
    } else {
        row + 1
    };

    let west = if column == 0 {
        self.width - 1
    } else {
        column - 1
    };

    let east = if column == self.width - 1 {
        0
    } else {
        column + 1
    };

    let nw = self.get_index(north, west);
    count += self.cells[nw] as u8;

    let n = self.get_index(north, column);
    count += self.cells[n] as u8;

    let ne = self.get_index(north, east);
    count += self.cells[ne] as u8;

    let w = self.get_index(row, west);
    count += self.cells[w] as u8;

    let e = self.get_index(row, east);
    count += self.cells[e] as u8;

    let sw = self.get_index(south, west);
    count += self.cells[sw] as u8;

    let s = self.get_index(south, column);
    count += self.cells[s] as u8;

    let se = self.get_index(south, east);
    count += self.cells[se] as u8;

    count
}
<span class="boring">}
</span></code></pre></pre>
<p>Now let's run the benchmarks again! This time output it to <code>after.txt</code>.</p>
<pre><code>$ cargo bench | tee after.txt
   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)
    Finished release [optimized + debuginfo] target(s) in 0.82 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>That looks a whole lot better! We can see just how much better it is with the <code>benchcmp</code> tool and the two text files we created before:</p>
<pre><code>$ cargo benchcmp before.txt after.txt
 name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup
 universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61
</code></pre>
<p>Wow! 7.61x speed up!</p>
<p>WebAssembly intentionally maps closely to common hardware architectures, but we
do need to make sure that this native code speed up translates into a
WebAssembly speed up as well.</p>
<p>Let's rebuild the <code>.wasm</code> with <code>wasm-pack build</code> and refresh
<a href="http://localhost:8080/">http://localhost:8080/</a>. On my machine, the page is
running at 60 frames per second again, and recording another profile with the
browser's profiler reveals that each animation frame is taking about ten
milliseconds.</p>
<p>Success!</p>
<p><a href="game-of-life/../images/game-of-life/waterfall-after-branches-and-unrolling.png"><img src="game-of-life/../images/game-of-life/waterfall-after-branches-and-unrolling.png" alt="Screenshot of a waterfall view of rendering a frame after replacing modulos with branches" /></a></p>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ul>
<li>
<p>At this point, the next lowest hanging fruit for speeding up <code>Universe::tick</code>
is removing the allocation and free. Implement double buffering of cells,
where the <code>Universe</code> maintains two vectors, never frees either of them, and
never allocates new buffers in <code>tick</code>.</p>
</li>
<li>
<p>Implement the alternative, delta-based design from the &quot;Implementing Life&quot;
chapter, where the Rust code returns a list of cells that changed states to
JavaScript. Does this make rendering to <code>&lt;canvas&gt;</code> faster? Can you implement
this design without allocating a new list of deltas on every tick?</p>
</li>
<li>
<p>As our profiling has shown us, 2D <code>&lt;canvas&gt;</code> rendering is not particularly
fast. Replace the 2D canvas renderer with a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a> renderer. How much faster is
the WebGL version? How large can you make the universe before WebGL rendering
is a bottleneck?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shrinking-wasm-size"><a class="header" href="#shrinking-wasm-size">Shrinking <code>.wasm</code> Size</a></h1>
<p>For <code>.wasm</code> binaries that we ship to clients over the network, such as our Game
of Life Web application, we want to keep an eye on code size. The smaller our
<code>.wasm</code> is, the faster our page loads get, and the happier our users are.</p>
<h2 id="how-small-can-we-get-our-game-of-life-wasm-binary-via-build-configuration"><a class="header" href="#how-small-can-we-get-our-game-of-life-wasm-binary-via-build-configuration">How small can we get our Game of Life <code>.wasm</code> binary via build configuration?</a></h2>
<p><a href="game-of-life/../reference/code-size.html#optimizing-builds-for-code-size">Take a moment to review the build configuration options we can tweak to get
smaller <code>.wasm</code> code
sizes.</a></p>
<p>With the default release build configuration (without debug symbols), our
WebAssembly binary is 29,410 bytes:</p>
<pre><code>$ wc -c pkg/wasm_game_of_life_bg.wasm
29410 pkg/wasm_game_of_life_bg.wasm
</code></pre>
<p>After enabling LTO, setting <code>opt-level = &quot;z&quot;</code>, and running <code>wasm-opt -Oz</code>, the
resulting <code>.wasm</code> binary shrinks to only 17,317 bytes:</p>
<pre><code>$ wc -c pkg/wasm_game_of_life_bg.wasm
17317 pkg/wasm_game_of_life_bg.wasm
</code></pre>
<p>And if we compress it with <code>gzip</code> (which nearly every HTTP server does) we get
down to a measly 9,045 bytes!</p>
<pre><code>$ gzip -9 &lt; pkg/wasm_game_of_life_bg.wasm | wc -c
9045
</code></pre>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ul>
<li>
<p>Use <a href="game-of-life/../reference/code-size.html#use-the-wasm-snip-tool">the <code>wasm-snip</code> tool</a>
to remove the panicking infrastructure functions from our Game of Life's
<code>.wasm</code> binary. How many bytes does it save?</p>
</li>
<li>
<p>Build our Game of Life crate with and without <a href="https://github.com/rustwasm/wee_alloc"><code>wee_alloc</code> as its global
allocator</a>. The
<code>rustwasm/wasm-pack-template</code> template that we cloned to start this project
has a &quot;wee_alloc&quot; cargo feature that you can enable by adding it to the
<code>default</code> key in the <code>[features]</code> section of <code>wasm-game-of-life/Cargo.toml</code>:</p>
<pre><code class="language-toml">[features]
default = [&quot;wee_alloc&quot;]
</code></pre>
<p>How much size does using <code>wee_alloc</code> shave off of the <code>.wasm</code>
binary?</p>
</li>
<li>
<p>We only ever instantiate a single <code>Universe</code>, so rather than providing a
constructor, we can export operations that manipulate a single <code>static mut</code>
global instance. If this global instance also uses the double buffering
technique discussed in earlier chapters, we can make those buffers also be
<code>static mut</code> globals. This removes all dynamic allocation from our Game of
Life implementation, and we can make it a <code>#![no_std]</code> crate that doesn't
include an allocator. How much size was removed from the <code>.wasm</code> by completely
removing the allocator dependency?</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="publishing-to-npm"><a class="header" href="#publishing-to-npm">Publishing to npm</a></h1>
<p>Now that we have a working, fast, <em>and</em> small <code>wasm-game-of-life</code> package, we
can publish it to npm so other JavaScript developers can reuse it, if they ever
need an off-the-shelf Game of Life implementation.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>First, <a href="https://www.npmjs.com/signup">make sure you have an npm account</a>.</p>
<p>Second, make sure you are logged into your account locally, by running this
command:</p>
<pre><code>wasm-pack login
</code></pre>
<h2 id="publishing"><a class="header" href="#publishing">Publishing</a></h2>
<p>Make sure that the <code>wasm-game-of-life/pkg</code> build is up to date by running
<code>wasm-pack</code> inside the <code>wasm-game-of-life</code> directory:</p>
<pre><code>wasm-pack build
</code></pre>
<p>Take a moment to check out the contents of <code>wasm-game-of-life/pkg</code> now, this is
what we are publishing to npm in the next step!</p>
<p>When you're ready, run <code>wasm-pack publish</code> to upload the package to npm:</p>
<pre><code>wasm-pack publish
</code></pre>
<p>That's all it takes to publish to npm!</p>
<p>...except other folks have also done this tutorial, and therefore the
<code>wasm-game-of-life</code> name is taken on npm, and that last command probably didn't
work.</p>
<p>Open up <code>wasm-game-of-life/Cargo.toml</code> and add your username to the end of the
<code>name</code> to disambiguate the package in a unique way:</p>
<pre><code class="language-toml">[package]
name = &quot;wasm-game-of-life-my-username&quot;
</code></pre>
<p>Then, rebuild and publish again:</p>
<pre><code>wasm-pack build
wasm-pack publish
</code></pre>
<p>This time it should work!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>This section contains reference material for Rust and WebAssembly
development. It is not intended to provide a narrative and be read start to
finish. Instead, each subsection should stand on its own.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates-you-should-know"><a class="header" href="#crates-you-should-know">Crates You Should Know</a></h1>
<p>This is a curated list of awesome crates you should know about for doing Rust
and WebAssembly development.</p>
<p><a href="https://crates.io/categories/wasm">You can also browse all the crates published to crates.io in the WebAssembly
category.</a></p>
<h2 id="interacting-with-javascript-and-the-dom"><a class="header" href="#interacting-with-javascript-and-the-dom">Interacting with JavaScript and the DOM</a></h2>
<h3 id="wasm-bindgen--a-hrefhttpscratesiocrateswasm-bindgencratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgenrepositorya"><a class="header" href="#wasm-bindgen--a-hrefhttpscratesiocrateswasm-bindgencratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgenrepositorya"><code>wasm-bindgen</code> | <a href="https://crates.io/crates/wasm-bindgen">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen">repository</a></a></h3>
<p><code>wasm-bindgen</code> facilitates high-level interactions between Rust and
JavaScript. It allows one to import JavaScript things into Rust and export Rust
things to JavaScript.</p>
<h3 id="wasm-bindgen-futures--a-hrefhttpscratesiocrateswasm-bindgen-futurescratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesfuturesrepositorya"><a class="header" href="#wasm-bindgen-futures--a-hrefhttpscratesiocrateswasm-bindgen-futurescratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesfuturesrepositorya"><code>wasm-bindgen-futures</code> | <a href="https://crates.io/crates/wasm-bindgen-futures">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/futures">repository</a></a></h3>
<p><code>wasm-bindgen-futures</code> is a bridge connecting JavaScript <code>Promise</code>s and Rust
<code>Future</code>s. It can convert in both directions and is useful when working with
asynchronous tasks in Rust, and allows interacting with DOM events and I/O
operations.</p>
<h3 id="js-sys--a-hrefhttpscratesiocratesjs-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesjs-sysrepositorya"><a class="header" href="#js-sys--a-hrefhttpscratesiocratesjs-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesjs-sysrepositorya"><code>js-sys</code> | <a href="https://crates.io/crates/js-sys">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys">repository</a></a></h3>
<p>Raw <code>wasm-bindgen</code> imports for all the JavaScript global types and methods, such
as <code>Object</code>, <code>Function</code>, <code>eval</code>, etc. These APIs are portable across all
standard ECMAScript environments, not just the Web, such as Node.js.</p>
<h3 id="web-sys--a-hrefhttpscratesiocratesweb-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesweb-sysrepositorya"><a class="header" href="#web-sys--a-hrefhttpscratesiocratesweb-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesweb-sysrepositorya"><code>web-sys</code> | <a href="https://crates.io/crates/web-sys">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/web-sys">repository</a></a></h3>
<p>Raw <code>wasm-bindgen</code> imports for all the Web's APIs, such as DOM manipulation,
<code>setTimeout</code>, Web GL, Web Audio, etc.</p>
<h2 id="error-reporting-and-logging"><a class="header" href="#error-reporting-and-logging">Error Reporting and Logging</a></h2>
<h3 id="console_error_panic_hook--a-hrefhttpscratesiocratesconsole_error_panic_hookcratesioa--a-hrefhttpsgithubcomrustwasmconsole_error_panic_hookrepositorya"><a class="header" href="#console_error_panic_hook--a-hrefhttpscratesiocratesconsole_error_panic_hookcratesioa--a-hrefhttpsgithubcomrustwasmconsole_error_panic_hookrepositorya"><code>console_error_panic_hook</code> | <a href="https://crates.io/crates/console_error_panic_hook">crates.io</a> | <a href="https://github.com/rustwasm/console_error_panic_hook">repository</a></a></h3>
<p>This crate lets you debug panics on <code>wasm32-unknown-unknown</code> by providing a
panic hook that forwards panic messages to <code>console.error</code>.</p>
<h3 id="console_log--a-hrefhttpscratesiocratesconsole_logcratesioa--a-hrefhttpsgithubcomiamcodemakerconsole_logrepositorya"><a class="header" href="#console_log--a-hrefhttpscratesiocratesconsole_logcratesioa--a-hrefhttpsgithubcomiamcodemakerconsole_logrepositorya"><code>console_log</code> | <a href="https://crates.io/crates/console_log">crates.io</a> | <a href="https://github.com/iamcodemaker/console_log">repository</a></a></h3>
<p>This crate provides a backend for <a href="https://crates.io/crates/log">the <code>log</code>
crate</a> that routes logged messages to the devtools
console.</p>
<h2 id="dynamic-allocation"><a class="header" href="#dynamic-allocation">Dynamic Allocation</a></h2>
<h3 id="wee_alloc--a-hrefhttpscratesiocrateswee_alloccratesioa--a-hrefhttpsgithubcomrustwasmwee_allocrepositorya"><a class="header" href="#wee_alloc--a-hrefhttpscratesiocrateswee_alloccratesioa--a-hrefhttpsgithubcomrustwasmwee_allocrepositorya"><code>wee_alloc</code> | <a href="https://crates.io/crates/wee_alloc">crates.io</a> | <a href="https://github.com/rustwasm/wee_alloc">repository</a></a></h3>
<p>The <strong>W</strong>asm-<strong>E</strong>nabled, <strong>E</strong>lfin Allocator. A small (~1K uncompressed
<code>.wasm</code>) allocator implementation for when code size is a greater concern than
allocation performance.</p>
<h2 id="parsing-and-generating-wasm-binaries"><a class="header" href="#parsing-and-generating-wasm-binaries">Parsing and Generating <code>.wasm</code> Binaries</a></h2>
<h3 id="parity-wasm--a-hrefhttpscratesiocratesparity-wasmcratesioa--a-hrefhttpsgithubcomparitytechparity-wasmrepositorya"><a class="header" href="#parity-wasm--a-hrefhttpscratesiocratesparity-wasmcratesioa--a-hrefhttpsgithubcomparitytechparity-wasmrepositorya"><code>parity-wasm</code> | <a href="https://crates.io/crates/parity-wasm">crates.io</a> | <a href="https://github.com/paritytech/parity-wasm">repository</a></a></h3>
<p>Low-level WebAssembly format library for serializing, deserializing, and
building <code>.wasm</code> binaries. Good support for well-known custom sections, such as
the &quot;names&quot; section and &quot;reloc.WHATEVER&quot; sections.</p>
<h3 id="wasmparser--a-hrefhttpscratesiocrateswasmparsercratesioa--a-hrefhttpsgithubcomyurydelendikwasmparserrsrepositorya"><a class="header" href="#wasmparser--a-hrefhttpscratesiocrateswasmparsercratesioa--a-hrefhttpsgithubcomyurydelendikwasmparserrsrepositorya"><code>wasmparser</code> | <a href="https://crates.io/crates/wasmparser">crates.io</a> | <a href="https://github.com/yurydelendik/wasmparser.rs">repository</a></a></h3>
<p>A simple, event-driven library for parsing WebAssembly binary files. Provides
the byte offsets of each parsed thing, which is necessary when interpreting
relocs, for example.</p>
<h2 id="interpreting-and-compiling-webassembly"><a class="header" href="#interpreting-and-compiling-webassembly">Interpreting and Compiling WebAssembly</a></h2>
<h3 id="wasmi--a-hrefhttpscratesiocrateswasmicratesioa--a-hrefhttpsgithubcomparitytechwasmirepositorya"><a class="header" href="#wasmi--a-hrefhttpscratesiocrateswasmicratesioa--a-hrefhttpsgithubcomparitytechwasmirepositorya"><code>wasmi</code> | <a href="https://crates.io/crates/wasmi">crates.io</a> | <a href="https://github.com/paritytech/wasmi">repository</a></a></h3>
<p>An embeddable WebAssembly interpreter from Parity.</p>
<h3 id="cranelift-wasm--a-hrefhttpscratesiocratescranelift-wasmcratesioa--a-hrefhttpsgithubcombytecodealliancewasmtimetreemastercraneliftrepositorya"><a class="header" href="#cranelift-wasm--a-hrefhttpscratesiocratescranelift-wasmcratesioa--a-hrefhttpsgithubcombytecodealliancewasmtimetreemastercraneliftrepositorya"><code>cranelift-wasm</code> | <a href="https://crates.io/crates/cranelift-wasm">crates.io</a> | <a href="https://github.com/bytecodealliance/wasmtime/tree/master/cranelift">repository</a></a></h3>
<p>Compile WebAssembly to the native host's machine code. Part of the Cranelift (né
Cretonne) code generator project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tools-you-should-know"><a class="header" href="#tools-you-should-know">Tools You Should Know</a></h1>
<p>This is a curated list of awesome tools you should know about when doing Rust
and WebAssembly development.</p>
<h2 id="development-build-and-workflow-orchestration"><a class="header" href="#development-build-and-workflow-orchestration">Development, Build, and Workflow Orchestration</a></h2>
<h3 id="wasm-pack--a-hrefhttpsgithubcomrustwasmwasm-packrepositorya"><a class="header" href="#wasm-pack--a-hrefhttpsgithubcomrustwasmwasm-packrepositorya"><code>wasm-pack</code> | <a href="https://github.com/rustwasm/wasm-pack">repository</a></a></h3>
<p><code>wasm-pack</code> seeks to be a one-stop shop for building and working with Rust-
generated WebAssembly that you would like to interoperate with JavaScript, on
the Web or with Node.js. <code>wasm-pack</code> helps you build and publish Rust-generated
WebAssembly to the npm registry to be used alongside any other JavaScript
package in workflows that you already use.</p>
<h2 id="optimizing-and-manipulating-wasm-binaries"><a class="header" href="#optimizing-and-manipulating-wasm-binaries">Optimizing and Manipulating <code>.wasm</code> Binaries</a></h2>
<h3 id="wasm-opt--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><a class="header" href="#wasm-opt--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><code>wasm-opt</code> | <a href="https://github.com/WebAssembly/binaryen">repository</a></a></h3>
<p>The <code>wasm-opt</code> tool reads WebAssembly as input, runs transformation,
optimization, and/or instrumentation passes on it, and then emits the
transformed WebAssembly as output. Running it on the <code>.wasm</code> binaries produced
by LLVM by way of <code>rustc</code> will usually create <code>.wasm</code> binaries that are both
smaller and execute faster. This tool is a part of the <code>binaryen</code> project.</p>
<h3 id="wasm2js--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><a class="header" href="#wasm2js--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><code>wasm2js</code> | <a href="https://github.com/WebAssembly/binaryen">repository</a></a></h3>
<p>The <code>wasm2js</code> tool compiles WebAssembly into &quot;almost asm.js&quot;. This is great for
supporting browsers that don't have a WebAssembly implementation, such as
Internet Explorer 11. This tool is a part of the <code>binaryen</code> project.</p>
<h3 id="wasm-gc--a-hrefhttpsgithubcomalexcrichtonwasm-gcrepositorya"><a class="header" href="#wasm-gc--a-hrefhttpsgithubcomalexcrichtonwasm-gcrepositorya"><code>wasm-gc</code> | <a href="https://github.com/alexcrichton/wasm-gc">repository</a></a></h3>
<p>A small tool to garbage collect a WebAssembly module and remove all unneeded
exports, imports, functions, etc. This is effectively a <code>--gc-sections</code> linker
flag for WebAssembly.</p>
<p>You don't usually need to use this tool yourself because of two reasons:</p>
<ol>
<li><code>rustc</code> now has a new enough version of <code>lld</code> that it supports the
<code>--gc-sections</code> flag for WebAssembly. This is automatically enabled for LTO
builds.</li>
<li>The <code>wasm-bindgen</code> CLI tool runs <code>wasm-gc</code> for you automatically.</li>
</ol>
<h3 id="wasm-snip--a-hrefhttpsgithubcomrustwasmwasm-sniprepositorya"><a class="header" href="#wasm-snip--a-hrefhttpsgithubcomrustwasmwasm-sniprepositorya"><code>wasm-snip</code> | <a href="https://github.com/rustwasm/wasm-snip">repository</a></a></h3>
<p><code>wasm-snip</code> replaces a WebAssembly function's body with an <code>unreachable</code>
instruction.</p>
<p>Maybe you know that some function will never be called at runtime, but the
compiler can't prove that at compile time? Snip it! Then run <code>wasm-gc</code> again and
all the functions it transitively called (which could also never be called at
runtime) will get removed too.</p>
<p>This is useful for forcibly removing Rust's panicking infrastructure in
non-debug production builds.</p>
<h2 id="inspecting-wasm-binaries"><a class="header" href="#inspecting-wasm-binaries">Inspecting <code>.wasm</code> Binaries</a></h2>
<h3 id="twiggy--a-hrefhttpsgithubcomrustwasmtwiggyrepositorya"><a class="header" href="#twiggy--a-hrefhttpsgithubcomrustwasmtwiggyrepositorya"><code>twiggy</code> | <a href="https://github.com/rustwasm/twiggy">repository</a></a></h3>
<p><code>twiggy</code> is a code size profiler for <code>.wasm</code> binaries. It analyzes a binary's
call graph to answer questions like:</p>
<ul>
<li>Why was this function included in the binary in the first place? I.e. which
exported functions are transitively calling it?</li>
<li>What is the retained size of this function? I.e. how much space would be saved
if I removed it and all the functions that become dead code after its removal.</li>
</ul>
<p>Use <code>twiggy</code> to make your binaries slim!</p>
<h3 id="wasm-objdump--a-hrefhttpsgithubcomwebassemblywabtrepositorya"><a class="header" href="#wasm-objdump--a-hrefhttpsgithubcomwebassemblywabtrepositorya"><code>wasm-objdump</code> | <a href="https://github.com/WebAssembly/wabt">repository</a></a></h3>
<p>Print low-level details about a <code>.wasm</code> binary and each of its sections. Also
supports disassembling into the WAT text format. It's like <code>objdump</code> but for
WebAssembly. This is a part of the WABT project.</p>
<h3 id="wasm-nm--a-hrefhttpsgithubcomfitzgenwasm-nmrepositorya"><a class="header" href="#wasm-nm--a-hrefhttpsgithubcomfitzgenwasm-nmrepositorya"><code>wasm-nm</code> | <a href="https://github.com/fitzgen/wasm-nm">repository</a></a></h3>
<p>List the imported, exported, and private function symbols defined within a
<code>.wasm</code> binary. It's like <code>nm</code> but for WebAssembly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-templates"><a class="header" href="#project-templates">Project Templates</a></h1>
<p>The Rust and WebAssembly working group curates and maintains a variety of
project templates to help you kickstart new projects and hit the ground running.</p>
<h2 id="wasm-pack-template"><a class="header" href="#wasm-pack-template"><code>wasm-pack-template</code></a></h2>
<p><a href="https://github.com/rustwasm/wasm-pack-template">This template</a> is for starting a Rust and WebAssembly
project to be used with <a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a>.</p>
<p>Use <code>cargo generate</code> to clone this project template:</p>
<pre><code>cargo install cargo-generate
cargo generate --git https://github.com/rustwasm/wasm-pack-template.git
</code></pre>
<h2 id="create-wasm-app"><a class="header" href="#create-wasm-app"><code>create-wasm-app</code></a></h2>
<p><a href="https://github.com/rustwasm/create-wasm-app">This template</a> is for JavaScript projects that consume
packages from npm that were created from Rust with <a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a>.</p>
<p>Use it with <code>npm init</code>:</p>
<pre><code>mkdir my-project
cd my-project/
npm init wasm-app
</code></pre>
<p>This template is often used alongside <code>wasm-pack-template</code>, where
<code>wasm-pack-template</code> projects are installed locally with <code>npm link</code>, and pulled
in as a dependency for a <code>create-wasm-app</code> project.</p>
<h2 id="rust-webpack-template"><a class="header" href="#rust-webpack-template"><code>rust-webpack-template</code></a></h2>
<p><a href="https://github.com/rustwasm/rust-webpack-template">This template</a> comes pre-configured with all the
boilerplate for compiling Rust to WebAssembly and hooking that directly into a
Webpack build pipeline with Webpack's <a href="https://github.com/wasm-tool/rust-loader/"><code>rust-loader</code></a>.</p>
<p>Use it with <code>npm init</code>:</p>
<pre><code>mkdir my-project
cd my-project/
npm init rust-webpack
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-rust-generated-webassembly"><a class="header" href="#debugging-rust-generated-webassembly">Debugging Rust-Generated WebAssembly</a></h1>
<p>This section contains tips for debugging Rust-generated WebAssembly.</p>
<h2 id="building-with-debug-symbols"><a class="header" href="#building-with-debug-symbols">Building with Debug Symbols</a></h2>
<blockquote>
<p>⚡ When debugging, always make sure you are building with debug symbols!</p>
</blockquote>
<p>If you don't have debug symbols enabled, then the <code>&quot;name&quot;</code> custom section won't
be present in the compiled <code>.wasm</code> binary, and stack traces will have function
names like <code>wasm-function[42]</code> rather than the Rust name of the function, like
<code>wasm_game_of_life::Universe::live_neighbor_count</code>.</p>
<p>When using a &quot;debug&quot; build (aka <code>wasm-pack build --debug</code> or <code>cargo build</code>)
debug symbols are enabled by default.</p>
<p>With a &quot;release&quot; build, debug symbols are not enabled by default. To enable
debug symbols, ensure that you <code>debug = true</code> in the <code>[profile.release]</code> section
of your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.release]
debug = true
</code></pre>
<h2 id="logging-with-the-console-apis"><a class="header" href="#logging-with-the-console-apis">Logging with the <code>console</code> APIs</a></h2>
<p>Logging is one of the most effective tools we have for proving and disproving
hypotheses about why our programs are buggy. On the Web, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/log">the <code>console.log</code>
function</a> is the
way to log messages to the browser's developer tools console.</p>
<p>We can use <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html">the <code>web-sys</code> crate</a> to get access to the <code>console</code> logging
functions:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

web_sys::console::log_1(&amp;&quot;Hello, world!&quot;.into());
<span class="boring">}
</span></code></pre></pre>
<p>Alternatively, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/error">the <code>console.error</code>
function</a> has
the same signature as <code>console.log</code>, but developer tools tend to also capture
and display a stack trace alongside the logged message when <code>console.error</code> is
used.</p>
<h3 id="references"><a class="header" href="#references">References</a></h3>
<ul>
<li>Using <code>console.log</code> with the <code>web-sys</code> crate:
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html"><code>web_sys::console::log</code> takes an array of values to log</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html"><code>web_sys::console::log_1</code> logs a single value</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html"><code>web_sys::console::log_2</code> logs two values</a></li>
<li>Etc...</li>
</ul>
</li>
<li>Using <code>console.error</code> with the <code>web-sys</code> crate:
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html"><code>web_sys::console::error</code> takes an array of values to log</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html"><code>web_sys::console::error_1</code> logs a single value</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html"><code>web_sys::console::error_2</code> logs two values</a></li>
<li>Etc...</li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console">The <code>console</code> object on MDN</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Web_Console">Firefox Developer Tools — Web Console</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/console">Microsoft Edge Developer Tools — Console</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/console/get-started">Get Started with the Chrome DevTools Console</a></li>
</ul>
<h2 id="logging-panics"><a class="header" href="#logging-panics">Logging Panics</a></h2>
<p><a href="https://github.com/rustwasm/console_error_panic_hook">The <code>console_error_panic_hook</code> crate logs unexpected panics to the developer
console via <code>console.error</code>.</a> Rather than getting cryptic,
difficult-to-debug <code>RuntimeError: unreachable executed</code> error messages, this
gives you Rust's formatted panic message.</p>
<p>All you need to do is install the hook by calling
<code>console_error_panic_hook::set_once()</code> in an initialization function or common
code path:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn init_panic_hook() {
    console_error_panic_hook::set_once();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-a-debugger"><a class="header" href="#using-a-debugger">Using a Debugger</a></h2>
<p>Unfortunately, the debugging story for WebAssembly is still immature. On most
Unix systems, <a href="http://dwarfstd.org/">DWARF</a> is used to encode the information that a debugger
needs to provide source-level inspection of a running program. There is an
alternative format that encodes similar information on Windows. Currently, there
is no equivalent for WebAssembly. Therefore, debuggers currently provide limited
utility, and we end up stepping through raw WebAssembly instructions emitted by
the compiler, rather than the Rust source text we authored.</p>
<blockquote>
<p>There is a <a href="https://github.com/WebAssembly/debugging">sub-charter of the W3C WebAssembly group for
debugging</a>, so expect this story to improve in the
future!</p>
</blockquote>
<p>Nonetheless, debuggers are still useful for inspecting the JavaScript that
interacts with our WebAssembly, and inspecting raw wasm state.</p>
<h3 id="references-1"><a class="header" href="#references-1">References</a></h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger">Firefox Developer Tools — Debugger</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/debugger">Microsoft Edge Developer Tools — Debugger</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/">Get Started with Debugging JavaScript in Chrome DevTools</a></li>
</ul>
<h2 id="avoid-the-need-to-debug-webassembly-in-the-first-place"><a class="header" href="#avoid-the-need-to-debug-webassembly-in-the-first-place">Avoid the Need to Debug WebAssembly in the First Place</a></h2>
<p>If the bug is specific to interactions with JavaScript or Web APIs, then <a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html">write
tests with <code>wasm-bindgen-test</code>.</a></p>
<p>If a bug does <em>not</em> involve interaction with JavaScript or Web APIs, then try to
reproduce it as a normal Rust <code>#[test]</code> function, where you can leverage your
OS's mature native tooling when debugging. Use testing crates like
<a href="https://crates.io/crates/quickcheck"><code>quickcheck</code></a> and its test case shrinkers to mechanically reduce
test cases. Ultimately, you will have an easier time finding and fixing bugs if
you can isolate them in a smaller test cases that don't require interacting with
JavaScript.</p>
<p>Note that in order to run native <code>#[test]</code>s without compiler and linker errors,
you will need to ensure that <code>&quot;rlib&quot;</code> is included in the <code>[lib.crate-type]</code>
array in your <code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">[lib]
crate-type [&quot;cdylib&quot;, &quot;rlib&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-profiling-1"><a class="header" href="#time-profiling-1">Time Profiling</a></h1>
<p>This section describes how to profile Web pages using Rust and WebAssembly where
the goal is improving throughput or latency.</p>
<blockquote>
<p>⚡ Always make sure you are using an optimized build when profiling! <code>wasm-pack build</code> will build with optimizations by default.</p>
</blockquote>
<h2 id="available-tools"><a class="header" href="#available-tools">Available Tools</a></h2>
<h3 id="the-windowperformancenow-timer"><a class="header" href="#the-windowperformancenow-timer">The <code>window.performance.now()</code> Timer</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now">The <code>performance.now()</code> function</a> returns a monotonic timestamp
measured in milliseconds since the Web page was loaded.</p>
<p>Calling <code>performance.now</code> has little overhead, so we can create simple, granular
measurements from it without distorting the performance of the rest of the
system and inflicting bias upon our measurements.</p>
<p>We can use it to time various operations, and we can access
<code>window.performance.now()</code> via <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html">the <code>web-sys</code> crate</a>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

fn now() -&gt; f64 {
    web_sys::window()
        .expect(&quot;should have a Window&quot;)
        .performance()
        .expect(&quot;should have a Performance&quot;)
        .now()
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/fn.window.html">The <code>web_sys::window</code> function</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.performance">The <code>web_sys::Window::performance</code> method</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Performance.html#method.now">The <code>web_sys::Performance::now</code> method</a></li>
</ul>
<h3 id="developer-tools-profilers"><a class="header" href="#developer-tools-profilers">Developer Tools Profilers</a></h3>
<p>All Web browsers' built-in developer tools include a profiler. These profilers
display which functions are taking the most time with the usual kinds of
visualizations like call trees and flame graphs.</p>
<p>If you <a href="reference/./debugging.html#building-with-debug-symbols">build with debug symbols</a> so that the &quot;name&quot; custom section is
included in the wasm binary, then these profilers should display the Rust
function names instead of something opaque like <code>wasm-function[123]</code>.</p>
<p>Note that these profilers <em>won't</em> show inlined functions, and since Rust and
LLVM rely on inlining so heavily, the results might still end up a bit
perplexing.</p>
<p><a href="reference/../images/game-of-life/profiler-with-rust-names.png"><img src="reference/../images/game-of-life/profiler-with-rust-names.png" alt="Screenshot of profiler with Rust symbols" /></a></p>
<h4 id="resources"><a class="header" href="#resources">Resources</a></h4>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Performance">Firefox Developer Tools — Performance</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/performance">Microsoft Edge Developer Tools — Performance</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution">Chrome DevTools JavaScript Profiler</a></li>
</ul>
<h3 id="the-consoletime-and-consoletimeend-functions"><a class="header" href="#the-consoletime-and-consoletimeend-functions">The <code>console.time</code> and <code>console.timeEnd</code> Functions</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/time">The <code>console.time</code> and <code>console.timeEnd</code> functions</a> allow you to
log the timing of named operations to the browser's developer tools console. You
call <code>console.time(&quot;some operation&quot;)</code> when the operation begins, and call
<code>console.timeEnd(&quot;some operation&quot;)</code> when it finishes. The string label naming
the operation is optional.</p>
<p>You can use these functions directly via <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html">the <code>web-sys</code> crate</a>:</p>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_with_label.html"><code>web_sys::console::time_with_label(&quot;some operation&quot;)</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_end_with_label.html"><code>web_sys::console::time_end_with_label(&quot;some operation&quot;)</code></a></li>
</ul>
<p>Here is a screenshot of <code>console.time</code> logs in the browser's console:</p>
<p><a href="reference/../images/game-of-life/console-time.png"><img src="reference/../images/game-of-life/console-time.png" alt="Screenshot of console.time logs" /></a></p>
<p>Additionally, <code>console.time</code> and <code>console.timeEnd</code> logs will show up in your
browser's profiler's &quot;timeline&quot; or &quot;waterfall&quot; view:</p>
<p><a href="reference/../images/game-of-life/console-time-in-profiler.png"><img src="reference/../images/game-of-life/console-time-in-profiler.png" alt="Screenshot of console.time logs" /></a></p>
<h3 id="using-bench-with-native-code"><a class="header" href="#using-bench-with-native-code">Using <code>#[bench]</code> with Native Code</a></h3>
<p>The same way we can often leverage our operating system's native code debugging
tools by writing <code>#[test]</code>s rather than debugging on the Web, we can leverage
our operating system's native code profiling tools by writing <code>#[bench]</code>
functions.</p>
<p>Write your benchmarks in the <code>benches</code> subdirectory of your crate. Make sure
that your <code>crate-type</code> includes <code>&quot;rlib&quot;</code> or else the bench binaries won't be
able to link your main lib.</p>
<p>However! Make sure that you know the bottleneck is in the WebAssembly before
investing much energy in native code profiling! Use your browser's profiler to
confirm this, or else you risk wasting your time optimizing code that isn't hot.</p>
<h4 id="resources-1"><a class="header" href="#resources-1">Resources</a></h4>
<ul>
<li><a href="http://www.brendangregg.com/perf.html">Using the <code>perf</code> profiler on Linux</a></li>
<li><a href="https://help.apple.com/instruments/mac/current/">Using the Instruments.app profiler on macOS</a></li>
<li><a href="https://software.intel.com/en-us/vtune">The VTune profiler supports Windows and Linux</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shrinking-wasm-code-size"><a class="header" href="#shrinking-wasm-code-size">Shrinking <code>.wasm</code> Code Size</a></h1>
<p>This section will teach you how to optimize your <code>.wasm</code> build for a small code
size footprint, and how to identify opportunities to change your Rust source
such that less <code>.wasm</code> code is emitted.</p>
<h2 id="why-care-about-code-size"><a class="header" href="#why-care-about-code-size">Why Care About Code Size?</a></h2>
<p>When serving a <code>.wasm</code> file over the network, the smaller it is, the faster the
client can download it. Faster <code>.wasm</code> downloads lead to faster page load times,
and that leads to happier users.</p>
<p>However, it's important to remember though that code size likely isn't the
end-all-be-all metric you're interested in, but rather something much more vague
and hard to measure like &quot;time to first interaction&quot;. While code size plays a
large factor in this measurement (can't do anything if you don't even have all
the code yet!) it's not the only factor.</p>
<p>WebAssembly is typically served to users gzip'd so you'll want to be sure to
compare differences in gzip'd size for transfer times over the wire. Also keep
in mind that the WebAssembly binary format is quite amenable to gzip
compression, often getting over 50% reductions in size.</p>
<p>Furthermore, WebAssembly's binary format is optimized for very fast parsing and
processing. Browsers nowadays have &quot;baseline compilers&quot; which parses WebAssembly
and emits compiled code as fast as wasm can come in over the network. This means
that <a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">if you're using <code>instantiateStreaming</code></a> the second the Web request
is done the WebAssembly module is probably ready to go. JavaScript, on the other
hand, can often take longer to not only parse but also get up to speed with JIT
compilation and such.</p>
<p>And finally, remember that WebAssembly is also far more optimized than
JavaScript for execution speed. You'll want to be sure to measure for runtime
comparisons between JavaScript and WebAssembly to factor that in to how
important code size is.</p>
<p>All this to say basically don't dismay immediately if your <code>.wasm</code> file is
larger than expected! Code size may end up only being one of many factors in the
end-to-end story. Comparisons between JavaScript and WebAssembly that only look
at code size are missing the forest for the trees.</p>
<h2 id="optimizing-builds-for-code-size"><a class="header" href="#optimizing-builds-for-code-size">Optimizing Builds for Code Size</a></h2>
<p>There are a bunch of configuration options we can use to get <code>rustc</code> to make
smaller <code>.wasm</code> binaries. In some cases, we are trading longer compile times for
smaller <code>.wasm</code> sizes. In other cases, we are trading runtime speed of the
WebAssembly for smaller code size. We should be cognizant of the trade offs of
each option, and in the cases where we trade runtime speed for code size,
profile and measure to make an informed decision about whether the trade is
worth it.</p>
<h3 id="compiling-with-link-time-optimizations-lto"><a class="header" href="#compiling-with-link-time-optimizations-lto">Compiling with Link Time Optimizations (LTO)</a></h3>
<p>In <code>Cargo.toml</code>, add <code>lto = true</code> in the <code>[profile.release]</code> section:</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<p>This gives LLVM many more opportunities to inline and prune functions. Not only
will it make the <code>.wasm</code> smaller, but it will also make it faster at runtime!
The downside is that compilation will take longer.</p>
<h3 id="tell-llvm-to-optimize-for-size-instead-of-speed"><a class="header" href="#tell-llvm-to-optimize-for-size-instead-of-speed">Tell LLVM to Optimize for Size Instead of Speed</a></h3>
<p>LLVM's optimization passes are tuned to improve speed, not size, by default. We
can change the goal to code size by modifying the <code>[profile.release]</code> section in
<code>Cargo.toml</code> to this:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>Or, to even more aggressively optimize for size, at further potential speed
costs:</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<p>Note that, surprisingly enough, <code>opt-level = &quot;s&quot;</code> can sometimes result in
smaller binaries than <code>opt-level = &quot;z&quot;</code>. Always measure!</p>
<h3 id="use-the-wasm-opt-tool"><a class="header" href="#use-the-wasm-opt-tool">Use the <code>wasm-opt</code> Tool</a></h3>
<p>The <a href="https://github.com/WebAssembly/binaryen">Binaryen</a> toolkit is a collection of WebAssembly-specific compiler
tools. It goes much further than LLVM's WebAssembly backend does, and using its
<code>wasm-opt</code> tool to post-process a <code>.wasm</code> binary generated by LLVM can often get
another 15-20% savings on code size. It will often produce runtime speed ups at
the same time!</p>
<pre><code class="language-bash"># Optimize for size.
wasm-opt -Os -o output.wasm input.wasm

# Optimize aggressively for size.
wasm-opt -Oz -o output.wasm input.wasm

# Optimize for speed.
wasm-opt -O -o output.wasm input.wasm

# Optimize aggressively for speed.
wasm-opt -O3 -o output.wasm input.wasm
</code></pre>
<h3 id="notes-about-debug-information"><a class="header" href="#notes-about-debug-information">Notes about Debug Information</a></h3>
<p>One of the biggest contributors to wasm binary size can be debug information and
the <code>names</code> section of the wasm binary. The <code>wasm-pack</code> tool, however, removes
debuginfo by default. Additionally <code>wasm-opt</code> removes the <code>names</code> section by
default unless <code>-g</code> is also specified.</p>
<p>This means that if you follow the above steps you should by default not have
either debuginfo or the names section in the wasm binary. If, however, you are
manually otherwise preserving this debug information in the wasm binary be sure
to be mindful of this!</p>
<h2 id="size-profiling"><a class="header" href="#size-profiling">Size Profiling</a></h2>
<p>If tweaking build configurations to optimize for code size isn't resulting in a
small enough <code>.wasm</code> binary, it is time to do some profiling to see where the
remaining code size is coming from.</p>
<blockquote>
<p>⚡ Just like how we let time profiling guide our speed up efforts, we want to
let size profiling guide our code size shrinking efforts. Fail to do this and
you risk wasting your own time!</p>
</blockquote>
<h3 id="the-twiggy-code-size-profiler"><a class="header" href="#the-twiggy-code-size-profiler">The <code>twiggy</code> Code Size Profiler</a></h3>
<p><a href="https://github.com/rustwasm/twiggy"><code>twiggy</code> is a code size profiler</a> that supports WebAssembly as
input. It analyzes a binary's call graph to answer questions like:</p>
<ul>
<li>
<p>Why was this function included in the binary in the first place?</p>
</li>
<li>
<p>What is the <em>retained size</em> of this function? I.e. how much space would be
saved if I removed it and all the functions that become dead code after its
removal?</p>
</li>
</ul>
<style>
/* For whatever reason, the default mdbook fonts fonts break with the
   following box-drawing characters, hence the manual style. */
pre, code {
  font-family: "SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;
}
</style>
<pre><code class="language-text">$ twiggy top -n 20 pkg/wasm_game_of_life_bg.wasm
 Shallow Bytes │ Shallow % │ Item
───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────
          9158 ┊    19.65% ┊ &quot;function names&quot; subsection
          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8
          2510 ┊     5.39% ┊ &lt;str as core::fmt::Debug&gt;::fmt::he0d87479d1c208ea
          1737 ┊     3.73% ┊ data[0]
          1574 ┊     3.38% ┊ data[3]
          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5
          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d
          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced
          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b
          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605
           931 ┊     2.00% ┊ data[4]
           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05
           841 ┊     1.80% ┊ &lt;char as core::fmt::Debug&gt;::fmt::h07742d9f4a8c56f2
           813 ┊     1.74% ┊ __rust_realloc
           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85
           678 ┊     1.45% ┊ &lt;core::fmt::builders::PadAdapter&lt;'a&gt; as core::fmt::Write&gt;::write_str::h96b72fb7457d3062
           631 ┊     1.35% ┊ universe_tick
           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8
           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5
           503 ┊     1.08% ┊ &lt;&amp;'a T as core::fmt::Debug&gt;::fmt::hba207e4f7abaece6
</code></pre>
<h3 id="manually-inspecting-llvm-ir"><a class="header" href="#manually-inspecting-llvm-ir">Manually Inspecting LLVM-IR</a></h3>
<p>LLVM-IR is the final intermediate representation in the compiler toolchain
before LLVM generates WebAssembly. Therefore, it is very similar to the
WebAssembly that is ultimately emitted. More LLVM-IR generally means more
<code>.wasm</code> size, and if a function takes up 25% of the LLVM-IR, then it generally
will take up 25% of the <code>.wasm</code>. While these numbers only hold in general, the
LLVM-IR has crucial information that is not present in the <code>.wasm</code> (because of
WebAssembly's lack of a debugging format like DWARF): which subroutines were
inlined into a given function.</p>
<p>You can generate LLVM-IR with this <code>cargo</code> command:</p>
<pre><code>cargo rustc --release -- --emit llvm-ir
</code></pre>
<p>Then, you can use <code>find</code> to locate the <code>.ll</code> file containing the LLVM-IR in
<code>cargo</code>'s <code>target</code> directory:</p>
<pre><code>find target/release -type f -name '*.ll'
</code></pre>
<h4 id="references-2"><a class="header" href="#references-2">References</a></h4>
<ul>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM Language Reference Manual</a></li>
</ul>
<h2 id="more-invasive-tools-and-techniques"><a class="header" href="#more-invasive-tools-and-techniques">More Invasive Tools and Techniques</a></h2>
<p>Tweaking build configurations to get smaller <code>.wasm</code> binaries is pretty hands
off. When you need to go the extra mile, however, you are prepared to use more
invasive techniques, like rewriting source code to avoid bloat. What follows is
a collection of get-your-hands-dirty techniques you can apply to get smaller
code sizes.</p>
<h3 id="avoid-string-formatting"><a class="header" href="#avoid-string-formatting">Avoid String Formatting</a></h3>
<p><code>format!</code>, <code>to_string</code>, etc... can bring in a lot of code bloat. If possible,
only do string formatting in debug mode, and in release mode use static strings.</p>
<h3 id="avoid-panicking"><a class="header" href="#avoid-panicking">Avoid Panicking</a></h3>
<p>This is definitely easier said than done, but tools like <code>twiggy</code> and manually
inspecting LLVM-IR can help you figure out which functions are panicking.</p>
<p>Panics do not always appear as a <code>panic!()</code> macro invocation. They arise
implicitly from many constructs, such as:</p>
<ul>
<li>
<p>Indexing a slice panics on out of bounds indices: <code>my_slice[i]</code></p>
</li>
<li>
<p>Division will panic if the divisor is zero: <code>dividend / divisor</code></p>
</li>
<li>
<p>Unwrapping an <code>Option</code> or <code>Result</code>: <code>opt.unwrap()</code> or <code>res.unwrap()</code></p>
</li>
</ul>
<p>The first two can be translated into the third. Indexing can be replaced with
fallible <code>my_slice.get(i)</code> operations. Division can be replaced with
<code>checked_div</code> calls. Now we only have a single case to contend with.</p>
<p>Unwrapping an <code>Option</code> or <code>Result</code> without panicking comes in two flavors: safe
and unsafe.</p>
<p>The safe approach is to <code>abort</code> instead of panicking when encountering a <code>None</code>
or an <code>Error</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub fn unwrap_abort&lt;T&gt;(o: Option&lt;T&gt;) -&gt; T {
    use std::process;
    match o {
        Some(t) =&gt; t,
        None =&gt; process::abort(),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Ultimately, panics translate into aborts in <code>wasm32-unknown-unknown</code> anyways, so
this gives you the same behavior but without the code bloat.</p>
<p>Alternatively, the <a href="https://crates.io/crates/unreachable"><code>unreachable</code> crate</a> provides an unsafe
<a href="https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap"><code>unchecked_unwrap</code> extension method</a> for <code>Option</code> and
<code>Result</code> which tells the Rust compiler to <em>assume</em> that the <code>Option</code> is <code>Some</code>
or the <code>Result</code> is <code>Ok</code>. It is undefined behavior what happens if that
assumption does not hold. You really only want to use this unsafe approach when
you 110% <em>know</em> that the assumption holds, and the compiler just isn't smart
enough to see it. Even if you go down this route, you should have a debug build
configuration that still does the checking, and only use unchecked operations in
release builds.</p>
<h3 id="avoid-allocation-or-switch-to-wee_alloc"><a class="header" href="#avoid-allocation-or-switch-to-wee_alloc">Avoid Allocation or Switch to <code>wee_alloc</code></a></h3>
<p>Rust's default allocator for WebAssembly is a port of <code>dlmalloc</code> to Rust. It
weighs in somewhere around ten kilobytes. If you can completely avoid dynamic
allocation, then you should be able to shed those ten kilobytes.</p>
<p>Completely avoiding dynamic allocation can be very difficult. But removing
allocation from hot code paths is usually much easier (and usually helps make
those hot code paths faster, as well). In these cases, <a href="https://github.com/rustwasm/wee_alloc">replacing the default
global allocator with <code>wee_alloc</code></a> should save you most (but not
quite all) of those ten kilobytes. <code>wee_alloc</code> is an allocator designed for
situations where you need <em>some</em> kind of allocator, but do not need a
particularly fast allocator, and will happily trade allocation speed for smaller
code size.</p>
<h3 id="use-trait-objects-instead-of-generic-type-parameters"><a class="header" href="#use-trait-objects-instead-of-generic-type-parameters">Use Trait Objects Instead of Generic Type Parameters</a></h3>
<p>When you create generic functions that use type parameters, like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whatever&lt;T: MyTrait&gt;(t: T) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>Then <code>rustc</code> and LLVM will create a new copy of the function for each <code>T</code> type
that the function is used with. This presents many opportunities for compiler
optimizations based on which particular <code>T</code> each copy is working with, but these
copies add up quickly in terms of code size.</p>
<p>If you use trait objects instead of type parameters, like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whatever(t: Box&lt;MyTrait&gt;) { ... }
// or
fn whatever(t: &amp;MyTrait) { ... }
// etc...
<span class="boring">}
</span></code></pre></pre>
<p>Then dynamic dispatch via virtual calls is used, and only a single version of
the function is emitted in the <code>.wasm</code>. The downside is the loss of the compiler
optimization opportunities and the added cost of indirect, dynamically
dispatched function calls.</p>
<h3 id="use-the-wasm-snip-tool"><a class="header" href="#use-the-wasm-snip-tool">Use the <code>wasm-snip</code> Tool</a></h3>
<p><a href="https://github.com/fitzgen/wasm-snip"><code>wasm-snip</code> replaces a WebAssembly function's body with an <code>unreachable</code>
instruction.</a> This is a rather heavy, blunt hammer for functions that kind
of look like nails if you squint hard enough.</p>
<p>Maybe you know that some function will never be called at runtime, but the
compiler can't prove that at compile time? Snip it! Afterwards, run <code>wasm-opt</code>
again with the <code>--dce</code> flag, and all the functions that the snipped function
transitively called (which could also never be called at runtime) will get
removed too.</p>
<p>This tool is particularly useful for removing the panicking infrastructure,
since panics ultimately translate into traps anyways.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-interoperation"><a class="header" href="#javascript-interoperation">JavaScript Interoperation</a></h1>
<h2 id="importing-and-exporting-js-functions"><a class="header" href="#importing-and-exporting-js-functions">Importing and Exporting JS Functions</a></h2>
<h3 id="from-the-rust-side"><a class="header" href="#from-the-rust-side">From the Rust Side</a></h3>
<p>When using wasm within a JS host, importing and exporting functions from the
Rust side is straightforward: it works very similarly to C.</p>
<p>WebAssembly modules declare a sequence of imports, each with a <em>module name</em>
and an <em>import name</em>. The module name for an <code>extern { ... }</code> block can be
specified using <a href="https://github.com/rust-lang/rust/issues/52090"><code>#[link(wasm_import_module)]</code></a>, currently
it defaults to &quot;env&quot;.</p>
<p>Exports have only a single name. In addition to any <code>extern</code> functions the
WebAssembly instance's default linear memory is exported as &quot;memory&quot;.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// import a JS function called `foo` from the module `mod`
#[link(wasm_import_module = &quot;mod&quot;)]
extern { fn foo(); }

// export a Rust function called `bar`
#[no_mangle]
pub extern fn bar() { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>Because of wasm's limited value types, these functions must operate only on
primitive numeric types.</p>
<h3 id="from-the-js-side"><a class="header" href="#from-the-js-side">From the JS Side</a></h3>
<p>Within JS, a wasm binary turns into an ES6 module. It must be <em>instantiated</em>
with linear memory and have a set of JS functions matching the expected
imports.  The details of instantiation are available on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">MDN</a>.</p>
<p>The resulting ES6 module will contain all of the functions exported from Rust, now
available as JS functions.</p>
<p><a href="https://www.hellorust.com/demos/add/index.html">Here</a> is a very simple example of the whole setup in action.</p>
<h2 id="going-beyond-numerics"><a class="header" href="#going-beyond-numerics">Going Beyond Numerics</a></h2>
<p>When using wasm within JS, there is a sharp split between the wasm module's
memory and the JS memory:</p>
<ul>
<li>
<p>Each wasm module has a linear memory (described at the top of this document),
which is initialized during instantiation. <strong>JS code can freely read and write
to this memory</strong>.</p>
</li>
<li>
<p>By contrast, wasm code has no <em>direct</em> access to JS objects.</p>
</li>
</ul>
<p>Thus, sophisticated interop happens in two main ways:</p>
<ul>
<li>
<p>Copying in or out binary data to the wasm memory. For example, this is one way
to provide an owned <code>String</code> to the Rust side.</p>
</li>
<li>
<p>Setting up an explicit &quot;heap&quot; of JS objects which are then given
&quot;addresses&quot;. This allows wasm code to refer to JS objects indirectly (using
integers), and operate on those objects by invoking imported JS functions.</p>
</li>
</ul>
<p>Fortunately, this interop story is very amenable to treatment through a generic
&quot;bindgen&quot;-style framework: <a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a>. The framework makes it possible to
write idiomatic Rust function signatures that map to idiomatic JS functions,
automatically.</p>
<h2 id="custom-sections"><a class="header" href="#custom-sections">Custom Sections</a></h2>
<p>Custom sections allow embedding named arbitrary data into a wasm module. The
section data is set at compile time and is read directly from the wasm module,
it cannot be modified at runtime.</p>
<p>In Rust, custom sections are static arrays (<code>[T; size]</code>) exposed with the
<code>#[link_section]</code> attribute:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link_section = &quot;hello&quot;]
pub static SECTION: [u8; 24] = *b&quot;This is a custom section&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>This adds a custom section named <code>hello</code> to the wasm file, the rust variable
name <code>SECTION</code> is arbitrary, changing it wouldn't alter the behaviour. The
contents are bytes of text here but could be any arbitrary data.</p>
<p>The custom sections can be read on the JS side using the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections"><code>WebAssembly.Module.customSections</code></a> function, it takes a wasm Module and the
section name as arguments and returns an Array of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>s. Multiple
sections may be specified using the same name, in which case they will all
appear in this array.</p>
<pre><code class="language-js">WebAssembly.compileStreaming(fetch(&quot;sections.wasm&quot;))
.then(mod =&gt; {
  const sections = WebAssembly.Module.customSections(mod, &quot;hello&quot;);

  const decoder = new TextDecoder();
  const text = decoder.decode(sections[0]);

  console.log(text); // -&gt; &quot;This is a custom section&quot;
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="which-crates-will-work-off-the-shelf-with-webassembly"><a class="header" href="#which-crates-will-work-off-the-shelf-with-webassembly">Which Crates Will Work Off-the-Shelf with WebAssembly?</a></h1>
<p>It is easiest to list the things that do <em>not</em> currently work with WebAssembly;
crates which avoid these things tend to be portable to WebAssembly and usually
<em>Just Work</em>. A good rule of thumb is that if a crate supports embedded and
<code>#![no_std]</code> usage, it probably also supports WebAssembly.</p>
<h2 id="things-a-crate-might-do-that-wont-work-with-webassembly"><a class="header" href="#things-a-crate-might-do-that-wont-work-with-webassembly">Things a Crate Might do that Won't Work with WebAssembly</a></h2>
<h3 id="c-and-system-library-dependencies"><a class="header" href="#c-and-system-library-dependencies">C and System Library Dependencies</a></h3>
<p>There are no system libraries in wasm, so any crate that tries to bind to a
system library won't work.</p>
<p>Using C libraries will also probably fail to work, since wasm doesn't have a
stable ABI for cross-language communication, and cross-language linking for wasm
is very finicky. Everyone wants this to work eventually, especially since
<code>clang</code> is shipping their <code>wasm32</code> target by default now, but the story isn't
quite there yet.</p>
<h3 id="file-io"><a class="header" href="#file-io">File I/O</a></h3>
<p>WebAssembly does not have access to a file system, so crates that assume the
existence of a file system — and don't have wasm-specific workarounds
— will not work.</p>
<h3 id="spawning-threads"><a class="header" href="#spawning-threads">Spawning Threads</a></h3>
<p>There are <a href="https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html">plans to add threading to WebAssembly</a>, but it isn't
shipping yet. Attempts to spawn on a thread on the <code>wasm32-unknown-unknown</code>
target will panic, which triggers a wasm trap.</p>
<h2 id="so-which-general-purpose-crates-tend-to-work-off-the-shelf-with-webassembly"><a class="header" href="#so-which-general-purpose-crates-tend-to-work-off-the-shelf-with-webassembly">So Which General Purpose Crates Tend to Work Off-the-Shelf with WebAssembly?</a></h2>
<h3 id="algorithms-and-data-structures"><a class="header" href="#algorithms-and-data-structures">Algorithms and Data Structures</a></h3>
<p>Crates that provide the implementation of a particular
<a href="https://crates.io/categories/algorithms">algorithm</a> or <a href="https://crates.io/categories/data-structures">data
structure</a>, for example A* graph
search or splay trees, tend to work well with WebAssembly.</p>
<h3 id="no_std"><a class="header" href="#no_std"><code>#![no_std]</code></a></h3>
<p><a href="https://crates.io/categories/no-std">Crates that do not rely on the standard
library</a> tend to work well with
WebAssembly.</p>
<h3 id="parsers"><a class="header" href="#parsers">Parsers</a></h3>
<p><a href="https://crates.io/categories/parser-implementations">Parsers</a> — so long
as they just take input and don't perform their own I/O — tend to work
well with WebAssembly.</p>
<h3 id="text-processing"><a class="header" href="#text-processing">Text Processing</a></h3>
<p><a href="https://crates.io/categories/text-processing">Crates that deal with the complexities of human language when expressed in
textual form</a> tend to work well
with WebAssembly.</p>
<h3 id="rust-patterns"><a class="header" href="#rust-patterns">Rust Patterns</a></h3>
<p><a href="https://crates.io/categories/rust-patterns">Shared solutions for particular situations specific to programming in
Rust</a> tend to work well with WebAssembly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-to-add-webassembly-support-to-a-general-purpose-crate"><a class="header" href="#how-to-add-webassembly-support-to-a-general-purpose-crate">How to Add WebAssembly Support to a General-Purpose Crate</a></h1>
<p>This section is for general-purpose crate authors who want to support
WebAssembly.</p>
<h2 id="maybe-your-crate-already-supports-webassembly"><a class="header" href="#maybe-your-crate-already-supports-webassembly">Maybe Your Crate Already Supports WebAssembly!</a></h2>
<p>Review the information about <a href="reference/./which-crates-work-with-wasm.html">what kinds of things can make a general-purpose
crate <em>not</em> portable for WebAssembly</a>. If
your crate doesn't have any of those things, it likely already supports
WebAssembly!</p>
<p>You can always check by running <code>cargo build</code> for the WebAssembly target:</p>
<pre><code>cargo build --target wasm32-unknown-unknown
</code></pre>
<p>If that command fails, then your crate doesn't support WebAssembly right now. If
it doesn't fail, then your crate <em>might</em> support WebAssembly. You can be 100%
sure that it does (and continues to do so!) by <a href="reference/add-wasm-support-to-crate.html#maintaining-ongoing-support-for-webassembly">adding tests for wasm and
running those tests in CI.</a></p>
<h2 id="adding-support-for-webassembly"><a class="header" href="#adding-support-for-webassembly">Adding Support for WebAssembly</a></h2>
<h3 id="avoid-performing-io-directly"><a class="header" href="#avoid-performing-io-directly">Avoid Performing I/O Directly</a></h3>
<p>On the Web, I/O is always asynchronous, and there isn't a file system. Factor
I/O out of your library, let users perform the I/O and then pass the input
slices to your library instead.</p>
<p>For example, refactor this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::path::Path;

pub fn parse_thing(path: &amp;Path) -&gt; Result&lt;MyThing, MyError&gt; {
    let contents = fs::read(path)?;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Into this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse_thing(contents: &amp;[u8]) -&gt; Result&lt;MyThing, MyError&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="add-wasm-bindgen-as-a-dependency"><a class="header" href="#add-wasm-bindgen-as-a-dependency">Add <code>wasm-bindgen</code> as a Dependency</a></h3>
<p>If you need to interact with the outside world (i.e. you can't have library
consumers drive that interaction for you) then you'll need to add <code>wasm-bindgen</code>
(and <code>js-sys</code> and <code>web-sys</code> if you need them) as a dependency for when
compilation is targeting WebAssembly:</p>
<pre><code class="language-toml">[target.'cfg(target_arch = &quot;wasm32&quot;)'.dependencies]
wasm-bindgen = &quot;0.2&quot;
js-sys = &quot;0.3&quot;
web-sys = &quot;0.3&quot;
</code></pre>
<h3 id="avoid-synchronous-io"><a class="header" href="#avoid-synchronous-io">Avoid Synchronous I/O</a></h3>
<p>If you must perform I/O in your library, then it cannot be synchronous. There is
only asynchronous I/O on the Web. Use <a href="https://crates.io/crates/futures">the <code>futures</code>
crate</a> and <a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/">the <code>wasm-bindgen-futures</code>
crate</a> to
manage asynchronous I/O. If your library functions are generic over some
future type <code>F</code>, then that future can be implemented via <code>fetch</code> on the Web or
via non-blocking I/O provided by the operating system.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_stuff&lt;F&gt;(future: F) -&gt; impl Future&lt;Item = MyOtherThing&gt;
where
    F: Future&lt;Item = MyThing&gt;,
{
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>You can also define a trait and implement it for WebAssembly and the Web and
also for native targets:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ReadMyThing {
    type F: Future&lt;Item = MyThing&gt;;
    fn read(&amp;self) -&gt; Self::F;
}

#[cfg(target_arch = &quot;wasm32&quot;)]
struct WebReadMyThing {
    // ...
}

#[cfg(target_arch = &quot;wasm32&quot;)]
impl ReadMyThing for WebReadMyThing {
    // ...
}

#[cfg(not(target_arch = &quot;wasm32&quot;))]
struct NativeReadMyThing {
    // ...
}

#[cfg(not(target_arch = &quot;wasm32&quot;))]
impl ReadMyThing for NativeReadMyThing {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="avoid-spawning-threads"><a class="header" href="#avoid-spawning-threads">Avoid Spawning Threads</a></h3>
<p>Wasm doesn't support threads yet (but <a href="https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html">experimental work is
ongoing</a>),
so attempts to spawn threads in wasm will panic.</p>
<p>You can use <code>#[cfg(..)]</code>s to enable threaded and non-threaded code paths
depending on if the target is WebAssembly or not:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg(target_arch = &quot;wasm32&quot;)]
<span class="boring">fn main() {
</span>fn do_work() {
    // Do work with only this thread...
}

#![cfg(not(target_arch = &quot;wasm32&quot;))]
fn do_work() {
    use std::thread;

    // Spread work to helper threads....
    thread::spawn(|| {
        // ...
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>Another option is to factor out thread spawning from your library and allow
users to &quot;bring their own threads&quot; similar to factoring out file I/O and
allowing users to bring their own I/O. This has the side effect of playing nice
with applications that want to own their own custom thread pool.</p>
<h2 id="maintaining-ongoing-support-for-webassembly"><a class="header" href="#maintaining-ongoing-support-for-webassembly">Maintaining Ongoing Support for WebAssembly</a></h2>
<h3 id="building-for-wasm32-unknown-unknown-in-ci"><a class="header" href="#building-for-wasm32-unknown-unknown-in-ci">Building for <code>wasm32-unknown-unknown</code> in CI</a></h3>
<p>Ensure that compilation doesn't fail when targeting WebAssembly by having your
CI script run these commands:</p>
<pre><code>rustup target add wasm32-unknown-unknown
cargo check --target wasm32-unknown-unknown
</code></pre>
<p>For example, you can add this to your <code>.travis.yml</code> configuration for Travis CI:</p>
<pre><code class="language-yaml">
matrix:
  include:
    - language: rust
      rust: stable
      name: &quot;check wasm32 support&quot;
      install: rustup target add wasm32-unknown-unknown
      script: cargo check --target wasm32-unknown-unknown
</code></pre>
<h3 id="testing-in-nodejs-and-headless-browsers"><a class="header" href="#testing-in-nodejs-and-headless-browsers">Testing in Node.js and Headless Browsers</a></h3>
<p>You can use <code>wasm-bindgen-test</code> and the <code>wasm-pack test</code> subcommand to run wasm
tests in either Node.js or a headless browser. You can even integrate these
tests into your CI.</p>
<p><a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html">Learn more about testing wasm
here.</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-rust-and-webassembly-to-production"><a class="header" href="#deploying-rust-and-webassembly-to-production">Deploying Rust and WebAssembly to Production</a></h1>
<blockquote>
<p><strong>⚡ Deploying Web applications built with Rust and WebAssembly is nearly
identical to deploying any other Web application!</strong></p>
</blockquote>
<p>To deploy a Web application that uses Rust-generated WebAssembly on the client,
copy the built Web application's files to your production server's file system
and configure your HTTP server to make them accessible.</p>
<h2 id="ensure-that-your-http-server-uses-the-applicationwasm-mime-type"><a class="header" href="#ensure-that-your-http-server-uses-the-applicationwasm-mime-type">Ensure that Your HTTP Server Uses the <code>application/wasm</code> MIME Type</a></h2>
<p>For the fastest page loads, you'll want to use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">the
<code>WebAssembly.instantiateStreaming</code> function</a> to pipeline
wasm compilation and instantiation with network transfer (or make sure your
bundler is able to use that function). However, <code>instantiateStreaming</code> requires
that the HTTP response has the <code>application/wasm</code> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a> set, or else it
will throw an error.</p>
<ul>
<li><a href="https://httpd.apache.org/docs/2.4/mod/mod_mime.html#addtype">How to configure MIME types for the Apache HTTP server</a></li>
<li><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#types">How to configure MIME types for the NGINX HTTP server</a></li>
</ul>
<h2 id="more-resources"><a class="header" href="#more-resources">More Resources</a></h2>
<ul>
<li><a href="https://webpack.js.org/guides/production/">Best Practices for Webpack in Production.</a> Many Rust and
WebAssembly projects use Webpack to bundle their Rust-generated WebAssembly,
JavaScript, CSS, and HTML. This guide has tips for getting the most out of
Webpack when deploying to production environments.</li>
<li><a href="https://httpd.apache.org/docs/">Apache documentation.</a> Apache is a popular HTTP server for use in
production.</li>
<li><a href="https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/">NGINX documentation.</a> NGINX is a popular HTTP server for use in
production.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
