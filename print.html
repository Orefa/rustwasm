<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust and WebAssembly</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> 简介</a></li><li class="chapter-item expanded "><a href="why-rust-and-webassembly.html"><strong aria-hidden="true">2.</strong> 为什么是Rust和WebAssembly?</a></li><li class="chapter-item expanded "><a href="background-and-concepts.html"><strong aria-hidden="true">3.</strong> 背景和概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="what-is-webassembly.html"><strong aria-hidden="true">3.1.</strong> 什么是WebAssembly?</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="game-of-life/introduction.html"><strong aria-hidden="true">4.</strong> 教程 </a></li><li><ol class="section"><li class="chapter-item expanded "><a href="game-of-life/setup.html"><strong aria-hidden="true">4.1.</strong> 设置</a></li><li class="chapter-item expanded "><a href="game-of-life/hello-world.html"><strong aria-hidden="true">4.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="game-of-life/rules.html"><strong aria-hidden="true">4.3.</strong> 规则</a></li><li class="chapter-item expanded "><a href="game-of-life/implementing.html"><strong aria-hidden="true">4.4.</strong> 实现康威的生命游戏</a></li><li class="chapter-item expanded "><a href="game-of-life/testing.html"><strong aria-hidden="true">4.5.</strong> 测试康威的生命游戏</a></li><li class="chapter-item expanded "><a href="game-of-life/debugging.html"><strong aria-hidden="true">4.6.</strong> 调试</a></li><li class="chapter-item expanded "><a href="game-of-life/interactivity.html"><strong aria-hidden="true">4.7.</strong> 添加交互性</a></li><li class="chapter-item expanded "><a href="game-of-life/time-profiling.html"><strong aria-hidden="true">4.8.</strong> 时间分析</a></li><li class="chapter-item expanded "><a href="game-of-life/code-size.html"><strong aria-hidden="true">4.9.</strong> 缩小.wasm 大小</a></li><li class="chapter-item expanded "><a href="game-of-life/publishing-to-npm.html"><strong aria-hidden="true">4.10.</strong> 发布到 npm</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="reference/index.html"><strong aria-hidden="true">5.</strong> 参考</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/crates.html"><strong aria-hidden="true">5.1.</strong> 你应该知道的Crates</a></li><li class="chapter-item expanded "><a href="reference/tools.html"><strong aria-hidden="true">5.2.</strong> 你应该知道的工具</a></li><li class="chapter-item expanded "><a href="reference/project-templates.html"><strong aria-hidden="true">5.3.</strong> 项目模板</a></li><li class="chapter-item expanded "><a href="reference/debugging.html"><strong aria-hidden="true">5.4.</strong> 调试</a></li><li class="chapter-item expanded "><a href="reference/time-profiling.html"><strong aria-hidden="true">5.5.</strong> 时间分析</a></li><li class="chapter-item expanded "><a href="reference/code-size.html"><strong aria-hidden="true">5.6.</strong> 缩小.wasm 大小</a></li><li class="chapter-item expanded "><a href="reference/js-ffi.html"><strong aria-hidden="true">5.7.</strong> JavaScript 互操作</a></li><li class="chapter-item expanded "><a href="reference/which-crates-work-with-wasm.html"><strong aria-hidden="true">5.8.</strong> 哪些板块能与WebAssembly一起使用现成的产品?</a></li><li class="chapter-item expanded "><a href="reference/add-wasm-support-to-crate.html"><strong aria-hidden="true">5.9.</strong> 如何为通用Crate添加 WebAssembly 支持</a></li><li class="chapter-item expanded "><a href="reference/deploying-to-production.html"><strong aria-hidden="true">5.10.</strong> 将 Rust 和 WebAssembly 部署到生产环境</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust and WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust--and-webassembly-"><a class="header" href="#rust--and-webassembly-">Rust 🦀 and WebAssembly 🕸</a></h1>
<p>这本小书描述了如何将<a href="https://www.rust-lang.org">Rust</a>和<a href="https://webassembly.org/">WebAssembly</a>一起使用。</p>
<h2 id="这本书是为谁写的"><a class="header" href="#这本书是为谁写的">这本书是为谁写的?</a></h2>
<p>本书是为那些对将Rust编译成 WebAssembly 以实现快速、可靠的网络代码感兴趣的人编写的。汇编成WebAssembly，以便在网络上获得快速可靠的代码。你应该了解一些Rust，并熟悉 JavaScript，HTML，和 CSS。你不需要成为其中任何一个方面的专家。</p>
<p>还不了解Rust吗？ <a href="https://doc.rust-lang.org/book/">先从 <em>The Rust Programming Language</em> 开始</a></p>
<p>不懂JavaScript、HTML或CSS？<a href="https://developer.mozilla.org/en-US/docs/Learn">在MDN上了解他们的情况</a></p>
<h2 id="如何阅读此书"><a class="header" href="#如何阅读此书">如何阅读此书</a></h2>
<p>你应该先阅读<a href="./why-rust-and-webassembly.html">一起使用Rust和WebAssembly的动机</a>，以及熟悉<a href="./background-and-concepts.html">背景和概念</a>。</p>
<p><a href="./game-of-life/introduction.html">教程</a>是为了从头到尾阅读而写的。你应该跟随：自己编写、编译和运行教程中的代码。如果你以前没有一起使用过Rust和WebAssembly，那就从教程开始吧!</p>
<p><a href="./reference/index.html">参考章节</a> 可以按任何顺序进行阅读。</p>
<blockquote>
<p><strong>💡 Tip:</strong> 你可以通过点击页面上面的搜索 🔍 图标或按下 <code>s</code> 键 进行搜索</p>
</blockquote>
<h2 id="参与完善本书"><a class="header" href="#参与完善本书">参与完善本书</a></h2>
<p>这本书是开放源代码的! 发现一个错别字？我们是否忽略了什么？</p>
<ul>
<li>中文版本: <a href="https://github.com/Orefa/rustwasm"><strong>Send us a pull request!</strong></a></li>
<li>英文版本: <a href="https://github.com/rustwasm/book"><strong>Send us a pull request!</strong></a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="为什么是rust和webassembly"><a class="header" href="#为什么是rust和webassembly">为什么是Rust和WebAssembly?</a></h1>
<h2 id="低水平控制与高水平的人机工程学"><a class="header" href="#低水平控制与高水平的人机工程学">低水平控制与高水平的人机工程学</a></h2>
<p>JavaScript网络应用程序很难达到并保持可靠的性能。JavaScript的动态类型系统和垃圾收集的暂停并没有帮助。看似很小的代码改动，如果你不小心偏离了JIT的快乐路径，就会导致性能的急剧下降。你不小心偏离了JIT的快乐路径。</p>
<p>Rust 为程序员提供了低级控制和可靠的性能。 它没有困扰 JavaScript 的非确定性垃圾收集暂停。 程序员可以控制间接、单态化和内存布局。 </p>
<h2 id="小的-wasm-尺寸"><a class="header" href="#小的-wasm-尺寸">小的 <code>.wasm</code> 尺寸</a></h2>
<p>代码大小非常重要，因为 <code>.wasm</code> 必须通过网络下载。 Rust 缺少运行时，支持较小的 <code>.wasm</code> 大小，因为没有像垃圾收集器那样包含额外的膨胀。 您只需为实际使用的功能付费（按代码大小）。 </p>
<h2 id="不需要-重写一切"><a class="header" href="#不需要-重写一切"><em>不需要</em> 重写一切</a></h2>
<p>不需要丢弃现有的代码库。 您可以首先将您对性能最敏感的 JavaScript 函数移植到 Rust，以获得直接的好处。 如果您愿意，你甚至可以到此为止。 </p>
<h2 id="与其程序可以很好的结合"><a class="header" href="#与其程序可以很好的结合">与其程序可以很好的结合</a></h2>
<p>Rust 和 WebAssembly 与现有的 JavaScript 工具集成。它支持 ECMAScript 模块，你可以继续使用你已经喜欢的工具，如 npm 和 Webpack。</p>
<h2 id="您期待的便利设施"><a class="header" href="#您期待的便利设施">您期待的便利设施</a></h2>
<p>Rust 拥有开发人员所期望的现代设施，例如： </p>
<ul>
<li>
<p>强大的包管理  <code>cargo</code>,</p>
</li>
<li>
<p>富有表现力（和零成本）的抽象， </p>
</li>
<li>
<p>和一个热情的社区！ 😊</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="背景和概念"><a class="header" href="#背景和概念">背景和概念</a></h1>
<p>本节提供了进入 Rust 和 WebAssembly 的必要背景。开发的必要背景。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="什么是webassembly"><a class="header" href="#什么是webassembly">什么是WebAssembly?</a></h1>
<p>WebAssembly(wasm)是一种简单的机器模型和可执行格式，有一个<a href="https://webassembly.github.io/spec/">广泛的规范</a>。它被设计成可移植、紧凑，并以或接近原生速度执行。</p>
<p>作为一种编程语言，WebAssembly是由两种格式组成的。表示相同的结构，只是方式不同而已：</p>
<ol>
<li><code>.wat</code> 文本格式（称为<code>wat</code>，表示 &quot;<strong>W</strong>eb<strong>A</strong>ssembly <strong>T</strong>ext&quot;）使用 <a href="https://en.wikipedia.org/wiki/S-expression">S-expressions</a>，与 Lisp 系列语言有一些相似之处  像 Scheme 和 Clojure。</li>
<li><code>.wasm</code> 二进制格式是较低级的，目的是让 wasm 虚拟机直接使用。它在概念上类似于 ELF 和 Mach-O</li>
</ol>
<p>作为参考，这里有一个阶乘函数，在 <code>wat</code>:</p>
<pre><code>(module
  (func $fac (param f64) (result f64)
    local.get 0
    f64.const 1
    f64.lt
    if (result f64)
      f64.const 1
    else
      local.get 0
      local.get 0
      f64.const 1
      f64.sub
      call $fac
      f64.mul
    end)
  (export &quot;fac&quot; (func $fac)))
</code></pre>
<p>如果您对 <code>wasm</code> 文件的外观感到好奇，可以将 <a href="https://webassembly.github.io/wabt/demo/wat2wasm/">wat2wasm demo</a> 与上述代码一起使用。 </p>
<h2 id="线性内存"><a class="header" href="#线性内存">线性内存</a></h2>
<p>WebAssembly有一个非常简单的<a href="https://webassembly.github.io/spec/core/syntax/modules.html#syntax-mem">内存模型</a>。一个wasm模块可以访问一个单一的 &quot;线性内存&quot;，这基本上是一个字节的平面阵列。这个[内存可以按页面大小（64K）的倍数增长。它不能被缩小。</p>
<h2 id="webassembly-只是用于-web-吗"><a class="header" href="#webassembly-只是用于-web-吗">WebAssembly 只是用于 Web 吗？</a></h2>
<p>尽管它目前在 JavaScript 和 Web 社区中普遍受到关注，但 wasm 对其主机环境不做任何假设。因此，推测 wasm 将成为一种 &quot;可移植的可执行 &quot;格式，在未来被用于各种情况下是有意义的。然而，截至<em>今天</em>，wasm 主要与JavaScript（JS）有关，而 JavaScrip t有很多种类（包括 Web 和<a href="https://nodejs.org">Node.js</a>上的）。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="教程-康威生命游戏"><a class="header" href="#教程-康威生命游戏">教程: 康威生命游戏</a></h1>
<p>这是一个用 Rust 和 WebAssembly 实现<a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">康威生命游戏</a>的教程。</p>
<h2 id="这个教程是为谁准备的"><a class="header" href="#这个教程是为谁准备的">这个教程是为谁准备的？</a></h2>
<p>本教程适用于已经有基本 Rust 和 JavaScript 经验的人，并希望学习如何一起使用 Rust、WebAssembly 和 JavaScript。</p>
<p>你应该能够自如地阅读和编写基本的Rust、JavaScript 和 HTML。你绝对不需要是一个专家。</p>
<h2 id="我将学到什么"><a class="header" href="#我将学到什么">我将学到什么？</a></h2>
<ul>
<li>
<p>如何设置Rust工具链以编译成WebAssembly。</p>
</li>
<li>
<p>一个用于开发由Rust、WebAssembly、JavaScript、HTML和CSS组成的多语言程序的工作流程。</p>
</li>
<li>
<p>如何设计 API 以最大限度地利用 Rust 和 WebAssembly 的优势，同时也是 JavaScript 的优势。</p>
</li>
<li>
<p>如何调试由Rust编译的WebAssembly模块。</p>
</li>
<li>
<p>如何对Rust和WebAssembly程序进行时间剖析以使其更快。</p>
</li>
<li>
<p>如何确定 Rust 和 WebAssembly 程序的大小，使<code>.wasm</code>二进制文件更小，更快通过网络下载。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设置"><a class="header" href="#设置">设置</a></h1>
<p>本节描述了如何设置工具链，将 Rust 程序编译为 WebAssembly，并将其集成到 JavaScript 中。到 WebAssembly，并将其集成到 JavaScript 中。</p>
<h2 id="rust-工具链"><a class="header" href="#rust-工具链">Rust 工具链</a></h2>
<p>你将需要标准的 Rust 工具链，包括 <code>rustup</code>, <code>rustc</code>, 和 <code>cargo</code>.</p>
<p><a href="https://www.rust-lang.org/tools/install">按照这些说明来安装Rust工具链。</a></p>
<p>Rust 和 WebAssembly 的经验是乘着 Rust 发布的列车到了稳定期! 这意味着我们不需要任何实验性功能标志。然而，我们确实 需要 Rust 1.30 或更新版本。</p>
<h2 id="wasm-pack"><a class="header" href="#wasm-pack"><code>wasm-pack</code></a></h2>
<p><code>wasm-pack</code> 是您构建、测试和发布 Rust 生成的 WebAssembly 的一站式商店。 </p>
<p><a href="https://rustwasm.github.io/wasm-pack/installer/">Get <code>wasm-pack</code> here!</a></p>
<h2 id="cargo-generate"><a class="header" href="#cargo-generate"><code>cargo-generate</code></a></h2>
<p><a href="https://github.com/ashleygwilliams/cargo-generate"><code>cargo-generate</code> 通过利用预先存在的 git 存储库作为模板，帮助您快速启动并运行新的 Rust 项目。</a></p>
<p>使用如下命令安装 <code>cargo-generate</code>:</p>
<pre><code>cargo install cargo-generate
</code></pre>
<h2 id="npm"><a class="header" href="#npm"><code>npm</code></a></h2>
<p><code>npm</code> 是 JavaScript 的包管理器。 我们将使用它来安装和运行 JavaScript 打包器和开发服务器。 在教程结束时，我们将把我们编译的 <code>.wasm</code> 发布到 <code>npm</code> 仓库。 </p>
<p><a href="https://www.npmjs.com/get-npm">按照这些说明进行安装 <code>npm</code>.</a></p>
<p>如果您已经安装了 <code>npm</code>，请使用以下命令确保它是最新的： </p>
<pre><code>npm install npm@latest -g
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<p>本节将告诉你如何构建和运行你的第一个 Rust 和 WebAssembly 的程序：一个提醒 &quot;Hello, World!&quot; 的网页。</p>
<p>在开始之前，请确保你已经遵循了<a href="game-of-life/setup.html">设置说明</a>。</p>
<h2 id="克隆项目模板"><a class="header" href="#克隆项目模板">克隆项目模板</a></h2>
<p>该项目模板预先配置了合理的默认值，因此你可以快速构建、集成和打包你的代码用于 Web。</p>
<p>用这个命令克隆项目模板:</p>
<pre><code class="language-text">cargo generate --git https://github.com/rustwasm/wasm-pack-template
</code></pre>
<p>这将提示你新项目的名称。我们将使用 <strong>&quot;wasm-game-of-life&quot;</strong>.</p>
<pre><code class="language-text">wasm-game-of-life
</code></pre>
<h2 id="里面有什么"><a class="header" href="#里面有什么">里面有什么</a></h2>
<p>进入新的 <code>wasm-game-of-life</code> 项目</p>
<pre><code>cd wasm-game-of-life
</code></pre>
<p>并让我们看看它的内容。</p>
<pre><code class="language-text">wasm-game-of-life/
├── Cargo.toml
├── LICENSE_APACHE
├── LICENSE_MIT
├── README.md
└── src
    ├── lib.rs
    └── utils.rs
</code></pre>
<p>让我们详细看一下其中的几个文件。 </p>
<h3 id="wasm-game-of-lifecargotoml"><a class="header" href="#wasm-game-of-lifecargotoml"><code>wasm-game-of-life/Cargo.toml</code></a></h3>
<p><code>Cargo.toml</code> 文件为 <code>cargo</code>、Rust 的包管理器和构建工具指定依赖项和元数据。 这个预先配置了一个 <code>wasm-bindgen</code> 依赖项，一些我们稍后将深入研究的可选依赖项，以及正确初始化的 <code>crate-type</code> 以生成 <code>.wasm</code> 库。 </p>
<h3 id="wasm-game-of-lifesrclibrs"><a class="header" href="#wasm-game-of-lifesrclibrs"><code>wasm-game-of-life/src/lib.rs</code></a></h3>
<p><code>src/lib.rs</code> 文件是我们正在编译为 WebAssembly 的 Rust crate 的根目录。 它使用 <code>wasm-bindgen</code> 与 JavaScript 交互。 它导入了 <code>window.alert</code> JavaScript 函数，并导出了 <code>greet</code> Rust 函数，它会提醒一条问候消息。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod utils;

use wasm_bindgen::prelude::*;

// When the `wee_alloc` feature is enabled, use `wee_alloc` as the global
// allocator.
#[cfg(feature = &quot;wee_alloc&quot;)]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[wasm_bindgen]
extern {
    fn alert(s: &amp;str);
}

#[wasm_bindgen]
pub fn greet() {
    alert(&quot;Hello, wasm-game-of-life!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="wasm-game-of-lifesrcutilsrs"><a class="header" href="#wasm-game-of-lifesrcutilsrs"><code>wasm-game-of-life/src/utils.rs</code></a></h3>
<p><code>src/utils.rs</code> 模块提供了一些通用的工具来让 Rust 编译成 WebAssembly 变得更容易。 我们将在本教程后面更详细地了解其中一些实用程序，例如当我们查看 <a href="game-of-life/debugging.html">调试我们的 wasm 代码</a> 时，但我们现在可以忽略此文件。 </p>
<h2 id="构建项目"><a class="header" href="#构建项目">构建项目</a></h2>
<p>我们使用 <code>wasm-pack</code> 来编排以下构建步骤： </p>
<ul>
<li>确保我们有 Rust 1.30 或更新版本，并且通过 <code>rustup</code> 安装了 <code>wasm32-unknown-unknown</code> 目标，</li>
<li>通过 <code>cargo</code> 将我们的 Rust 源编译为 WebAssembly <code>.wasm</code> 二进制文件，</li>
<li>使用 <code>wasm-bindgen</code> 生成 JavaScript API，以便使用我们的 Rust 生成的 WebAssembly。 </li>
</ul>
<p>要做到这一切，在项目目录内运行这个命令。</p>
<pre><code>wasm-pack build
</code></pre>
<p>构建完成后，我们可以在 <code>pkg</code> 目录中找到它的工件，它应该有以下内容： </p>
<pre><code>pkg/
├── package.json
├── README.md
├── wasm_game_of_life_bg.wasm
├── wasm_game_of_life.d.ts
└── wasm_game_of_life.js
</code></pre>
<p><code>README.md</code> 文件是从主项目复制的，但其他文件是全新的。 </p>
<h3 id="wasm-game-of-lifepkgwasm_game_of_life_bgwasm"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_life_bgwasm"><code>wasm-game-of-life/pkg/wasm_game_of_life_bg.wasm</code></a></h3>
<p><code>.wasm</code> 文件是由 Rust 编译器从我们的 Rust 源代码生成的 WebAssembly 二进制文件。 它包含我们所有 Rust 函数和数据的编译到 wasm 版本。 例如，它有一个导出的“问候”功能。 </p>
<h3 id="wasm-game-of-lifepkgwasm_game_of_lifejs"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_lifejs"><code>wasm-game-of-life/pkg/wasm_game_of_life.js</code></a></h3>
<p><code>.js</code> 文件由 <code>wasm-bindgen</code> 生成，包含用于将 DOM 和 JavaScript 函数导入 Rust 并将 WebAssembly 函数的良好 API 暴露给 JavaScript 的 JavaScript 胶水。 例如，有一个 JavaScript 的 <code>greet</code> 函数包装了从 WebAssembly 模块导出的 <code>greet</code> 函数。 现在，这种粘合剂并没有做太多事情，但是当我们开始在 wasm 和 JavaScript 之间来回传递更多有趣的值时，它将帮助引导这些值跨越边界。 </p>
<pre><code class="language-js">import * as wasm from './wasm_game_of_life_bg';

// ...

export function greet() {
    return wasm.greet();
}
</code></pre>
<h3 id="wasm-game-of-lifepkgwasm_game_of_lifedts"><a class="header" href="#wasm-game-of-lifepkgwasm_game_of_lifedts"><code>wasm-game-of-life/pkg/wasm_game_of_life.d.ts</code></a></h3>
<p><code>.d.ts</code> 文件包含 JavaScript 胶水的 <a href="http://www.typescriptlang.org/">TypeScript</a> 类型声明。 如果您使用的是 TypeScript，您可以检查对 WebAssembly 函数的调用类型，并且您的 IDE 可以提供自动完成和建议！ 如果您不使用 TypeScript，则可以放心地忽略此文件。 </p>
<pre><code class="language-typescript">export function greet(): void;
</code></pre>
<h3 id="wasm-game-of-lifepkgpackagejson"><a class="header" href="#wasm-game-of-lifepkgpackagejson"><code>wasm-game-of-life/pkg/package.json</code></a></h3>
<p><a href="https://docs.npmjs.com/files/package.json"><code>package.json</code> 文件包含有关生成的 JavaScript 和 WebAssembly 包的元数据。</a> npm 和 JavaScript 捆绑器使用它来确定包之间的依赖关系、包名称、版本和一堆其他东西。 它帮助我们与 JavaScript 工具集成，并允许我们将我们的包发布到 npm。 </p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;wasm-game-of-life&quot;,
  &quot;collaborators&quot;: [
    &quot;Your Name &lt;your.email@example.com&gt;&quot;
  ],
  &quot;description&quot;: null,
  &quot;version&quot;: &quot;0.1.0&quot;,
  &quot;license&quot;: null,
  &quot;repository&quot;: null,
  &quot;files&quot;: [
    &quot;wasm_game_of_life_bg.wasm&quot;,
    &quot;wasm_game_of_life.d.ts&quot;
  ],
  &quot;main&quot;: &quot;wasm_game_of_life.js&quot;,
  &quot;types&quot;: &quot;wasm_game_of_life.d.ts&quot;
}
</code></pre>
<h2 id="将其放入网页"><a class="header" href="#将其放入网页">将其放入网页</a></h2>
<p>为了获取我们的 <code>wasm-game-of-life</code> 包并在网页中使用它，我们使用 <a href="https://github.com/rustwasm/create-wasm-app"><code>create-wasm-app</code> JavaScript 项目模板</a>。 </p>
<p>在 <code>wasm-game-of-life</code> 目录中运行此命令： </p>
<pre><code>npm init wasm-app www
</code></pre>
<p>这是我们新的 <code>wasm-game-of-life/www</code> 子目录包含的内容： </p>
<pre><code>wasm-game-of-life/www/
├── bootstrap.js
├── index.html
├── index.js
├── LICENSE-APACHE
├── LICENSE-MIT
├── package.json
├── README.md
└── webpack.config.js
</code></pre>
<p>再一次，让我们仔细看看其中的一些文件。 </p>
<h3 id="wasm-game-of-lifewwwpackagejson"><a class="header" href="#wasm-game-of-lifewwwpackagejson"><code>wasm-game-of-life/www/package.json</code></a></h3>
<p>这个 <code>package.json</code> 预先配置了 <code>webpack</code> 和 <code>webpack-dev-server</code> 依赖，以及对 <code>hello-wasm-pack</code> 的依赖，它是已发布到 npm 的 <code>wasm-pack-template</code> 包。 </p>
<h3 id="wasm-game-of-lifewwwwebpackconfigjs"><a class="header" href="#wasm-game-of-lifewwwwebpackconfigjs"><code>wasm-game-of-life/www/webpack.config.js</code></a></h3>
<p>此文件配置 webpack 及其本地开发服务器。 它是预先配置的，你根本不需要调整它来让 webpack 和它的本地开发服务器工作。 </p>
<h3 id="wasm-game-of-lifewwwindexhtml"><a class="header" href="#wasm-game-of-lifewwwindexhtml"><code>wasm-game-of-life/www/index.html</code></a></h3>
<p>这是网页的根 HTML 文件。 除了加载 <code>bootstrap.js </code>之外，它没有做太多事情，<code>bootstrap.js</code> 是一个非常薄的 <code>index.js</code> 包装器。 </p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello wasm-pack!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;./bootstrap.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h3 id="wasm-game-of-lifewwwindexjs"><a class="header" href="#wasm-game-of-lifewwwindexjs"><code>wasm-game-of-life/www/index.js</code></a></h3>
<p><code>index.js</code> 是我们网页的 JavaScript 的主要入口点。 它导入 <code>hello-wasm-pack</code> npm 包，其中包含默认的 <code>wasm-pack-template</code> 编译的 WebAssembly 和 JavaScript 胶水，然后调用 <code>hello-wasm-pack</code> 的 <code>greet</code> 函数。 </p>
<pre><code class="language-js">import * as wasm from &quot;hello-wasm-pack&quot;;

wasm.greet();
</code></pre>
<h3 id="安装依赖项"><a class="header" href="#安装依赖项">安装依赖项</a></h3>
<p>首先，通过在 <code>wasm-game-of-life/www</code> 子目录中运行 <code>npm install</code> 来确保本地开发服务器及其依赖项已安装： </p>
<pre><code class="language-text">npm install
</code></pre>
<p>这个命令只需要运行一次，就会安装<code>webpack</code> JavaScript bundler 和它的开发服务器。</p>
<blockquote>
<p>请注意，使用 Rust 和 WebAssembly 不需要 <code>webpack</code>，
这里它只是我们为了方便而选择的打包器和开发服务器
Parcel 和 Rollup 还应该支持将 WebAssembly 导入为 ECMAScript 模块
你也可以使用 Rust 和 WebAssembly <a href="https://rustwasm.github.io/docs/wasm-bindgen/examples/without-a-bundler.html">没有捆绑器</a> 如果你愿意！ </p>
</blockquote>
<h3 id="在-www-中使用我们本地的-wasm-game-of-life-包"><a class="header" href="#在-www-中使用我们本地的-wasm-game-of-life-包">在 <code>www</code> 中使用我们本地的 <code>wasm-game-of-life</code> 包</a></h3>
<p>我们不想使用 npm 中的 <code>hello-wasm-pack</code> 包，而是想使用我们本地的 <code>wasm-game-of-life</code> 包。 这将使我们能够逐步开发我们的生命游戏程序。</p>
<p>打开 <code>wasm-game-of-life/www/package.json</code> 并在 <code>&quot;devDependencies&quot;</code> 旁边添加 <code>&quot;dependencies&quot;</code> 字段，包括一个 <code>&quot;wasm-game-of-life&quot;: &quot;file :../pkg&quot;</code> 条目： </p>
<pre><code class="language-js">{
  // ...
  &quot;dependencies&quot;: {                     // Add this three lines block!
    &quot;wasm-game-of-life&quot;: &quot;file:../pkg&quot;
  },
  &quot;devDependencies&quot;: {
    //...
  }
}
</code></pre>
<p>接下来，修改 <code>wasm-game-of-life/www/index.js</code> 以导入 <code>wasm-game-of-life</code> 而不是 <code>hello-wasm-pack</code> 包： </p>
<pre><code class="language-js">import * as wasm from &quot;wasm-game-of-life&quot;;

wasm.greet();
</code></pre>
<p>由于我们声明了一个新的依赖项，我们需要安装它：</p>
<pre><code class="language-text">npm install
</code></pre>
<p>我们的网页现在可以在本地提供服务了！ </p>
<h2 id="本地服务"><a class="header" href="#本地服务">本地服务</a></h2>
<p>接下来，为开发服务器打开一个新终端。 在新终端中运行服务器让我们让它在后台运行，同时不会阻止我们运行其他命令。 在新终端中，从 <code>wasm-game-of-life/www</code> 目录中运行以下命令： </p>
<pre><code>npm run start
</code></pre>
<p>将您的 Web 浏览器导航到 <a href="http://localhost:8080/">http://localhost:8080/</a>，您应该会看到一条警告消息： </p>
<p><a href="game-of-life/../images/game-of-life/hello-world.png"><img src="game-of-life/../images/game-of-life/hello-world.png" alt="Screenshot of the &quot;Hello, wasm-game-of-life!&quot; Web page alert" /></a></p>
<p>任何时候进行更改并希望它们反映在 <a href="http://localhost:8080/">http://localhost:8080/</a> 上，只需在 <code>wasm-game-of-life</code> 目录中运行 <code>wasm-pack build</code> 命令.</p>
<p>Anytime you make changes and want them reflected on
<a href="http://localhost:8080/">http://localhost:8080/</a>, just re-run the <code>wasm-pack build</code> command within the <code>wasm-game-of-life</code> directory.</p>
<h2 id="练习"><a class="header" href="#练习">练习</a></h2>
<ul>
<li>
<p>修改 <code>wasm-game-of-life/src/lib.rs</code> 中的 <code>greet</code> 函数，采用 <code>name: &amp;str</code> 参数来自定义警报消息，并将你的名字从内部传递给 <code>greet</code> 函数 <code>wasm-game-of-life/www/index.js</code>。 使用 <code>wasm-pack build</code> 重新构建 <code>.wasm</code> 二进制文件，然后在 Web 浏览器中刷新 <a href="http://localhost:8080/">http://localhost:8080/</a>，你应该会看到一个自定义的问候语！ </p>
<details>
  <summary>答案</summary>
<p><code>wasm-game-of-life/src/lib.rs</code> 中的 <code>greet</code> 函数的新版本:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn greet(name: &amp;str) {
    alert(&amp;format!(&quot;Hello, {}!&quot;, name));
}
<span class="boring">}
</span></code></pre></pre>
<p><code>wasm-game-of-life/www/index.js</code> 中对 <code>greet</code> 的新调用：</p>
<pre><code class="language-js">wasm.greet(&quot;Your Name&quot;);
</code></pre>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="康威生命游戏规则"><a class="header" href="#康威生命游戏规则">康威生命游戏规则</a></h1>
<p><em>注：如果你已经熟悉了康威的生命游戏及其规则。请随意跳到下一节！</em>。</p>
<p><a href="https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">维基百科对康威生命游戏的规则做了一个很好的描述:</a></p>
<blockquote>
<p>生命游戏的宇宙是一个无限的二维正交方格网格，
每个方格都处于两种可能状态中的一种，活或死，（或分别为有人居住和无人居住）。
每个单元格与其八个相邻单元格相互作用，这些单元格是水平、垂直或对角相邻的单元格。
在时间的每一步，都会发生以下转换：</p>
<ol>
<li>任何具有少于两个活邻居的活单元格都会死亡，就像人口不足一样。</li>
<li>任何有两个或三个活邻居的活单元格都会传给下一代。</li>
<li>任何拥有三个以上活邻居的活单元格都会死亡，就像人口过多一样。</li>
<li>任何只有三个活邻居的死单元格都会变成活单元格，就像通过繁殖一样。</li>
</ol>
<p>这些将自动机的行为与现实生活进行比较的规则可以浓缩为以下内容：</p>
<ol>
<li>任何有两个或三个活邻居的活单元格都能存活。</li>
<li>任何具有三个活邻居的死单元格都会成为活单元格。</li>
<li>所有其他活单元格在下一代中死亡。同样，所有其他死单元格保持死亡。 </li>
</ol>
<p>初始模式构成了系统的种子。 
第一代是通过将上述规则同时应用于种子中的每个单元格，
无论是活的还是死的； 出生和死亡同时发生，
发生这种情况的离散时刻有时称为滴答声。 每
一代都是前一代的纯函数。 这些规则不断被反复应用以创造更多的世代。</p>
</blockquote>
<p>考虑以下初始宇宙:</p>
<img src='../images/game-of-life/initial-universe.png' alt='Initial Universe' width=80 />
<p>我们可以通过考虑每个单元格来计算下一代。左上角的单元格已死。规则 (4) 是唯一适用于死单元格的转换规则。然而，因为左上角的单元格没有正好三个活着的邻居，所以转换规则不适用，它在下一代中仍然是死的。第一行中的每个其他单元格也是如此。</p>
<p>当我们考虑第二行第三列的顶部活单元格时，事情变得有趣了。对于活单元格，前三个规则中的任何一个都可能适用。在这个单元格的情况下，它只有一个活着的邻居，因此规则（1）适用：这个单元格将在下一代死亡。同样的命运等待着底部的活单元格。</p>
<p>中间的活单元格有两个活的邻居：顶部和底部的活单元格。这意味着规则 (2) 适用，并且它在下一代中仍然存在。</p>
<p>最后一个有趣的例子是中间活单元格左侧和右侧的死单元格。三个活单元格都是这两个单元格的邻居，这意味着规则（4）适用，这些单元格将在下一代变得活跃。</p>
<p>把它们放在一起，我们在下一个滴答后得到这个宇宙：</p>
<img src='../images/game-of-life/next-universe.png' alt='Next Universe' width=80 />
<p>从这些简单的、确定性的规则中，出现了奇怪而令人兴奋的行为:</p>
<table><thead><tr><th>Gosper's glider gun</th><th>Pulsar</th><th>Space ship</th></tr></thead><tbody>
<tr><td><img src="game-of-life/../images/wiki/Gospers_glider_gun.gif" alt="Gosper's glider gun" /></td><td><img src="game-of-life/../images/wiki/Game_of_life_pulsar.gif" alt="Pulsar" /></td><td><img src="game-of-life/../images/wiki/Game_of_life_animated_LWSS.gif" alt="Lighweight space ship" /></td></tr>
</tbody></table>
<center>
<iframe width="560" height="315" src="https://www.youtube.com/embed/C2vgICfQawE?rel=0&amp;start=65" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</center>
<h2 id="练习-1"><a class="header" href="#练习-1">练习</a></h2>
<ul>
<li>
<p>用手计算我们的例子宇宙的下一个刻度。注意到任何熟悉的东西吗？</p>
<details>
  <summary>答案</summary>
<p>它应该是例子宇宙的初始状态。</p>
<img src='../images/game-of-life/initial-universe.png' alt='Initial Universe' width=80 />
<p>这种模式是<em>周期性的</em>：它在每两个ticks之后返回到初始状态。</p>
</details>
</li>
<li>
<p>你能找到一个稳定的初始宇宙吗？就是说，一个每一代都是一样的宇宙。</p>
<details>
  <summary>答案</summary>
<p>有无限多的稳定的宇宙! 琐碎稳定的宇宙是空宇宙。一个由活单元格组成的2乘2的正方形也是一个稳定的宇宙。</p>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现康威的生命游戏"><a class="header" href="#实现康威的生命游戏">实现康威的生命游戏</a></h1>
<h2 id="设计"><a class="header" href="#设计">设计</a></h2>
<p>在我们深入研究之前，我们需要考虑一些设计选择。 </p>
<h3 id="无限宇宙"><a class="header" href="#无限宇宙">无限宇宙</a></h3>
<p>生命游戏是在一个无限的宇宙中进行的，但我们没有无限的内存和计算能力。 解决这个相当烦人的限制通常有以下三种方式之一： </p>
<ol>
<li>
<p>跟踪宇宙的哪个子集发生了有趣的事情，并根据需要扩展该区域。 在最坏的情况下，这种扩展是无界的，实现会越来越慢，最终会耗尽内存。 </p>
</li>
<li>
<p>创建一个固定大小的宇宙，其中边缘的单元格比中间的单元格具有更少的邻居。 这种方法的缺点是，像滑翔机一样到达宇宙尽头的无限模式被扼杀了。 </p>
</li>
<li>
<p>创建一个固定大小的周期性宇宙，其中边缘的单元格有环绕宇宙另一侧的邻居。 因为邻居环绕着宇宙的边缘，所以滑翔机可以永远运行。 </p>
</li>
</ol>
<p>我们将实施第三个选项。</p>
<h3 id="rust-和-javascript-的接口"><a class="header" href="#rust-和-javascript-的接口">Rust 和 JavaScript 的接口</a></h3>
<blockquote>
<p>⚡ 这是本教程中需要理解和掌握的最重要的概念之一！</p>
</blockquote>
<p>JavaScript 的垃圾收集堆——其中分配了“对象”、“数组”和 DOM 节点——与 WebAssembly 的线性内存空间不同，我们的 Rust 值存在于其中。 WebAssembly 目前无法直接访问垃圾收集堆（截至 2018 年 4 月，这预计会随着 <a href="https://github.com/WebAssembly/interface-types/blob/master/proposals/interface-types/Explainer.md">“接口类型”提案</a> 的出现而改变）。 另一方面，JavaScript可以读写WebAssembly的线性内存空间，但只能作为标量值的<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a>（<code>u8</code>，<code>i32</code>，<code>f64</code>，等等）。 WebAssembly 函数也接受和返回标量值。 这些是构成所有 WebAssembly 和 JavaScript 通信的构建块。 </p>
<p><code>wasm_bindgen</code> 定义了如何跨这个边界处理复合结构的共同理解。 它涉及装箱 Rust 结构，并将指针包装在 JavaScript 类中以提高可用性，或者从 Rust 索引到 JavaScript 对象表。 <code>wasm_bindgen</code> 非常方便，但它并没有消除考虑我们的数据表示的需要，以及跨越这个边界传递的值和结构。 相反，将其视为实现您选择的界面设计的工具。</p>
<p>在设计 WebAssembly 和 JavaScript 之间的接口时，我们希望针对以下属性进行优化： </p>
<ol>
<li>
<p><strong>最大限度地减少进出 WebAssembly 线性内存的复制。</strong> 不必要的副本会带来不必要的开销。 </p>
</li>
<li>
<p><strong>最小化序列化和反序列化。</strong> 与副本类似，序列化和反序列化也会产生开销，并且通常也会产生复制。 如果我们可以将不透明的句柄传递给数据结构——而不是在一侧序列化它，将它复制到 WebAssembly 线性内存中的某个已知位置，然后在另一侧反序列化——我们通常可以减少很多开销。 <code>wasm_bindgen</code> 帮助我们定义和使用 JavaScript 对象或盒装 Rust 结构的不透明句柄。 </p>
</li>
</ol>
<h3 id="在我们的生活游戏中连接-rust-和-javascript"><a class="header" href="#在我们的生活游戏中连接-rust-和-javascript">在我们的生活游戏中连接 Rust 和 JavaScript</a></h3>
<p>让我们首先列举一些要避免的危险。 我们不想在每个滴答声中将整个宇宙复制到 WebAssembly 线性内存中。 我们不想为宇宙中的每个单元格分配对象，也不想强加跨界调用来读取和写入每个单元格。</p>
<p>这让我们何去何从？ 我们可以将宇宙表示为一个平面数组，它存在于 WebAssembly 线性内存中，每个单元格都有一个字节。 <code>0</code> 是死单元格，<code>1</code> 是活单元格。</p>
<p>以下是 4 x 4 宇宙在内存中的样子： </p>
<p><img src="game-of-life/../images/game-of-life/universe.png" alt="Screenshot of a 4 by 4 universe" /></p>
<p>为了找到宇宙中某一行和某一列的单元格的阵列索引，我们可以使用这个公式：</p>
<pre><code class="language-text">index(row, column, universe) = row * width(universe) + column
</code></pre>
<p>我们有几种方法可以将宇宙的单元格暴露给 JavaScript。首先，我们将为 &quot;宇宙 &quot;实现<a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>std::fmt::Display</code></a>，我们可以用它来生成一个渲染为文本字符的单元格的Rust<code>String</code>。然后这个Rust字符串从WebAssembly的线性内存中复制到JavaScript的垃圾收集堆中的一个JavaScript字符串，然后通过设置HTML<code>textContent</code>来显示。在本章的后面，我们将发展这个实现，以避免在堆之间复制宇宙的单元，并渲染到<code>&lt;canvas&gt;</code>。</p>
<p><em>另一个可行的设计方案是让Rust在每次打勾后返回一个改变状态的单元格的列表，而不是将整个宇宙暴露给JavaScript。这样一来，JavaScript就不需要在渲染时遍历整个宇宙，只需要遍历相关的子集。这样做的好处是，这种基于delta的设计在实现上稍显困难。</em></p>
<h2 id="rust-实现"><a class="header" href="#rust-实现">Rust 实现</a></h2>
<p>在上一章中，我们克隆了一个初始项目模板。 我们现在将修改该项目模板。</p>
<p>让我们首先从 <code>wasm-game-of-life/src/lib.rs</code> 中删除 <code>alert</code> 导入和 <code>greet</code> 函数，并将它们替换为单元格的类型定义： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
#[repr(u8)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Cell {
    Dead = 0,
    Alive = 1,
}
<span class="boring">}
</span></code></pre></pre>
<p>重要的是我们有<code>#[repr(u8)]</code>，这样每个单元格都表示为一个字节。 同样重要的是，<code>Dead</code> 变体为 <code>0</code>，<code>Alive</code> 变体为 <code>1</code>，以便我们可以轻松地通过加法计算单元格的活邻居。</p>
<p>接下来，让我们定义宇宙。 宇宙有宽度和高度，以及长度为 <code>width * height</code> 的单元向量。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: Vec&lt;Cell&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>为了访问给定行和列的单元格，我们将行和列转换为单元格向量的索引，如前所述：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    fn get_index(&amp;self, row: u32, column: u32) -&gt; usize {
        (row * self.width + column) as usize
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>为了计算一个单元格的下一个状态，我们需要计算它的邻居有多少是活着的。 让我们编写一个 <code>live_neighbor_count</code> 方法来做到这一点！ </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    // ...

    fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
        let mut count = 0;
        for delta_row in [self.height - 1, 0, 1].iter().cloned() {
            for delta_col in [self.width - 1, 0, 1].iter().cloned() {
                if delta_row == 0 &amp;&amp; delta_col == 0 {
                    continue;
                }

                let neighbor_row = (row + delta_row) % self.height;
                let neighbor_col = (column + delta_col) % self.width;
                let idx = self.get_index(neighbor_row, neighbor_col);
                count += self.cells[idx] as u8;
            }
        }
        count
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>live_neighbor_count</code> 方法使用 deltas 和 modulo 来避免使用 <code>if</code> 对宇宙边缘进行特殊外壳。 当应用 <code>-1</code> 的增量时，我们<em>添加</em> <code>self.height - 1</code> 并让模数做它的事情，而不是尝试减去 <code>1</code>。 <code>row</code> 和 <code>column</code> 可以是 <code>0</code>，如果我们试图从它们中减去 <code>1</code>，就会出现一个无符号整数下溢。</p>
<p>现在我们拥有了从当前计算下一代所需的一切！ 游戏的每条规则都直接转换为“匹配”表达式的条件。 此外，因为我们希望 JavaScript 控制滴答发生的时间，我们将把这个方法放在一个 <code>#[wasm_bindgen]</code> 块中，以便它暴露给 JavaScript。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    pub fn tick(&amp;mut self) {
        let mut next = self.cells.clone();

        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }

        self.cells = next;
    }

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>到目前为止，宇宙的状态被表示为一个单元格向量。 为了使人能够读懂这些内容，让我们实现一个基本的文本渲染器。 这个想法是将宇宙一行一行地写成文本，对于每个活着的单元格，打印 Unicode 字符<code>◼</code>（“黑色中型方块”）。 对于死单元格，我们将打印<code>◻</code>（一个“白色中等正方形”）。</p>
<p>通过实现 Rust 标准库中的 <a href="https://doc.rust-lang.org/1.25.0/std/fmt/trait.Display.html"><code>Display</code></a> 特性，我们可以添加一种以面向用户的方式格式化结构的方法。 这也会自动给我们一个 <a href="https://doc.rust-lang.org/1.25.0/std/string/trait.ToString.html"><code>to_string</code></a> 方法。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fmt;

impl fmt::Display for Universe {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        for line in self.cells.as_slice().chunks(self.width as usize) {
            for &amp;cell in line {
                let symbol = if cell == Cell::Dead { '◻' } else { '◼' };
                write!(f, &quot;{}&quot;, symbol)?;
            }
            write!(f, &quot;\n&quot;)?;
        }

        Ok(())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最后，我们定义了一个构造函数，用一个有趣的活单元格和死单元格的模式来初始化宇宙，以及一个`render'方法:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn new() -&gt; Universe {
        let width = 64;
        let height = 64;

        let cells = (0..width * height)
            .map(|i| {
                if i % 2 == 0 || i % 7 == 0 {
                    Cell::Alive
                } else {
                    Cell::Dead
                }
            })
            .collect();

        Universe {
            width,
            height,
            cells,
        }
    }

    pub fn render(&amp;self) -&gt; String {
        self.to_string()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这样，我们的生命游戏的Rust部分就完成了。</p>
<p>在<code>wasm-game-of-life</code>目录下运行<code>wasm-pack build</code>，将其重新编译为WebAssembly。</p>
<h2 id="用javascript进行渲染"><a class="header" href="#用javascript进行渲染">用JavaScript进行渲染</a></h2>
<p>首先，让我们在<code>wasm-game-of-life/www/index.html</code>中添加一个<code>&lt;pre&gt;</code>元素，将宇宙渲染进去，就在<code>&lt;script&gt;</code>标签上方:</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;pre id=&quot;game-of-life-canvas&quot;&gt;&lt;/pre&gt;
  &lt;script src=&quot;./bootstrap.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>此外，我们希望<code>&lt;pre&gt;</code>在网页的中间位置。我们可以使用CSS柔性框来完成这个任务。在<code>wasm-game-of-life/www/index.html</code>的<code>&lt;head&gt;</code>内添加以下<code>&lt;style&gt;</code>标签:</p>
<pre><code class="language-html">&lt;style&gt;
  body {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
&lt;/style&gt;
</code></pre>
<p>在 <code>wasm-game-of-life/www/index.js</code> 的顶部，让我们修复我们的导入以引入 <code>Universe</code> 而不是旧的 <code>greet</code> 函数： </p>
<pre><code class="language-js">import { Universe } from &quot;wasm-game-of-life&quot;;
</code></pre>
<p>另外，让我们获取刚刚添加的 <code>&lt;pre&gt;</code> 元素并实例化一个新的 Universe：</p>
<pre><code class="language-js">const pre = document.getElementById(&quot;game-of-life-canvas&quot;);
const universe = Universe.new();
</code></pre>
<p>JavaScript在<a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame">一个<code>requestAnimationFrame</code>循环</a>中运行。在每个迭代中，它将当前的宇宙画到<code>&lt;pre&gt;</code>，然后调用<code>Universe::tick</code>。</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  pre.textContent = universe.render();
  universe.tick();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>为了开始渲染过程，我们所要做的就是为渲染循环的第一次迭代进行初始调用:</p>
<pre><code class="language-js">requestAnimationFrame(renderLoop);
</code></pre>
<p>确保你的开发服务器仍在运行（在<code>wasm-game-of-life/www</code>内运行<code>npm run start</code>），这就是<a href="http://localhost:8080/">http://localhost:8080/</a>应该有的样子:</p>
<p><a href="game-of-life/../images/game-of-life/initial-game-of-life-pre.png"><img src="game-of-life/../images/game-of-life/initial-game-of-life-pre.png" alt="Screenshot of the Game of Life implementation with text rendering" /></a></p>
<h2 id="直接从内存向画布渲染"><a class="header" href="#直接从内存向画布渲染">直接从内存向画布渲染</a></h2>
<p>在Rust中生成（和分配）一个<code>String</code>，然后让<code>wasm-bindgen</code>将其转换为有效的JavaScript字符串，就会对宇宙的单元格进行不必要的复制。由于JavaScript代码已经知道了宇宙的宽度和高度，并且可以直接读取构成单元格的WebAssembly的线性内存，我们将修改<code>render</code>方法以返回一个指向单元格数组开始的指针。</p>
<p>另外，我们将改用<a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a>来代替渲染Unicode文本。我们将在本教程的其余部分使用这种设计。</p>
<p>在<code>wasm-game-of-life/www/index.html</code>中，让我们把之前添加的<code>&lt;pre&gt;</code>替换成我们要渲染的<code>&lt;canvas&gt;</code>（它也应该在<code>&lt;body&gt;</code>中，在加载我们JavaScript的<code>&lt;script&gt;</code>之前）：</p>
<pre><code class="language-html">&lt;body&gt;
  &lt;canvas id=&quot;game-of-life-canvas&quot;&gt;&lt;/canvas&gt;
  &lt;script src='./bootstrap.js'&gt;&lt;/script&gt;
&lt;/body&gt;
</code></pre>
<p>为了从Rust的实现中获得必要的信息，我们需要为一个宇宙的宽度、高度和指向其单元格数组的指针增加一些getter函数。所有这些也都暴露在JavaScript中。在<code>wasm-game-of-life/src/lib.rs</code>中增加这些内容:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn width(&amp;self) -&gt; u32 {
        self.width
    }

    pub fn height(&amp;self) -&gt; u32 {
        self.height
    }

    pub fn cells(&amp;self) -&gt; *const Cell {
        self.cells.as_ptr()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>接下来，在<code>wasm-game-of-life/www/index.js</code>中，让我们也从<code>wasm-game-of-life</code>中导入<code>Cell</code>，并定义一些常量，我们将在渲染到画布时使用：</p>
<pre><code class="language-js">import { Universe, Cell } from &quot;wasm-game-of-life&quot;;

const CELL_SIZE = 5; // px
const GRID_COLOR = &quot;#CCCCCC&quot;;
const DEAD_COLOR = &quot;#FFFFFF&quot;;
const ALIVE_COLOR = &quot;#000000&quot;;
</code></pre>
<p>现在，让我们重写这段JavaScript代码的其余部分，不再写入<code>&lt;pre&gt;</code>的<code>textContent</code>，而是绘制到<code>&lt;canvas&gt;</code>:</p>
<pre><code class="language-js">// Construct the universe, and get its width and height.
const universe = Universe.new();
const width = universe.width();
const height = universe.height();

// Give the canvas room for all of our cells and a 1px border
// around each of them.
const canvas = document.getElementById(&quot;game-of-life-canvas&quot;);
canvas.height = (CELL_SIZE + 1) * height + 1;
canvas.width = (CELL_SIZE + 1) * width + 1;

const ctx = canvas.getContext('2d');

const renderLoop = () =&gt; {
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>为了画出单元格之间的网格，我们画了一组等距的水平线，和一组等距的垂直线。这些线纵横交错，形成网格。</p>
<pre><code class="language-js">const drawGrid = () =&gt; {
  ctx.beginPath();
  ctx.strokeStyle = GRID_COLOR;

  // Vertical lines.
  for (let i = 0; i &lt;= width; i++) {
    ctx.moveTo(i * (CELL_SIZE + 1) + 1, 0);
    ctx.lineTo(i * (CELL_SIZE + 1) + 1, (CELL_SIZE + 1) * height + 1);
  }

  // Horizontal lines.
  for (let j = 0; j &lt;= height; j++) {
    ctx.moveTo(0,                           j * (CELL_SIZE + 1) + 1);
    ctx.lineTo((CELL_SIZE + 1) * width + 1, j * (CELL_SIZE + 1) + 1);
  }

  ctx.stroke();
};
</code></pre>
<p>我们可以通过<code>memory</code>直接访问WebAssembly的线性内存，它被定义在原始wasm模块<code>wasm_game_of_life_bg</code>。为了绘制单元格，我们得到一个指向宇宙单元格的指针，构建一个覆盖单元格缓冲区的<code>Uint8Array</code>，遍历每个单元格，并根据单元格是死是活，分别绘制一个白色或黑色的矩形。通过使用指针和覆盖，我们避免了在每次打勾时将单元格复制到边界上。</p>
<pre><code class="language-js">// Import the WebAssembly memory at the top of the file.
import { memory } from &quot;wasm-game-of-life/wasm_game_of_life_bg&quot;;

// ...

const getIndex = (row, column) =&gt; {
  return row * width + column;
};

const drawCells = () =&gt; {
  const cellsPtr = universe.cells();
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      ctx.fillStyle = cells[idx] === Cell.Dead
        ? DEAD_COLOR
        : ALIVE_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
<p>为了开始渲染过程，我们将使用与上面相同的代码来启动渲染循环的第一次迭代:</p>
<pre><code class="language-js">drawGrid();
drawCells();
requestAnimationFrame(renderLoop);
</code></pre>
<p>注意，我们在这里调用<code>drawGrid()</code>和<code>drawCells()</code>，然后再调用<code>requestAnimationFrame()</code>。我们这样做的原因是为了在我们进行修改之前画出宇宙的_初始_状态。如果我们只是简单地调用<code>requestAnimationFrame(renderLoop)</code>，我们最终会出现这样的情况：第一个被绘制的帧实际上是在第一次调用<code>universe.tick()</code>之后，也就是这些单元格生命中的第二个 &quot;打勾&quot;。</p>
<h2 id="it-works"><a class="header" href="#it-works">It Works!</a></h2>
<p>通过从 <code>wasm-game-of-life</code> 目录中运行以下命令来重建 WebAssembly 和绑定：</p>
<pre><code>wasm-pack build
</code></pre>
<p>确保您的开发服务器仍在运行。 如果不是，请从 <code>wasm-game-of-life/www</code> 目录中重新启动它：</p>
<pre><code>npm run start
</code></pre>
<p>如果你刷新<a href="http://localhost:8080/">http://localhost:8080/</a>，你应该会看到精彩的生活展示！ </p>
<p><a href="game-of-life/../images/game-of-life/initial-game-of-life.png"><img src="game-of-life/../images/game-of-life/initial-game-of-life.png" alt="Screenshot of the Game of Life implementation" /></a></p>
<p>顺便说一句，还有一个非常简洁的算法来实现生命游戏，称为 <a href="https://en.wikipedia.org/wiki/Hashlife">hashlife</a>。 它使用积极的记忆，并且实际上可以<em>指数更快</em>来计算它运行的时间越长的后代！ 鉴于此，您可能想知道为什么我们没有在本教程中实现 hashlife。 这超出了本文的范围，我们专注于 Rust 和 WebAssembly 的集成，但我们强烈建议您自行了解 hashlife！</p>
<h2 id="练习-2"><a class="header" href="#练习-2">练习</a></h2>
<ul>
<li>
<p>用单个太空船初始化宇宙。</p>
</li>
<li>
<p>不是对初始宇宙进行硬编码，而是生成一个随机的宇宙，其中每个单元格有 550 次存活或死亡的机会。 </p>
<p><em>提示：使用<a href="https://crates.io/crates/js-sys"><code>js-sys</code> crate</a> 导入<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random"><code>Math.random</code> JavaScript 函数</a>.</em> </p>
<details>
  <summary>答案</summary>
  *首先，在`wasm-game-of-life/Cargo.toml`中添加`js-sys`作为依赖项：*
<pre><code class="language-toml"># ...
[dependencies]
js-sys = &quot;0.3&quot;
# ...
</code></pre>
<p><em>然后，使用<code>js_sys::Math::random</code>函数来投掷硬币：</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate js_sys;

// ...

if js_sys::Math::random() &lt; 0.5 {
    // Alive...
} else {
    // Dead...
}
<span class="boring">}
</span></code></pre></pre>
</details>
</li>
<li>
<p>用一个字节表示每个单元，使单元的迭代变得容易，但它的代价是浪费了内存。每个字节有八个比特，但是我们只需要一个比特来表示每个单元格是活的还是死的。重构数据表示，使每个单元格只使用一个比特的空间。</p>
<details>
  <summary>答案</summary>
<p>在Rust中，你可以使用<a href="https://crates.io/crates/fixedbitset"><code>fixedbitset</code> crate和它的<code>FixedBitSet</code>类型</a>来表示单元，而不是<code>Vec&lt;Cell&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Make sure you also added the dependency to Cargo.toml!
extern crate fixedbitset;
use fixedbitset::FixedBitSet;

// ...

#[wasm_bindgen]
pub struct Universe {
    width: u32,
    height: u32,
    cells: FixedBitSet,
}
<span class="boring">}
</span></code></pre></pre>
<p>Universe 构造函数可以通过以下方式进行调整：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Universe {
    let width = 64;
    let height = 64;

    let size = (width * height) as usize;
    let mut cells = FixedBitSet::with_capacity(size);

    for i in 0..size {
        cells.set(i, i % 2 == 0 || i % 7 == 0);
    }

    Universe {
        width,
        height,
        cells,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>要在宇宙的下一个刻度中更新单元格，我们使用<code>FixedBitSet</code>的<code>set</code>方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>next.set(idx, match (cell, live_neighbors) {
    (true, x) if x &lt; 2 =&gt; false,
    (true, 2) | (true, 3) =&gt; true,
    (true, x) if x &gt; 3 =&gt; false,
    (false, 3) =&gt; true,
    (otherwise, _) =&gt; otherwise
});
<span class="boring">}
</span></code></pre></pre>
<p>要将指向位开头的指针传递给 JavaScript，您可以将 <code>FixedBitSet</code> 转换为切片，然后将切片转换为指针：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Universe {
    // ...

    pub fn cells(&amp;self) -&gt; *const u32 {
        self.cells.as_slice().as_ptr()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>在 JavaScript 中，从 Wasm 内存构造一个 <code>Uint8Array</code> 和之前一样，只是数组的长度不再是 <code>width * height</code>，而是 <code>width * height / 8</code> 因为我们每比特有一个单元格而不是 每字节：</p>
<pre><code class="language-js">const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);
</code></pre>
<p>给定一个索引和 <code>Uint8Array</code>，您可以使用以下函数确定是否设置了 <em>n<sup>th</sup></em> 位：</p>
<pre><code class="language-js">const bitIsSet = (n, arr) =&gt; {
  const byte = Math.floor(n / 8);
  const mask = 1 &lt;&lt; (n % 8);
  return (arr[byte] &amp; mask) === mask;
};
</code></pre>
<p>鉴于所有这些，新版本的 <code>drawCells</code> 看起来像这样：</p>
<pre><code class="language-js">const drawCells = () =&gt; {
  const cellsPtr = universe.cells();

  // This is updated!
  const cells = new Uint8Array(memory.buffer, cellsPtr, width * height / 8);

  ctx.beginPath();

  for (let row = 0; row &lt; height; row++) {
    for (let col = 0; col &lt; width; col++) {
      const idx = getIndex(row, col);

      // This is updated!
      ctx.fillStyle = bitIsSet(idx, cells)
        ? ALIVE_COLOR
        : DEAD_COLOR;

      ctx.fillRect(
        col * (CELL_SIZE + 1) + 1,
        row * (CELL_SIZE + 1) + 1,
        CELL_SIZE,
        CELL_SIZE
      );
    }
  }

  ctx.stroke();
};
</code></pre>
</details>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="实现康威的生命游戏-1"><a class="header" href="#实现康威的生命游戏-1">实现康威的生命游戏</a></h1>
<p>现在我们已经使用 JavaScript 在浏览器中实现了生命游戏渲染的 Rust 实现，让我们来谈谈测试我们的 Rust 生成的 WebAssembly 函数。</p>
<p>我们将测试我们的 <code>tick</code> 函数以确保它提供我们期望的输出。</p>
<p>接下来，我们将要在 <code>wasm_game_of_life/src/lib.rs</code> 文件中现有的 <code>impl Universe</code> 块中创建一些 setter 和 getter 函数。 我们将创建一个 <code>set_width</code> 和一个 <code>set_height</code> 函数，以便我们可以创建不同大小的 <code>Universe</code>。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
impl Universe { 
    // ...

    /// Set the width of the universe.
    ///
    /// Resets all cells to the dead state.
    pub fn set_width(&amp;mut self, width: u32) {
        self.width = width;
        self.cells = (0..width * self.height).map(|_i| Cell::Dead).collect();
    }

    /// Set the height of the universe.
    ///
    /// Resets all cells to the dead state.
    pub fn set_height(&amp;mut self, height: u32) {
        self.height = height;
        self.cells = (0..self.width * height).map(|_i| Cell::Dead).collect();
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>我们将在我们的 <code>wasm_game_of_life/src/lib.rs</code> 文件中创建另一个不带 <code>#[wasm_bindgen]</code> 属性的 <code>impl Universe</code> 块。 有一些我们需要测试的函数我们不想暴露给我们的 JavaScript。 Rust 生成的 WebAssembly 函数不能返回借用的引用。 尝试使用属性编译 Rust 生成的 WebAssembly 并查看您得到的错误。</p>
<p>我们将编写 <code>get_cells</code> 的实现来获取 <code>Universe</code> 的 <code>cells</code> 的内容。 我们还将编写一个 <code>set_cells</code> 函数，以便我们可以将 <code>Universe</code> 的特定行和列中的 <code>cells</code> 设置为 <code>Alive</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Universe {
    /// Get the dead and alive values of the entire universe.
    pub fn get_cells(&amp;self) -&gt; &amp;[Cell] {
        &amp;self.cells
    }

    /// Set cells to be alive in a universe by passing the row and column
    /// of each cell as an array.
    pub fn set_cells(&amp;mut self, cells: &amp;[(u32, u32)]) {
        for (row, col) in cells.iter().cloned() {
            let idx = self.get_index(row, col);
            self.cells[idx] = Cell::Alive;
        }
    }

}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们将在 <code>wasm_game_of_life/tests/web.rs</code> 文件中创建我们的测试。</p>
<p>在我们这样做之前，文件中已经有一个工作测试。 您可以通过在 <code>wasm-game-of-life</code> 目录中运行 <code>wasm-pack test --chrome --headless</code> 来确认 Rust 生成的 WebAssembly 测试正在运行。 你还可以使用 <code>--firefox</code>、<code>--safari</code> 和 <code>--node</code> 选项在这些浏览器中测试你的代码。</p>
<p>在 <code>wasm_game_of_life/tests/web.rs</code> 文件中，我们需要导出 <code>wasm_game_of_life</code> crate 和 <code>Universe</code> 类型。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate wasm_game_of_life;
use wasm_game_of_life::Universe;
<span class="boring">}
</span></code></pre></pre>
<p>在 <code>wasm_game_of_life/tests/web.rs</code> 文件中，我们将要创建一些飞船建造器功能。</p>
<p>我们需要一个用于我们的输入宇宙飞船，我们将调用 <code>tick</code> 函数，我们希望在一个刻度后我们将获得预期的宇宙飞船。 我们选择了要初始化为 <code>Alive</code> 的单元格，以在 <code>input_spaceship</code> 函数中创建我们的飞船。 <code>input_spaceship</code> 勾选后，<code>expected_spaceship</code> 函数中飞船的位置是手动计算的。 您可以自己确认一下，输入飞船的单元格在一个tick后与预期的飞船相同。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
pub fn input_spaceship() -&gt; Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&amp;[(1,2), (2,3), (3,1), (3,2), (3,3)]);
    universe
}

#[cfg(test)]
pub fn expected_spaceship() -&gt; Universe {
    let mut universe = Universe::new();
    universe.set_width(6);
    universe.set_height(6);
    universe.set_cells(&amp;[(2,1), (2,3), (3,2), (3,3), (4,2)]);
    universe
}
<span class="boring">}
</span></code></pre></pre>
<p>现在我们将为我们的<code>test_tick</code> 函数编写实现。 首先，我们创建了一个 <code>input_spaceship()</code> 和 <code>expected_spaceship()</code> 的实例。 然后，我们在 <code>input_universe</code> 上调用 <code>tick</code>。 最后，我们使用 <code>assert_eq!</code> 宏调用 <code>get_cells()</code> 以确保 <code>input_universe</code> 和 <code>expected_universe</code> 具有相同的 <code>Cell</code> 数组值。 我们将 <code>#[wasm_bindgen_test]</code> 属性添加到我们的代码块中，以便我们可以测试 Rust 生成的 WebAssembly 代码并使用 <code>wasm-pack test</code> 来测试 WebAssembly 代码。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen_test]
pub fn test_tick() {
    // Let's create a smaller Universe with a small spaceship to test!
    let mut input_universe = input_spaceship();

    // This is what our spaceship should look like
    // after one tick in our universe.
    let expected_universe = expected_spaceship();

    // Call `tick` and then see if the cells in the `Universe`s are the same.
    input_universe.tick();
    assert_eq!(&amp;input_universe.get_cells(), &amp;expected_universe.get_cells());
}
<span class="boring">}
</span></code></pre></pre>
<p>通过在 <code>wasm-game-of-life</code> 目录中运行 <code>wasm-pack test --firefox --headless</code> 进行测试。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试"><a class="header" href="#调试">调试</a></h1>
<p>在我们写更多的代码之前，我们会想在我们的腰带上有一些调试工具，以备出错时使用。花点时间回顾一下<a href="game-of-life/../reference/debugging.html">参考页列出了可用来调试Rust生成的WebAssembly的工具和方法</a>.</p>
<h2 id="为-panics-启用日志记录"><a class="header" href="#为-panics-启用日志记录">为 Panics 启用日志记录</a></h2>
<p><a href="game-of-life/../reference/debugging.html#%E8%AE%B0%E5%BD%95-panics">如果我们的代码出现混乱，我们希望在开发者控制台中显示信息性错误消息。</a></p>
<p>我们的 <code>wasm-pack-template</code> 带有一个可选的、默认启用的对 <a href="https://github.com/rustwasm/console_error_panic_hook"><code>console_error_panic_hook</code> crate</a> 的依赖，该依赖被配置在 <code>wasm-game-of-life/src/utils.rs</code> 中。我们需要做的就是在初始化函数或公共代码路径中安装这个钩子。我们可以在 <code>wasm-ame-of-life/src/lib.rs</code> 中的 <code>Universe::new</code> 构造函数中调用它。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Universe {
    utils::set_panic_hook();

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="在我们的生活游戏中加入记录的内容"><a class="header" href="#在我们的生活游戏中加入记录的内容">在我们的生活游戏中加入记录的内容</a></h2>
<p>让我们<a href="game-of-life/../reference/debugging.html#logging-with-the-console-apis">通过<code>web-sys</code> crate 使用 <code>console.log</code> 函数来添加一些关于我们 <code>Universe::tick</code> 函数中每个单元的日志</a>。</p>
<p>首先，添加 <code>web-sys</code> 作为依赖，并在 <code>wasm-game-of-life/Cargo.toml</code> 中启用其<code>&quot;console&quot;</code>功能:</p>
<pre><code class="language-toml">[dependencies]

# ...

[dependencies.web-sys]
version = &quot;0.3&quot;
features = [
  &quot;console&quot;,
]
</code></pre>
<p>为了符合人体工程学，我们将把<code>console.log</code>函数包装成一个<code>println!</code>风格的宏:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

// A macro to provide `println!(..)`-style syntax for `console.log` logging.
macro_rules! log {
    ( $( $t:tt )* ) =&gt; {
        web_sys::console::log_1(&amp;format!( $( $t )* ).into());
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>现在，我们可以通过在Rust代码中插入对<code>log</code>的调用来开始将信息记录到控制台。例如，为了记录每个单元格的状态、活的邻居数和下一个状态，我们可以这样修改<code>wasm-game-of-life/src/lib.rs</code>:</p>
<pre><code class="language-diff">diff --git a/src/lib.rs b/src/lib.rs
index f757641..a30e107 100755
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -123,6 +122,14 @@ impl Universe {
                 let cell = self.cells[idx];
                 let live_neighbors = self.live_neighbor_count(row, col);

+                log!(
+                    &quot;cell[{}, {}] is initially {:?} and has {} live neighbors&quot;,
+                    row,
+                    col,
+                    cell,
+                    live_neighbors
+                );
+
                 let next_cell = match (cell, live_neighbors) {
                     // Rule 1: Any live cell with fewer than two live neighbours
                     // dies, as if caused by underpopulation.
@@ -140,6 +147,8 @@ impl Universe {
                     (otherwise, _) =&gt; otherwise,
                 };

+                log!(&quot;    it becomes {:?}&quot;, next_cell);
+
                 next[idx] = next_cell;
             }
         }
</code></pre>
<h2 id="使用调试器在每个-tick-之间进行停顿"><a class="header" href="#使用调试器在每个-tick-之间进行停顿">使用调试器在每个 Tick 之间进行停顿</a></h2>
<p><a href="game-of-life/../reference/debugging.html#using-a-debugger">浏览器的步进调试器对于检查我们的 Rust 生成的 WebAssembly 与之交互的 JavaScript 很有用。</a></p>
<p>例如，我们可以使用调试器通过将 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger">一个 JavaScript <code>debugger;</code> 语句</a> 放在我们对 <code>universe.tick()</code> 的调用上方来暂停 <code>renderLoop</code> 函数的每次迭代。</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
  debugger;
  universe.tick();

  drawGrid();
  drawCells();

  requestAnimationFrame(renderLoop);
};
</code></pre>
<p>这为我们提供了一个方便的检查点，用于检查记录的消息，并将当前渲染的帧与前一帧进行比较。</p>
<p><a href="game-of-life/../images/game-of-life/debugging.png"><img src="game-of-life/../images/game-of-life/debugging.png" alt="Screenshot of debugging the Game of Life" /></a></p>
<h2 id="练习-3"><a class="header" href="#练习-3">练习</a></h2>
<ul>
<li>
<p>向 <code>tick</code> 函数添加日志记录，记录每个单元格的行和列，这些单元格将状态从活动状态转换为死状态，反之亦然。</p>
</li>
<li>
<p>在 <code>Universe::new</code> 方法中引入 <code>panic!()</code>。 在 Web 浏览器的 JavaScript 调试器中检查恐慌的回溯。 禁用调试符号，在没有 <code>console_error_panic_hook</code> 可选依赖项的情况下重建，并再次检查堆栈跟踪。 不是那么有用吗？ </p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="添加交互性"><a class="header" href="#添加交互性">添加交互性</a></h1>
<p>我们将继续探索 JavaScript 和 WebAssembly 界面，为我们的 Game of Life 实现添加一些交互功能。 我们将使用户能够通过单击来切换单元格是活的还是死的，并允许暂停游戏，这使得绘制单元格图案变得更加容易。 </p>
<h2 id="暂停和恢复游戏"><a class="header" href="#暂停和恢复游戏">暂停和恢复游戏</a></h2>
<p>让我们添加一个按钮来切换游戏是正在播放还是暂停。 在 <code>wasm-game-of-life/www/index.html</code> 中，在 <code>&lt;canvas&gt;</code> 正上方添加按钮：</p>
<pre><code class="language-html">&lt;button id=&quot;play-pause&quot;&gt;&lt;/button&gt;
</code></pre>
<p>在 <code>wasm-game-of-life/www/index.js</code> JavaScript 中，我们将进行以下更改：</p>
<ul>
<li>
<p>跟踪最近一次调用<code>requestAnimationFrame</code> 返回的标识符，以便我们可以通过使用该标识符调用<code>cancelAnimationFrame</code> 来取消动画。</p>
</li>
<li>
<p>当播放/暂停按钮被点击时，检查我们是否有排队动画帧的标识符。如果我们这样做，那么游戏当前正在播放，我们想要取消动画帧，以便不再调用 <code>renderLoop</code>，从而有效地暂停游戏。如果我们没有排队动画帧的标识符，那么我们当前处于暂停状态，我们想调用<code>requestAnimationFrame</code> 来恢复游戏。</p>
</li>
</ul>
<p>因为 JavaScript 正在驱动 Rust 和 WebAssembly，这就是我们需要做的所有事情，我们不需要更改 Rust 源。</p>
<p>我们引入了<code>animationId</code> 变量来跟踪<code>requestAnimationFrame</code> 返回的标识符。当没有排队的动画帧时，我们将此变量设置为 <code>null</code>。</p>
<pre><code class="language-js">let animationId = null;

// This function is the same as before, except the
// result of `requestAnimationFrame` is assigned to
// `animationId`.
const renderLoop = () =&gt; {
  drawGrid();
  drawCells();

  universe.tick();

  animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>在任何时候，我们都可以通过检查 <code>animationId</code> 的值来判断游戏是否暂停：</p>
<pre><code class="language-js">const isPaused = () =&gt; {
  return animationId === null;
};
</code></pre>
<p>现在，当点击播放/暂停按钮时，我们检查游戏当前是否暂停或播放，并分别恢复<code>renderLoop</code>动画或取消下一动画帧。 此外，我们更新按钮的文本图标以反映按钮在下一次单击时将采取的操作。</p>
<pre><code class="language-js">const playPauseButton = document.getElementById(&quot;play-pause&quot;);

const play = () =&gt; {
  playPauseButton.textContent = &quot;⏸&quot;;
  renderLoop();
};

const pause = () =&gt; {
  playPauseButton.textContent = &quot;▶&quot;;
  cancelAnimationFrame(animationId);
  animationId = null;
};

playPauseButton.addEventListener(&quot;click&quot;, event =&gt; {
  if (isPaused()) {
    play();
  } else {
    pause();
  }
});
</code></pre>
<p>最后，我们之前通过直接调用 <code>requestAnimationFrame(renderLoop)</code> 来启动游戏及其动画，但我们想用对 <code>play</code> 的调用替换它，以便按钮获得正确的初始文本图标。</p>
<pre><code class="language-diff">// This used to be `requestAnimationFrame(renderLoop)`.
play();
</code></pre>
<p>刷新 <a href="http://localhost:8080/">http://localhost:8080/</a> 我们现在应该可以通过点击按钮暂停和恢复游戏了！ </p>
<h2 id="在-click-事件上切换单元格的状态"><a class="header" href="#在-click-事件上切换单元格的状态">在 <code>&quot;click&quot;</code> 事件上切换单元格的状态</a></h2>
<p>现在我们可以暂停游戏了，是时候添加通过单击单元格来变异单元格的功能了。</p>
<p>切换一个单元格就是将它的状态从活着变为死亡或从死亡变为活着。 向 <code>wasm-game-of-life/src/lib.rs</code> 中的 <code>Cell</code> 添加 <code>toggle</code> 方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Cell {
    fn toggle(&amp;mut self) {
        *self = match *self {
            Cell::Dead =&gt; Cell::Alive,
            Cell::Alive =&gt; Cell::Dead,
        };
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>要在给定的行和列处切换单元格的状态，我们将行和列对转换为单元格向量的索引，并在该索引处的单元格上调用 toggle 方法：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Public methods, exported to JavaScript.
#[wasm_bindgen]
impl Universe {
    // ...

    pub fn toggle_cell(&amp;mut self, row: u32, column: u32) {
        let idx = self.get_index(row, column);
        self.cells[idx].toggle();
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这个方法被定义在<code>impl</code>块中，该块被注释为<code>#[wasm_bindgen]</code>，这样它就可以被JavaScript调用。</p>
<p>在<code>wasm-game-of-life/www/index.js</code>中，我们监听<code>&lt;canvas&gt;</code>元素上的点击事件，将点击事件的页面相对坐标转换为画布相对坐标，然后转换为行和列，调用<code>toggle_cell</code>方法，最后重新绘制场景。</p>
<pre><code class="language-js">canvas.addEventListener(&quot;click&quot;, event =&gt; {
  const boundingRect = canvas.getBoundingClientRect();

  const scaleX = canvas.width / boundingRect.width;
  const scaleY = canvas.height / boundingRect.height;

  const canvasLeft = (event.clientX - boundingRect.left) * scaleX;
  const canvasTop = (event.clientY - boundingRect.top) * scaleY;

  const row = Math.min(Math.floor(canvasTop / (CELL_SIZE + 1)), height - 1);
  const col = Math.min(Math.floor(canvasLeft / (CELL_SIZE + 1)), width - 1);

  universe.toggle_cell(row, col);

  drawGrid();
  drawCells();
});
</code></pre>
<p>在<code>wasm-game-of-life</code>中用<code>wasm-pack build</code>重新构建，然后再次刷新<a href="http://localhost:8080/">http://localhost:8080/</a>，现在我们可以通过点击单元格并切换其状态来绘制我们自己的图案。s</p>
<h2 id="练习-4"><a class="header" href="#练习-4">练习</a></h2>
<ul>
<li>
<p>引入一个<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range"><code>&lt;input type=&quot;range&quot;&gt;</code></a>小部件来控制每一帧动画发生多少次。</p>
</li>
<li>
<p>添加一个按钮，当点击时将宇宙重置到一个随机的初始状态。另一个按钮可以将宇宙重设为所有死单元。</p>
</li>
<li>
<p>在 <code>Ctrl + Click</code> 时，插入一个 <a href="https://en.wikipedia.org/wiki/Glider_(Conway%27s_Life)">glider</a>，以目标单元为中心。在<code>Shift + Click</code>上，插入一个脉冲星。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间分析"><a class="header" href="#时间分析">时间分析</a></h1>
<p>在本章中，我们将提高生命游戏实现的性能。 我们将使用时间分析来指导我们的工作。</p>
<p>在继续之前熟悉 <a href="game-of-life/../reference/time-profiling.html">用于时间分析 Rust 和 WebAssembly 代码的可用工具</a>。 </p>
<h2 id="使用-windowperformancenow-函数创建每秒帧数计时器"><a class="header" href="#使用-windowperformancenow-函数创建每秒帧数计时器">使用 <code>window.performance.now</code> 函数创建每秒帧数计时器</a></h2>
<p>当我们研究加速生命游戏的渲染时，这个 FPS 计时器将非常有用。</p>
<p>我们首先向 <code>wasm-game-of-life/www/index.js</code> 添加一个 <code>fps</code> 对象： </p>
<pre><code class="language-js">const fps = new class {
  constructor() {
    this.fps = document.getElementById(&quot;fps&quot;);
    this.frames = [];
    this.lastFrameTimeStamp = performance.now();
  }

  render() {
    // Convert the delta time since the last frame render into a measure
    // of frames per second.
    const now = performance.now();
    const delta = now - this.lastFrameTimeStamp;
    this.lastFrameTimeStamp = now;
    const fps = 1 / delta * 1000;

    // Save only the latest 100 timings.
    this.frames.push(fps);
    if (this.frames.length &gt; 100) {
      this.frames.shift();
    }

    // Find the max, min, and mean of our 100 latest timings.
    let min = Infinity;
    let max = -Infinity;
    let sum = 0;
    for (let i = 0; i &lt; this.frames.length; i++) {
      sum += this.frames[i];
      min = Math.min(this.frames[i], min);
      max = Math.max(this.frames[i], max);
    }
    let mean = sum / this.frames.length;

    // Render the statistics.
    this.fps.textContent = `
Frames per Second:
         latest = ${Math.round(fps)}
avg of last 100 = ${Math.round(mean)}
min of last 100 = ${Math.round(min)}
max of last 100 = ${Math.round(max)}
`.trim();
  }
};
</code></pre>
<p>接下来我们在 <code>renderLoop</code> 的每次迭代中调用 <code>fps</code> <code>render</code> 函数：</p>
<pre><code class="language-js">const renderLoop = () =&gt; {
    fps.render(); //new

    universe.tick();
    drawGrid();
    drawCells();

    animationId = requestAnimationFrame(renderLoop);
};
</code></pre>
<p>最后，不要忘记将 <code>fps</code> 元素添加到 <code>wasm-game-of-life/www/index.html</code>，就在 <code>&lt;canvas&gt;</code> 的上方:</p>
<pre><code class="language-html">&lt;div id=&quot;fps&quot;&gt;&lt;/div&gt;
</code></pre>
<p>并添加 CSS 以使其格式更好：</p>
<pre><code class="language-css">#fps {
  white-space: pre;
  font-family: monospace;
}
</code></pre>
<p>瞧！ 刷新 <a href="http://localhost:8080">http://localhost:8080</a> 现在我们有了一个 FPS 计数器！ </p>
<h3 id="使用-consoletime-和-consoletimeend-为每个-universetick-计时"><a class="header" href="#使用-consoletime-和-consoletimeend-为每个-universetick-计时">使用 <code>console.time</code> 和 <code>console.timeEnd</code> 为每个 <code>Universe::tick</code> 计时</a></h3>
<p>为了测量每次调用 <code>Universe::tick</code> 需要多长时间，我们可以通过 <code>web-sys</code> crate 使用 <code>console.time</code> 和 <code>console.timeEnd</code>。</p>
<p>首先，将 <code>web-sys</code> 作为依赖添加到 <code>wasm-game-of-life/Cargo.toml</code>：</p>
<pre><code class="language-toml">[dependencies.web-sys]
version = &quot;0.3&quot;
features = [
  &quot;console&quot;,
]
</code></pre>
<p>因为每个 <code>console.time</code> 调用都应该有一个相应的 <code>console.timeEnd</code> 调用，所以将它们都包装在 <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> 类型中会很方便：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;
use web_sys::console;

pub struct Timer&lt;'a&gt; {
    name: &amp;'a str,
}

impl&lt;'a&gt; Timer&lt;'a&gt; {
    pub fn new(name: &amp;'a str) -&gt; Timer&lt;'a&gt; {
        console::time_with_label(name);
        Timer { name }
    }
}

impl&lt;'a&gt; Drop for Timer&lt;'a&gt; {
    fn drop(&amp;mut self) {
        console::time_end_with_label(self.name);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>然后，我们可以通过将此代码段添加到方法的顶部来计算每个 <code>Universe::tick</code> 花费的时间：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _timer = Timer::new(&quot;Universe::tick&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>每次调用 <code>Universe::tick</code> 花费的时间现在记录在控制台中：</p>
<p><a href="game-of-life/../images/game-of-life/console-time.png"><img src="game-of-life/../images/game-of-life/console-time.png" alt="Screenshot of console.time logs" /></a></p>
<p>此外，<code>console.time</code> 和 <code>console.timeEnd</code> 对将显示在浏览器的分析器的 “时间轴” 或“ 瀑布” 视图中：</p>
<p><a href="game-of-life/../images/game-of-life/console-time-in-profiler.png"><img src="game-of-life/../images/game-of-life/console-time-in-profiler.png" alt="Screenshot of console.time logs" /></a></p>
<h2 id="发展我们的生命游戏宇宙"><a class="header" href="#发展我们的生命游戏宇宙">发展我们的生命游戏宇宙</a></h2>
<blockquote>
<p>⚠️ 本节使用来自 Firefox 的示例屏幕截图。 
虽然所有现代浏览器都有类似的工具，但使用不同的开发人员工具可能会有细微的差别。 
您提取的配置文件信息将基本相同，但您所看到的视图和不同工具的命名可能会有所不同。</p>
</blockquote>
<p>如果我们让生命游戏的宇宙更大，会发生什么？ 用 128 x 128 Universe 替换 64 x 64 Universe（通过修改 <code>wasm-game-of-life/src/lib.rs</code> 中的 <code>Universe::new</code>）导致 FPS 从平滑的 60 下降到不稳定的 40-ish 在我的机器上。</p>
<p>如果我们记录一个配置文件并查看瀑布视图，我们会看到每个动画帧花费了 20 毫秒以上。 回想一下，每秒 60 帧为渲染一帧的整个过程留下了 16 毫秒。 这不仅仅是我们的 JavaScript 和 WebAssembly，还有浏览器正在做的所有其他事情，比如绘画。</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-waterfall.png"><img src="game-of-life/../images/game-of-life/drawCells-before-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame" /></a></p>
<p>如果我们查看单个动画帧内发生的情况，我们会发现<code>CanvasRenderingContext2D.fillStyle</code> setter 非常昂贵！ </p>
<blockquote>
<p>⚠️ 在 Firefox 中，如果您看到一行简单地说“DOM”
而不是上面提到的“CanvasRenderingContext2D.fillStyle”，
则可能需要在性能开发人员工具选项中打开“显示 Gecko 平台数据”选项： </p>
<p><a href="game-of-life/../images/game-of-life/profiler-firefox-show-gecko-platform.png"><img src="game-of-life/../images/game-of-life/profiler-firefox-show-gecko-platform.png" alt="Turning on Show Gecko Platform Data" /></a></p>
</blockquote>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-before-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>我们可以通过查看调用树的许多帧的聚合来确认这不是异常：</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-before-calltree.png"><img src="game-of-life/../images/game-of-life/drawCells-before-calltree.png" alt="Screenshot of a flamegraph view of rendering a frame" /></a></p>
<p>我们将近 40% 的时间都花在了这个 setter 上！</p>
<blockquote>
<p>⚡ 我们可能已经预料到 <code>tick</code> 方法中的某些东西会成为性能瓶颈，
但事实并非如此。 始终让分析引导您的注意力，因为时间可能会花在您不期望的地方。</p>
</blockquote>
<p>在 <code>wasm-game-of-life/www/index.js</code> 的 <code>drawCells</code> 函数中，<code>fillStyle</code> 属性为 Universe 中的每个单元格在每个动画帧上设置一次： </p>
<pre><code class="language-js">for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);

    ctx.fillStyle = cells[idx] === DEAD
      ? DEAD_COLOR
      : ALIVE_COLOR;

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>既然我们已经发现设置<code>fillStyle</code>是如此昂贵，那么我们该如何做才能避免频繁地设置它？我们需要根据一个单元格是活的还是死的来改变<code>fillStyle</code>。如果我们设置<code>fillStyle = ALIVE_COLOR</code>，然后在一次绘制所有活着的单元格，然后设置<code>fillStyle = DEAD_COLOR</code>，在另一次绘制所有死亡的单元格，那么我们只需要设置<code>fillStyle</code>两次，而不是对每个单元格设置一次。</p>
<pre><code class="language-js">// Alive cells.
ctx.fillStyle = ALIVE_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Alive) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}

// Dead cells.
ctx.fillStyle = DEAD_COLOR;
for (let row = 0; row &lt; height; row++) {
  for (let col = 0; col &lt; width; col++) {
    const idx = getIndex(row, col);
    if (cells[idx] !== Cell.Dead) {
      continue;
    }

    ctx.fillRect(
      col * (CELL_SIZE + 1) + 1,
      row * (CELL_SIZE + 1) + 1,
      CELL_SIZE,
      CELL_SIZE
    );
  }
}
</code></pre>
<p>保存这些变化并刷新<a href="http://localhost:8080/">http://localhost:8080/</a>后，渲染又恢复到每秒60帧的平稳状态。</p>
<p>如果我们再拍一张剖面图，我们可以看到现在每个动画帧只花了大约10毫秒。</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-after-waterfall.png"><img src="game-of-life/../images/game-of-life/drawCells-after-waterfall.png" alt="Screenshot of a waterfall view of rendering a frame after the drawCells changes" /></a></p>
<p>分解一个单一的框架，我们看到<code>fillStyle</code>的成本已经没有了，我们框架的大部分时间是在<code>fillRect</code>中度过的，绘制每个单元格的矩形。</p>
<p><a href="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png"><img src="game-of-life/../images/game-of-life/drawCells-after-flamegraph.png" alt="Screenshot of a flamegraph view of rendering a frame after the drawCells changes" /></a></p>
<h2 id="让时间跑得更快"><a class="header" href="#让时间跑得更快">让时间跑得更快</a></h2>
<p>有些人不喜欢等待，他们希望每一帧动画不是发生一次宇宙的跳动，而是发生九次跳动。我们可以修改<code>wasm-game-of-life/www/index.js</code>中的<code>renderLoop</code>函数来实现这个目的。</p>
<pre><code class="language-js">for (let i = 0; i &lt; 9; i++) {
  universe.tick();
}
</code></pre>
<p>在我的机器上，这使我们回落到每秒只有35帧。这可不好。我们要的是奶油般的60帧!</p>
<p>现在我们知道时间是在 <code>Universe::tick</code> 中度过的，所以让我们添加一些 <code>Timer</code>，在 <code>console.time</code> 和 <code>console.timeEnd</code> 的调用中包住它的各个部分，看看这将会给我们带来什么。我的假设是，在每个tick上分配一个新的单元格向量并释放旧的向量是昂贵的，并且占用了我们时间预算的很大一部分。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn tick(&amp;mut self) {
    let _timer = Timer::new(&quot;Universe::tick&quot;);

    let mut next = {
        let _timer = Timer::new(&quot;allocate next cells&quot;);
        self.cells.clone()
    };

    {
        let _timer = Timer::new(&quot;new generation&quot;);
        for row in 0..self.height {
            for col in 0..self.width {
                let idx = self.get_index(row, col);
                let cell = self.cells[idx];
                let live_neighbors = self.live_neighbor_count(row, col);

                let next_cell = match (cell, live_neighbors) {
                    // Rule 1: Any live cell with fewer than two live neighbours
                    // dies, as if caused by underpopulation.
                    (Cell::Alive, x) if x &lt; 2 =&gt; Cell::Dead,
                    // Rule 2: Any live cell with two or three live neighbours
                    // lives on to the next generation.
                    (Cell::Alive, 2) | (Cell::Alive, 3) =&gt; Cell::Alive,
                    // Rule 3: Any live cell with more than three live
                    // neighbours dies, as if by overpopulation.
                    (Cell::Alive, x) if x &gt; 3 =&gt; Cell::Dead,
                    // Rule 4: Any dead cell with exactly three live neighbours
                    // becomes a live cell, as if by reproduction.
                    (Cell::Dead, 3) =&gt; Cell::Alive,
                    // All other cells remain in the same state.
                    (otherwise, _) =&gt; otherwise,
                };

                next[idx] = next_cell;
            }
        }
    }

    let _timer = Timer::new(&quot;free old cells&quot;);
    self.cells = next;
}
<span class="boring">}
</span></code></pre></pre>
<p>看一下时间，很明显我的假设是不正确的：绝大部分时间都花在了实际计算下一代的单元上。令人惊讶的是，在每次勾选时分配和释放一个载体的成本似乎可以忽略不计。又一次提醒我们要始终用剖析来指导我们的工作!</p>
<p><a href="game-of-life/../images/game-of-life/console-time-in-universe-tick.png"><img src="game-of-life/../images/game-of-life/console-time-in-universe-tick.png" alt="Screenshot of a Universe::tick timer results" /></a></p>
<p>下一节要求使用<code>nightly</code>编译器。之所以需要它，是因为我们要用<a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">test feature gate</a>来做基准测试。我们要安装的另一个工具是<a href="https://github.com/BurntSushi/cargo-benchcmp">cargo benchcmp</a>。它是一个小工具，用于比较由<code>cargo bench</code>产生的微观基准。</p>
<p>让我们写一个本地代码<code>#[bench]</code>，做与我们的WebAssembly相同的事情，但在这里我们可以使用更成熟的剖析工具。这里是新的<code>wasm-game-of-life/benches/bench.rs</code>。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![feature(test)]

<span class="boring">fn main() {
</span>extern crate test;
extern crate wasm_game_of_life;

#[bench]
fn universe_ticks(b: &amp;mut test::Bencher) {
    let mut universe = wasm_game_of_life::Universe::new();

    b.iter(|| {
        universe.tick();
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>我们还必须注释掉所有的<code>#[wasm_bindgen]</code>注释，以及<code>Cargo.toml</code>中的<code>&quot;dylib&quot;</code>位，否则构建本地代码会失败，并出现链接错误。</p>
<p>有了这些，我们就可以运行<code>cargo bench | tee before.txt</code>来编译和运行我们的基准测试了 <code>| tee before.txt</code>部分将从<code>cargo bench</code>中获取输出，并放入一个名为<code>before.txt</code>的文件。</p>
<pre><code>$ cargo bench | tee before.txt
    Finished release [optimized + debuginfo] target(s) in 0.0 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:     664,421 ns/iter (+/- 51,926)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>This also tells us where the binary lives, and we can run the benchmarks again,
but this time under our operating system's profiler. In my case, I'm running
Linux, so <a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code></a> is the profiler I'll use:</p>
<pre><code>$ perf record -g target/release/deps/bench-8474091a05cfa2d9 --bench
running 1 test
test universe_ticks ... bench:     635,061 ns/iter (+/- 38,764)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out

[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.178 MB perf.data (2349 samples) ]
</code></pre>
<p>用 <code>perf report </code> 加载配置文件显示，我们所有的时间都花在了 <code>Universe::tick</code> 上，正如预期：</p>
<p><a href="game-of-life/../images/game-of-life/bench-perf-report.png"><img src="game-of-life/../images/game-of-life/bench-perf-report.png" alt="Screenshot of perf report" /></a></p>
<p>如果你按下<code>a</code>，<code>perf</code> 将注解函数中的哪些指令正在花费时间：</p>
<p><a href="game-of-life/../images/game-of-life/bench-perf-annotate.png"><img src="game-of-life/../images/game-of-life/bench-perf-annotate.png" alt="Screenshot of perf's instruction annotation" /></a></p>
<p>这告诉我们，26.67%的时间花在相邻单元格的数值相加上，23.41%的时间花在获取相邻的列索引上，另外15.42%的时间花在获取相邻的行索引上。在这前三个最昂贵的指令中，第二和第三条都是昂贵的<code>div</code>指令。这些<code>div</code>实现了<code>Universe::live_neighbor_count</code>中的模数索引逻辑。</p>
<p>回顾一下<code>wasm-game-of-life/src/lib.rs</code>中的<code>live_neighbor_count</code>定义:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;
    for delta_row in [self.height - 1, 0, 1].iter().cloned() {
        for delta_col in [self.width - 1, 0, 1].iter().cloned() {
            if delta_row == 0 &amp;&amp; delta_col == 0 {
                continue;
            }

            let neighbor_row = (row + delta_row) % self.height;
            let neighbor_col = (column + delta_col) % self.width;
            let idx = self.get_index(neighbor_row, neighbor_col);
            count += self.cells[idx] as u8;
        }
    }
    count
}
<span class="boring">}
</span></code></pre></pre>
<p>我们使用模数的原因是为了避免在第一或最后一行或一列的边缘情况下用<code>if</code>分支使代码变得混乱。但是，即使在最常见的情况下，我们也要付出<code>div</code>指令的代价，当<code>row</code>和<code>column</code>都不在宇宙的边缘，它们不需要模数包装处理。相反，如果我们使用<code>if</code>s来处理边缘情况，并解开这个循环，分支<em>应该</em>被CPU的分支预测器很好地预测到。</p>
<p>让我们这样重写<code>live_neighbor_count</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn live_neighbor_count(&amp;self, row: u32, column: u32) -&gt; u8 {
    let mut count = 0;

    let north = if row == 0 {
        self.height - 1
    } else {
        row - 1
    };

    let south = if row == self.height - 1 {
        0
    } else {
        row + 1
    };

    let west = if column == 0 {
        self.width - 1
    } else {
        column - 1
    };

    let east = if column == self.width - 1 {
        0
    } else {
        column + 1
    };

    let nw = self.get_index(north, west);
    count += self.cells[nw] as u8;

    let n = self.get_index(north, column);
    count += self.cells[n] as u8;

    let ne = self.get_index(north, east);
    count += self.cells[ne] as u8;

    let w = self.get_index(row, west);
    count += self.cells[w] as u8;

    let e = self.get_index(row, east);
    count += self.cells[e] as u8;

    let sw = self.get_index(south, west);
    count += self.cells[sw] as u8;

    let s = self.get_index(south, column);
    count += self.cells[s] as u8;

    let se = self.get_index(south, east);
    count += self.cells[se] as u8;

    count
}
<span class="boring">}
</span></code></pre></pre>
<p>现在让我们再运行一次基准测试! 这次把它输出到<code>after.txt</code>。</p>
<pre><code>$ cargo bench | tee after.txt
   Compiling wasm_game_of_life v0.1.0 (file:///home/fitzgen/wasm_game_of_life)
    Finished release [optimized + debuginfo] target(s) in 0.82 secs
     Running target/release/deps/wasm_game_of_life-91574dfbe2b5a124

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/release/deps/bench-8474091a05cfa2d9

running 1 test
test universe_ticks ... bench:      87,258 ns/iter (+/- 14,632)

test result: ok. 0 passed; 0 failed; 0 ignored; 1 measured; 0 filtered out
</code></pre>
<p>这看起来好了很多! 我们可以通过<code>benchcmp</code>工具和我们之前创建的两个文本文件看到它有多好：</p>
<pre><code>$ cargo benchcmp before.txt after.txt
 name            before.txt ns/iter  after.txt ns/iter  diff ns/iter   diff %  speedup
 universe_ticks  664,421             87,258                 -577,163  -86.87%   x 7.61
</code></pre>
<p>哇！7.61倍的速度</p>
<p>WebAssembly有意与常见的硬件架构紧密映射，但我们确实需要确保这种本地代码的速度也能转化为WebAssembly的速度。</p>
<p>让我们用<code>wasm-pack build</code>重建<code>.wasm</code>并刷新[http://localhost:8080/]（http://localhost:8080/）。在我的机器上，该页面再次以每秒60帧的速度运行，用浏览器的剖析器记录另一个剖析，发现每个动画帧大约需要10毫秒。</p>
<p>成功了!</p>
<p><a href="game-of-life/../images/game-of-life/waterfall-after-branches-and-unrolling.png"><img src="game-of-life/../images/game-of-life/waterfall-after-branches-and-unrolling.png" alt="Screenshot of a waterfall view of rendering a frame after replacing modulos with branches" /></a></p>
<h2 id="练习-5"><a class="header" href="#练习-5">练习</a></h2>
<ul>
<li>
<p>在这一点上，加快<code>Universe::tick</code>的下一个最低的目标是取消分配和释放。实现单元格的双重缓冲，即<code>Universe</code>维护两个向量，不释放其中任何一个，并且不在<code>tick</code>中分配新的缓冲。</p>
</li>
<li>
<p>实现 &quot;实现生命 &quot;一章中的另一种基于delta的设计，Rust代码将改变状态的单元格的列表返回给JavaScript。这是否使渲染到<code>&lt;canvas&gt;</code>的速度更快？你能实现这种设计而不在每次勾选时分配一个新的deltas列表吗？</p>
</li>
<li>
<p>正如我们的分析所显示的，2D <code>&lt;canvas&gt;</code>的渲染不是特别快。用<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a>渲染器取代2D画布渲染器。WebGL版本的速度有多大？在WebGL渲染成为瓶颈之前，你能把宇宙做得多大？</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="缩小wasm-大小"><a class="header" href="#缩小wasm-大小">缩小<code>.wasm</code> 大小</a></h1>
<p>对于我们通过网络发送给客户端的 <code>.wasm</code> 二进制文件，例如我们的 Game of Life Web 应用程序，我们希望关注代码大小。 我们的 <code>.wasm</code> 越小，我们的页面加载速度就越快，我们的用户就越开心。</p>
<h2 id="我们可以通过构建配置获得我们的-game-of-life-wasm-二进制文件有多小"><a class="header" href="#我们可以通过构建配置获得我们的-game-of-life-wasm-二进制文件有多小">我们可以通过构建配置获得我们的 Game of Life <code>.wasm</code> 二进制文件有多小？</a></h2>
<p><a href="game-of-life/../reference/code-size.html#%E9%92%88%E5%AF%B9%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E6%9E%84%E5%BB%BA">花点时间查看我们可以调整的构建配置选项以获得更小的 <code>.wasm</code> 代码大小。</a></p>
<p>使用默认的发布构建配置（没有调试符号），我们的 WebAssembly 二进制文件是 29,410 字节： </p>
<pre><code>$ wc -c pkg/wasm_game_of_life_bg.wasm
29410 pkg/wasm_game_of_life_bg.wasm
</code></pre>
<p>在启用 LTO、设置 <code>opt-level = &quot;z&quot;</code> 并运行 <code>wasm-opt -Oz</code> 后，生成的 <code>.wasm</code> 二进制文件缩小到只有 17,317 个字节： </p>
<pre><code>$ wc -c pkg/wasm_game_of_life_bg.wasm
17317 pkg/wasm_game_of_life_bg.wasm
</code></pre>
<p>如果我们用 <code>gzip</code> 压缩它（几乎每个 HTTP 服务器都会这样做），我们会减少到 9,045 字节！ </p>
<pre><code>$ gzip -9 &lt; pkg/wasm_game_of_life_bg.wasm | wc -c
9045
</code></pre>
<h2 id="练习-6"><a class="header" href="#练习-6">练习</a></h2>
<ul>
<li>
<p>使用 <a href="game-of-life/../reference/code-size.html#%E4%BD%BF%E7%94%A8-wasm-snip-%E5%B7%A5%E5%85%B7"><code>wasm-snip</code> 工具</a> 从我们的生命游戏的 <code>.wasm</code> 二进制文件中删除恐慌的基础设施功能。 它节省了多少字节？</p>
</li>
<li>
<p>使用和不使用 <a href="https://github.com/rustwasm/wee_alloc"><code>wee_alloc</code> 作为其全局分配器</a> 构建我们的游戏生命箱。 我们克隆来启动这个项目的 <code>rustwasm/wasm-pack-template</code> 模板有一个“wee_alloc”货物特性，您可以通过将其添加到 <code>wasm-game-of-life/Cargo.toml</code> 的 <code>[features]</code> 部分中的 <code>default</code> 键来启用：</p>
<pre><code class="language-toml">[features]
default = [&quot;wee_alloc&quot;]
</code></pre>
<p>使用 <code>wee_alloc</code> 可以减少 <code>.wasm</code> 二进制文件的大小吗？ </p>
</li>
<li>
<p>我们只实例化一个 <code>Universe</code>，因此我们可以导出操作单个 <code>static mut</code> 全局实例的操作，而不是提供构造函数。 如果这个全局实例也使用了前面章节中讨论过的双缓冲技术，我们可以使这些缓冲区也成为 <code>static mut</code> 全局变量。 这从我们的生命游戏实现中删除了所有动态分配，我们可以使它成为一个不包含分配器的 <code>#![no_std]</code> crate。 通过完全删除分配器依赖，从 <code>.wasm</code> 中删除了多少大小？ </p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="发布到-npm"><a class="header" href="#发布到-npm">发布到 npm</a></h1>
<p>现在我们有了一个有效的、快速的、<em>和</em>小的 <code>wasm-game-of-life</code> 包，我们可以将它发布到 npm 以便其他 JavaScript 开发人员可以重用它，如果他们需要一个现成的游戏 生活执行。</p>
<h2 id="先决条件"><a class="header" href="#先决条件">先决条件</a></h2>
<p>首先，<a href="https://www.npmjs.com/signup">确保您有一个 npm 帐户</a>。</p>
<p>其次，通过运行以下命令确保您在本地登录到您的帐户： </p>
<pre><code>wasm-pack login
</code></pre>
<h2 id="发布"><a class="header" href="#发布">发布</a></h2>
<p>通过在 <code>wasm-game-of-life</code> 目录中运行 <code>wasm-pack</code>，确保 <code>wasm-game-of-life/pkg</code> 构建是最新的： </p>
<pre><code>wasm-pack build
</code></pre>
<p>现在花点时间查看一下 <code>wasm-game-of-life/pkg</code> 的内容，这就是我们下一步要发布到 npm 的内容！</p>
<p>准备好后，运行 <code>wasm-pack publish</code> 将包上传到 npm： </p>
<pre><code>wasm-pack publish
</code></pre>
<p>这就是发布到 npm 所需的全部内容！</p>
<p>...除了其他人也完成了本教程，因此在 npm 上使用了 <code>wasm-game-of-life</code> 名称，最后一个命令可能不起作用。</p>
<p>打开 <code>wasm-game-of-life/Cargo.toml</code> 并将您的用户名添加到 <code>name</code> 的末尾，以独特的方式消除包的歧义：</p>
<pre><code class="language-toml">[package]
name = &quot;wasm-game-of-life-my-username&quot;
</code></pre>
<p>然后，重建并再次发布：</p>
<pre><code>wasm-pack build
wasm-pack publish
</code></pre>
<p>这次应该可以了！</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="参考"><a class="header" href="#参考">参考</a></h1>
<p>本节包含 Rust 和 WebAssembly 开发的参考资料。 它的目的不是提供叙述，而是从头到尾阅读。 相反，每个小节都应该独立存在。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="你应该知道的crates"><a class="header" href="#你应该知道的crates">你应该知道的Crates</a></h1>
<p>这是您在进行 Rust 和 WebAssembly 开发时应该了解的很棒的 crate 的精选列表。 </p>
<p><a href="https://crates.io/categories/wasm">您还可以在 WebAssembly 类别中浏览所有发布到 crates.io 的 crate.</a></p>
<h2 id="与-javascript-和-dom-交互"><a class="header" href="#与-javascript-和-dom-交互">与 JavaScript 和 DOM 交互</a></h2>
<h3 id="wasm-bindgen--a-hrefhttpscratesiocrateswasm-bindgencratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgenrepositorya"><a class="header" href="#wasm-bindgen--a-hrefhttpscratesiocrateswasm-bindgencratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgenrepositorya"><code>wasm-bindgen</code> | <a href="https://crates.io/crates/wasm-bindgen">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen">repository</a></a></h3>
<p><code>wasm-bindgen</code> 促进了 Rust 和 JavaScript 之间的高级交互。 它允许将 JavaScript 内容导入 Rust 并将 Rust 内容导出到 JavaScript。 </p>
<h3 id="wasm-bindgen-futures--a-hrefhttpscratesiocrateswasm-bindgen-futurescratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesfuturesrepositorya"><a class="header" href="#wasm-bindgen-futures--a-hrefhttpscratesiocrateswasm-bindgen-futurescratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesfuturesrepositorya"><code>wasm-bindgen-futures</code> | <a href="https://crates.io/crates/wasm-bindgen-futures">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/futures">repository</a></a></h3>
<p><code>wasm-bindgen-futures</code> 是连接 JavaScript <code>Promise</code>s 和 Rust <code>Future</code>s 的桥梁。 它可以双向转换，在 Rust 中处理异步任务时很有用，并允许与 DOM 事件和 I/O 操作进行交互。</p>
<h3 id="js-sys--a-hrefhttpscratesiocratesjs-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesjs-sysrepositorya"><a class="header" href="#js-sys--a-hrefhttpscratesiocratesjs-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesjs-sysrepositorya"><code>js-sys</code> | <a href="https://crates.io/crates/js-sys">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/js-sys">repository</a></a></h3>
<p>所有 JavaScript 全局类型和方法的原始 <code>wasm-bindgen</code> 导入，例如 <code>Object</code>、<code>Function</code>、<code>eval</code> 等。这些 API 可以在所有标准 ECMAScript 环境中移植，而不仅仅是 Web，例如 Node.js。</p>
<h3 id="web-sys--a-hrefhttpscratesiocratesweb-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesweb-sysrepositorya"><a class="header" href="#web-sys--a-hrefhttpscratesiocratesweb-syscratesioa--a-hrefhttpsgithubcomrustwasmwasm-bindgentreemastercratesweb-sysrepositorya"><code>web-sys</code> | <a href="https://crates.io/crates/web-sys">crates.io</a> | <a href="https://github.com/rustwasm/wasm-bindgen/tree/master/crates/web-sys">repository</a></a></h3>
<p>所有 Web API 的原始 <code>wasm-bindgen</code> 导入，例如 DOM 操作、<code>setTimeout</code>、Web GL、Web Audio 等。</p>
<h2 id="错误报告和日志记录"><a class="header" href="#错误报告和日志记录">错误报告和日志记录</a></h2>
<h3 id="console_error_panic_hook--a-hrefhttpscratesiocratesconsole_error_panic_hookcratesioa--a-hrefhttpsgithubcomrustwasmconsole_error_panic_hookrepositorya"><a class="header" href="#console_error_panic_hook--a-hrefhttpscratesiocratesconsole_error_panic_hookcratesioa--a-hrefhttpsgithubcomrustwasmconsole_error_panic_hookrepositorya"><code>console_error_panic_hook</code> | <a href="https://crates.io/crates/console_error_panic_hook">crates.io</a> | <a href="https://github.com/rustwasm/console_error_panic_hook">repository</a></a></h3>
<p>这个 crate 允许你通过提供一个将 panic 消息转发到 <code>console.error</code> 的 panic 钩子来调试 <code>wasm32-unknown-unknown</code> 上的 panics。</p>
<h3 id="console_log--a-hrefhttpscratesiocratesconsole_logcratesioa--a-hrefhttpsgithubcomiamcodemakerconsole_logrepositorya"><a class="header" href="#console_log--a-hrefhttpscratesiocratesconsole_logcratesioa--a-hrefhttpsgithubcomiamcodemakerconsole_logrepositorya"><code>console_log</code> | <a href="https://crates.io/crates/console_log">crates.io</a> | <a href="https://github.com/iamcodemaker/console_log">repository</a></a></h3>
<p>此 crate 为 <a href="https://crates.io/crates/log">the <code>log</code> crate</a> 提供后端，将记录的消息路由到 devtools 控制台。</p>
<h2 id="动态分配"><a class="header" href="#动态分配">动态分配</a></h2>
<h3 id="wee_alloc--a-hrefhttpscratesiocrateswee_alloccratesioa--a-hrefhttpsgithubcomrustwasmwee_allocrepositorya"><a class="header" href="#wee_alloc--a-hrefhttpscratesiocrateswee_alloccratesioa--a-hrefhttpsgithubcomrustwasmwee_allocrepositorya"><code>wee_alloc</code> | <a href="https://crates.io/crates/wee_alloc">crates.io</a> | <a href="https://github.com/rustwasm/wee_alloc">repository</a></a></h3>
<p><strong>W</strong>asm-<strong>E</strong>nabled，<strong>E</strong>lfin 分配器。 当代码大小比分配性能更受关注时，一个小的（~1K 未压缩的<code>.wasm</code>）分配器实现。 </p>
<h2 id="解析和生成-wasm-二进制文件"><a class="header" href="#解析和生成-wasm-二进制文件">解析和生成 <code>.wasm</code> 二进制文件</a></h2>
<h3 id="parity-wasm--a-hrefhttpscratesiocratesparity-wasmcratesioa--a-hrefhttpsgithubcomparitytechparity-wasmrepositorya"><a class="header" href="#parity-wasm--a-hrefhttpscratesiocratesparity-wasmcratesioa--a-hrefhttpsgithubcomparitytechparity-wasmrepositorya"><code>parity-wasm</code> | <a href="https://crates.io/crates/parity-wasm">crates.io</a> | <a href="https://github.com/paritytech/parity-wasm">repository</a></a></h3>
<p>用于序列化、反序列化和构建 <code>.wasm</code> 二进制文件的低级 WebAssembly 格式库。 对众所周知的自定义部分的良好支持，例如 &quot;names&quot; 部分和 &quot;reloc.WHATEVER&quot; 部分。 </p>
<h3 id="wasmparser--a-hrefhttpscratesiocrateswasmparsercratesioa--a-hrefhttpsgithubcomyurydelendikwasmparserrsrepositorya"><a class="header" href="#wasmparser--a-hrefhttpscratesiocrateswasmparsercratesioa--a-hrefhttpsgithubcomyurydelendikwasmparserrsrepositorya"><code>wasmparser</code> | <a href="https://crates.io/crates/wasmparser">crates.io</a> | <a href="https://github.com/yurydelendik/wasmparser.rs">repository</a></a></h3>
<p>一个简单的、事件驱动的库，用于解析 WebAssembly 二进制文件。 提供每个已解析事物的字节偏移量，例如在解释 relocs 时这是必需的。</p>
<h2 id="解释和编译-webassembly"><a class="header" href="#解释和编译-webassembly">解释和编译 WebAssembly</a></h2>
<h3 id="wasmi--a-hrefhttpscratesiocrateswasmicratesioa--a-hrefhttpsgithubcomparitytechwasmirepositorya"><a class="header" href="#wasmi--a-hrefhttpscratesiocrateswasmicratesioa--a-hrefhttpsgithubcomparitytechwasmirepositorya"><code>wasmi</code> | <a href="https://crates.io/crates/wasmi">crates.io</a> | <a href="https://github.com/paritytech/wasmi">repository</a></a></h3>
<p>Parity 的可嵌入 WebAssembly 解释器。</p>
<h3 id="cranelift-wasm--a-hrefhttpscratesiocratescranelift-wasmcratesioa--a-hrefhttpsgithubcombytecodealliancewasmtimetreemastercraneliftrepositorya"><a class="header" href="#cranelift-wasm--a-hrefhttpscratesiocratescranelift-wasmcratesioa--a-hrefhttpsgithubcombytecodealliancewasmtimetreemastercraneliftrepositorya"><code>cranelift-wasm</code> | <a href="https://crates.io/crates/cranelift-wasm">crates.io</a> | <a href="https://github.com/bytecodealliance/wasmtime/tree/master/cranelift">repository</a></a></h3>
<p>将 WebAssembly 编译为本机主机的机器代码。 Cranelift (né Cretonne) 代码生成器项目的一部分。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="你应该知道的工具"><a class="header" href="#你应该知道的工具">你应该知道的工具</a></h1>
<p>这是在进行 Rust 和 WebAssembly 开发时你应该知道的一些很棒的工具的精选列表。</p>
<h2 id="开发构建和工作流编排"><a class="header" href="#开发构建和工作流编排">开发、构建和工作流编排</a></h2>
<h3 id="wasm-pack--a-hrefhttpsgithubcomrustwasmwasm-packrepositorya"><a class="header" href="#wasm-pack--a-hrefhttpsgithubcomrustwasmwasm-packrepositorya"><code>wasm-pack</code> | <a href="https://github.com/rustwasm/wasm-pack">repository</a></a></h3>
<p><code>wasm-pack</code> 旨在成为构建和使用 Rust 生成的 WebAssembly 的一站式商店，您希望与 JavaScript、Web 或 Node.js 进行互操作。 <code>wasm-pack</code> 可帮助您构建 Rust 生成的 WebAssembly 并将其发布到 npm 仓库，以便与您已经使用的工作流中的任何其他 JavaScript 包一起使用。 </p>
<h2 id="优化和操作-wasm-二进制文件"><a class="header" href="#优化和操作-wasm-二进制文件">优化和操作 <code>.wasm</code> 二进制文件</a></h2>
<h3 id="wasm-opt--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><a class="header" href="#wasm-opt--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><code>wasm-opt</code> | <a href="https://github.com/WebAssembly/binaryen">repository</a></a></h3>
<p><code>wasm-opt</code> 工具将 WebAssembly 读取为输入，对其运行转换、优化和/或检测传递，然后将转换后的 WebAssembly 作为输出发出。 在 LLVM 通过 <code>rustc</code> 生成的 <code>.wasm</code> 二进制文件上运行它通常会创建更小且执行速度更快的 <code>.wasm</code> 二进制文件。 这个工具是<code>binaryen</code> 项目的一部分。 </p>
<h3 id="wasm2js--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><a class="header" href="#wasm2js--a-hrefhttpsgithubcomwebassemblybinaryenrepositorya"><code>wasm2js</code> | <a href="https://github.com/WebAssembly/binaryen">repository</a></a></h3>
<p><code>wasm2js</code> 工具将 WebAssembly 编译成“几乎是 asm.js”。 这非常适合支持没有 WebAssembly 实现的浏览器，例如 Internet Explorer 11。这个工具是 <code>binaryen</code> 项目的一部分。</p>
<h3 id="wasm-gc--a-hrefhttpsgithubcomalexcrichtonwasm-gcrepositorya"><a class="header" href="#wasm-gc--a-hrefhttpsgithubcomalexcrichtonwasm-gcrepositorya"><code>wasm-gc</code> | <a href="https://github.com/alexcrichton/wasm-gc">repository</a></a></h3>
<p>一个垃圾收集 WebAssembly 模块并删除所有不需要的导出、导入、函数等的小工具。这实际上是 WebAssembly 的一个 <code>--gc-sections</code> 链接器标志。</p>
<p>由于两个原因，您通常不需要自己使用此工具：</p>
<ol>
<li><code>rustc</code> 现在有一个足够新的 <code>lld</code> 版本，它支持 WebAssembly 的 <code>--gc-sections</code> 标志。 这会自动为 LTO 构建启用。</li>
<li><code>wasm-bindgen</code> CLI 工具会自动为你运行 <code>wasm-gc</code>。</li>
</ol>
<h3 id="wasm-snip--a-hrefhttpsgithubcomrustwasmwasm-sniprepositorya"><a class="header" href="#wasm-snip--a-hrefhttpsgithubcomrustwasmwasm-sniprepositorya"><code>wasm-snip</code> | <a href="https://github.com/rustwasm/wasm-snip">repository</a></a></h3>
<p><code>wasm-snip</code> 用 <code>unreachable</code> 指令替换了 WebAssembly 函数的主体。</p>
<p>也许您知道某些函数在运行时永远不会被调用，但是编译器无法在编译时证明这一点？ 剪吧！ 然后再次运行<code>wasm-gc</code>，它传递调用的所有函数（在运行时也永远不会被调用）也将被删除。</p>
<p>这对于在非调试生产版本中强行删除 Rust 的恐慌基础架构很有用。</p>
<h2 id="检查-wasm-二进制文件"><a class="header" href="#检查-wasm-二进制文件">检查 <code>.wasm</code> 二进制文件</a></h2>
<h3 id="twiggy--a-hrefhttpsgithubcomrustwasmtwiggyrepositorya"><a class="header" href="#twiggy--a-hrefhttpsgithubcomrustwasmtwiggyrepositorya"><code>twiggy</code> | <a href="https://github.com/rustwasm/twiggy">repository</a></a></h3>
<p><code>twiggy</code> 是 <code>.wasm</code> 二进制文件的代码大小分析器。 它分析二进制的调用图来回答以下问题：</p>
<ul>
<li>为什么这个函数首先包含在二进制文件中？ 即 哪些导出的函数正在传递调用它？</li>
<li>这个函数的保留大小是多少？ 即 如果我删除它以及删除后成为死代码的所有函数，将节省多少空间。</li>
</ul>
<p>使用 <code>twiggy</code> 使你的二进制文件变得苗条！</p>
<h3 id="wasm-objdump--a-hrefhttpsgithubcomwebassemblywabtrepositorya"><a class="header" href="#wasm-objdump--a-hrefhttpsgithubcomwebassemblywabtrepositorya"><code>wasm-objdump</code> | <a href="https://github.com/WebAssembly/wabt">repository</a></a></h3>
<p>打印有关 <code>.wasm</code> 二进制文件及其每个部分的低级详细信息。 还支持反汇编成 WAT 文本格式。 它就像<code>objdump</code>，但用于WebAssembly。 这是 WABT 项目的一部分。</p>
<h3 id="wasm-nm--a-hrefhttpsgithubcomfitzgenwasm-nmrepositorya"><a class="header" href="#wasm-nm--a-hrefhttpsgithubcomfitzgenwasm-nmrepositorya"><code>wasm-nm</code> | <a href="https://github.com/fitzgen/wasm-nm">repository</a></a></h3>
<p>列出在 <code>.wasm</code> 二进制文件中定义的导入、导出和私有函数符号。 它就像 <code>nm</code> 但对于 WebAssembly。 </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目模板"><a class="header" href="#项目模板">项目模板</a></h1>
<p>Rust 和 WebAssembly 工作组策划和维护各种项目模板，以帮助您启动新项目并开始运行。</p>
<h2 id="wasm-pack-template"><a class="header" href="#wasm-pack-template"><code>wasm-pack-template</code></a></h2>
<p><a href="https://github.com/rustwasm/wasm-pack-template">此模板</a> 用于启动 Rust 和 WebAssembly 项目，与 <a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a> 一起使用。</p>
<p>使用 <code>cargo generate</code> 来克隆这个项目模板：</p>
<pre><code>cargo install cargo-generate
cargo generate --git https://github.com/rustwasm/wasm-pack-template.git
</code></pre>
<h2 id="create-wasm-app"><a class="header" href="#create-wasm-app"><code>create-wasm-app</code></a></h2>
<p><a href="https://github.com/rustwasm/create-wasm-app">此模板</a> 适用于使用来自 npm 的包的 JavaScript 项目，这些包是使用 <a href="https://github.com/rustwasm/wasm-pack"><code>wasm-pack</code></a> 从 Rust 创建的。</p>
<p>与 <code>npm init</code> 一起使用：</p>
<pre><code>mkdir my-project
cd my-project/
npm init wasm-app
</code></pre>
<p>该模板通常与 <code>wasm-pack-template</code> 一起使用，其中 <code>wasm-pack-template</code> 项目通过 <code>npm link</code> 安装在本地，并作为 <code>create-wasm-app</code> 项目的依赖项引入。</p>
<h2 id="rust-webpack-template"><a class="header" href="#rust-webpack-template"><code>rust-webpack-template</code></a></h2>
<p><a href="https://github.com/rustwasm/rust-webpack-template">此模板</a> 预配置了所有样板，用于将 Rust 编译为 WebAssembly，并使用 Webpack 的 <a href="https://github.com/wasm-tool/rust-loader/"><code>rust-loader</code></a> 将其直接挂接到 Webpack 构建管道中。</p>
<p>与 <code>npm init</code> 一起使用：</p>
<pre><code>mkdir my-project
cd my-project/
npm init rust-webpack
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="调试-rust-生成的-webassembly"><a class="header" href="#调试-rust-生成的-webassembly">调试 Rust 生成的 WebAssembly</a></h1>
<p>本节包含调试 Rust 生成的 WebAssembly 的技巧。</p>
<h2 id="使用调试符号构建"><a class="header" href="#使用调试符号构建">使用调试符号构建</a></h2>
<blockquote>
<p>⚡ 调试时，请始终确保使用调试符号进行构建！</p>
</blockquote>
<p>如果你没有启用调试符号，那么在编译的 <code>.wasm</code> 二进制文件中将不会出现 <code>&quot;name&quot;</code> 自定义部分，并且堆栈跟踪将具有类似 <code>wasm-function[42]</code> 的函数名称，而不是函数的 Rust 名称，比如 <code>wasm_game_of_life::Universe::live_neighbor_count</code>。</p>
<p>当使用 &quot;debug&quot; 构建（又名 <code>wasm-pack build --debug</code> 或 <code>cargo build</code>）时，默认启用调试符号。</p>
<p>对于 &quot;release&quot; 版本，默认情况下不启用调试符号。 要启用调试符号，请确保在 <code>Cargo.toml</code> 的 <code>[profile.release]</code> 部分中设置 <code>debug = true</code>：</p>
<pre><code class="language-toml">[profile.release]
debug = true
</code></pre>
<h2 id="使用-console-api-进行日志记录"><a class="header" href="#使用-console-api-进行日志记录">使用 <code>console</code> API 进行日志记录</a></h2>
<p>日志记录是我们拥有的最有效的工具之一，用于证明和反驳关于我们的程序为什么有错误的假设。 在 Web 上，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/log"><code>console.log</code> 功能</a> 是将消息记录到浏览器的开发者工具控制台的方式 .</p>
<p>我们可以使用 <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html">the <code>web-sys</code> crate</a> 来访问 <code>console</code> 日志功能:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

web_sys::console::log_1(&amp;&quot;Hello, world!&quot;.into());
<span class="boring">}
</span></code></pre></pre>
<p>或者，<a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/error"><code>console.error</code> 函数</a> 具有与 <code>console.log</code> 相同的签名，但开发人员工具 当使用 <code>console.error</code> 时，往往还会在记录的消息旁边捕获和显示堆栈跟踪。</p>
<h3 id="references"><a class="header" href="#references">References</a></h3>
<ul>
<li>使用 <code>console.log</code> 和 <code>web-sys</code> crate:
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log.html"><code>web_sys::console::log</code> 取一个数组的值来记录</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_1.html"><code>web_sys::console::log_1</code> 记录一个单一的值</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.log_2.html"><code>web_sys::console::log_2</code> 记录了两个值</a></li>
<li>Etc...</li>
</ul>
</li>
<li>使用 <code>console.error</code> 与 <code>web-sys</code> crate:
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error.html"><code>web_sys::console::error</code> 取一个数组的值来记录</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_1.html"><code>web_sys::console::error_1</code> 记录一个单一的值</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.error_2.html"><code>web_sys::console::error_2</code> 记录了两个值</a></li>
<li>Etc...</li>
</ul>
</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console">MDN上的 <code>console</code> 对象</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Web_Console">火狐浏览器开发者工具 - 网络控制台</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/console">微软EDGE开发工具 - 控制台</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/console/get-started">开始使用 Chrome DevTools 控制台</a></li>
</ul>
<h2 id="记录-panics"><a class="header" href="#记录-panics">记录 Panics</a></h2>
<p><a href="https://github.com/rustwasm/console_error_panic_hook"><code>console_error_panic_hook</code> crate 通过 <code>console.error</code> 将意外的恐慌记录到开发者控制台。</a> 而不是获得神秘的、难以调试的 <code>RuntimeError: unreachable execution</code> 错误消息，这给你 Rust 的格式化 恐慌信息。</p>
<p>您需要做的就是通过在初始化函数或公共代码路径中调用 <code>console_error_panic_hook::set_once()</code> 来安装钩子： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[wasm_bindgen]
pub fn init_panic_hook() {
    console_error_panic_hook::set_once();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="使用调试器"><a class="header" href="#使用调试器">使用调试器</a></h2>
<p>不幸的是，WebAssembly 的调试故事仍然不成熟。 在大多数 Unix 系统上，<a href="http://dwarfstd.org/">DWARF</a> 用于对调试器提供正在运行的程序的源代码级检查所需的信息进行编码。 有一种替代格式可以对 Windows 上的类似信息进行编码。 目前，没有 WebAssembly 的等价物。 因此，调试器目前提供的实用程序有限，我们最终会逐步执行编译器发出的原始 WebAssembly 指令，而不是我们编写的 Rust 源文本。</p>
<blockquote>
<p>有一个<a href="https://github.com/WebAssembly/debugging">W3C WebAssembly 小组调试子章程</a>，所以期待这个故事在未来得到改进！ </p>
</blockquote>
<p>尽管如此，调试器对于检查与我们的 WebAssembly 交互的 JavaScript 和检查原始 wasm 状态仍然很有用。</p>
<h3 id="参考-1"><a class="header" href="#参考-1">参考</a></h3>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Debugger">Firefox 开发者工具 — 调试器</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/debugger">Microsoft Edge 开发者工具 — 调试器</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/javascript/">在 Chrome DevTools 中开始调试 JavaScript</a></li>
</ul>
<h2 id="首先避免调试-webassembly"><a class="header" href="#首先避免调试-webassembly">首先避免调试 WebAssembly</a></h2>
<p>如果该错误特定于与 JavaScript 或 Web API 的交互，则 <a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html">使用 <code>wasm-bindgen-test</code> 编写测试。</a></p>
<p>如果错误<em>不</em>涉及与 JavaScript 或 Web API 的交互，那么尝试将其复制为普通的 Rust <code>#[test]</code> 函数，您可以在调试时利用操作系统成熟的本机工具。 使用像 <a href="https://crates.io/crates/quickcheck"><code>quickcheck</code></a> 和它的测试用例收缩器这样的测试箱来机械地减少测试用例。 最终，如果您可以在不需要与 JavaScript 交互的较小测试用例中隔离它们，您将更容易找到和修复错误。</p>
<p>请注意，为了在没有编译器和链接器错误的情况下运行本机 <code>#[test]</code>，您需要确保 <code>&quot;rlib&quot;</code> 包含在 <code>Cargo. toml</code> 文件。</p>
<pre><code class="language-toml">[lib]
crate-type [&quot;cdylib&quot;, &quot;rlib&quot;]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="时间分析-1"><a class="header" href="#时间分析-1">时间分析</a></h1>
<p>本节介绍如何使用 Rust 和 WebAssembly 分析网页，其目标是提高吞吐量或延迟。</p>
<blockquote>
<p>⚡ 始终确保在分析时使用优化的构建！ <code>wasm-pack build</code> 将默认进行优化构建。 </p>
</blockquote>
<h2 id="可用工具"><a class="header" href="#可用工具">可用工具</a></h2>
<h3 id="windowperformancenow-计时器"><a class="header" href="#windowperformancenow-计时器"><code>window.performance.now()</code> 计时器</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/now"><code>performance.now()</code> 函数</a> 返回自网页加载以来以毫秒为单位的单调时间戳。</p>
<p>调用 <code>performance.now</code> 的开销很小，因此我们可以从中创建简单、细粒度的测量，而不会扭曲系统其余部分的性能并对我们的测量造成偏差。</p>
<p>我们可以用它来为各种操作计时，我们可以通过<a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html"><code>web-sys</code> crate</a> 访问<code>window.performance.now()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern crate web_sys;

fn now() -&gt; f64 {
    web_sys::window()
        .expect(&quot;should have a Window&quot;)
        .performance()
        .expect(&quot;should have a Performance&quot;)
        .now()
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/fn.window.html">The <code>web_sys::window</code> function</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.performance">The <code>web_sys::Window::performance</code> method</a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Performance.html#method.now">The <code>web_sys::Performance::now</code> method</a></li>
</ul>
<h3 id="开发者工具分析器"><a class="header" href="#开发者工具分析器">开发者工具分析器</a></h3>
<p>所有 Web 浏览器的内置开发人员工具都包含一个分析器。 这些分析器通过调用树和火焰图等常见类型的可视化显示哪些函数占用的时间最多。</p>
<p>如果您 <a href="reference/./debugging.html#building-with-debug-symbols">使用调试符号构建</a> 以便“名称”自定义部分包含在 wasm 二进制文件中，那么这些分析器应该显示 Rust 函数名称，而不是像 <code>wasm-function[123]</code> 这样不透明的东西。</p>
<p>请注意，这些分析器<em>不会</em>显示内联函数，并且由于 Rust 和 LLVM 非常依赖内联，因此结果可能仍然有点令人困惑。</p>
<p><a href="reference/../images/game-of-life/profiler-with-rust-names.png"><img src="reference/../images/game-of-life/profiler-with-rust-names.png" alt="Screenshot of profiler with Rust symbols" /></a></p>
<h4 id="资源"><a class="header" href="#资源">资源</a></h4>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Tools/Performance">Firefox 开发者工具——性能</a></li>
<li><a href="https://docs.microsoft.com/en-us/microsoft-edge/devtools-guide/performance">Microsoft Edge 开发者工具——性能</a></li>
<li><a href="https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution">Chrome DevTools JavaScript Profiler</a></li>
</ul>
<h3 id="consoletime-和-consoletimeend-函数"><a class="header" href="#consoletime-和-consoletimeend-函数"><code>console.time</code> 和 <code>console.timeEnd</code> 函数</a></h3>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Console/time"><code>console.time</code> 和 <code>console.timeEnd</code> 函数</a> 允许您将命名操作的时间记录到浏览器的开发者工具控制台。 你在操作开始时调用<code>console.time(&quot;some operation&quot;)</code>，在操作结束时调用<code>console.timeEnd(&quot;some operation&quot;)</code>。 命名操作的字符串标签是可选的。</p>
<p>您可以直接通过 <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/index.html"><code>web-sys</code> crate</a> 使用这些函数：</p>
<ul>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_with_label.html"><code>web_sys::console::time_with_label(&quot;some operation&quot;)</code></a></li>
<li><a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/console/fn.time_end_with_label.html"><code>web_sys::console::time_end_with_label(&quot;some operation&quot;)</code></a></li>
</ul>
<p>这是浏览器控制台中 <code>console.time</code> 日志的屏幕截图：</p>
<p><a href="reference/../images/game-of-life/console-time.png"><img src="reference/../images/game-of-life/console-time.png" alt="Screenshot of console.time logs" /></a></p>
<p>此外，<code>console.time</code> 和 <code>console.timeEnd</code> 日志将显示在浏览器分析器的“时间轴”或“瀑布”视图中： </p>
<p><a href="reference/../images/game-of-life/console-time-in-profiler.png"><img src="reference/../images/game-of-life/console-time-in-profiler.png" alt="Screenshot of console.time logs" /></a></p>
<h3 id="在本机代码中使用-bench"><a class="header" href="#在本机代码中使用-bench">在本机代码中使用 <code>#[bench]</code></a></h3>
<p>与我们通常可以通过编写 <code>#[test]</code>s 而不是在 Web 上调试来利用操作系统的本机代码调试工具一样，我们可以通过编写 <code>#[bench]</code> 函数来利用操作系统的本机代码分析工具。</p>
<p>在 crate 的 <code>benches</code> 子目录中写入你的基准。 确保你的 <code>crate-type</code> 包含 <code>&quot;rlib&quot;</code>，否则 bench 二进制文件将无法链接你的主库。</p>
<p>然而！ 在投入大量精力进行本机代码分析之前，请确保您知道瓶颈在 WebAssembly 中！ 使用浏览器的分析器来确认这一点，否则您可能会浪费时间优化不热门的代码。 </p>
<h4 id="资源-1"><a class="header" href="#资源-1">资源</a></h4>
<ul>
<li><a href="http://www.brendangregg.com/perf.html">在Linux上使用<code>perf</code>剖析器</a></li>
<li><a href="https://help.apple.com/instruments/mac/current/">在MacOS上使用Instruments.app分析器</a></li>
<li><a href="https://software.intel.com/en-us/vtune">VTune剖析器支持Windows和Linux</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="缩小wasm-代码大小"><a class="header" href="#缩小wasm-代码大小">缩小<code>.wasm</code> 代码大小</a></h1>
<p>本节将教你如何优化你的 <code>.wasm</code> 构建以减少代码大小，以及如何识别更改 Rust 源代码的机会，以便发出更少的 <code>.wasm</code> 代码。</p>
<h2 id="为什么要关心代码大小"><a class="header" href="#为什么要关心代码大小">为什么要关心代码大小？</a></h2>
<p>当通过网络提供 <code>.wasm</code> 文件时，它越小，客户端下载它的速度就越快。更快的 <code>.wasm</code> 下载会导致更快的页面加载时间，从而带来更快乐的用户。</p>
<p>但是，重要的是要记住，尽管代码大小可能不是您感兴趣的最终指标，而是更模糊且难以衡量的指标，例如“首次交互时间”。虽然代码大小在这个衡量中扮演着重要的角色（如果你还没有所有的代码，就什么也做不了！）它不是唯一的因素。</p>
<p>WebAssembly 通常提供给使用 gzip 压缩的用户，因此您需要确保比较 gzip 大小的差异，以便通过网络传输时间。还要记住，WebAssembly 二进制格式非常适合 gzip 压缩，通常可以减少 50% 以上的大小。</p>
<p>此外，WebAssembly 的二进制格式针对非常快速的解析和处理进行了优化。现在的浏览器有“基线编译器”，它解析 WebAssembly 并以最快的速度发出已编译的代码，因为它可以通过网络传入。这意味着<a href="https://hacks.mozilla.org/2018/01/making-webassembly-even-faster-firefoxs-new-streaming-and-tiering-compiler/">如果你正在使用<code>instantiateStreaming</code></a> Web 请求完成后，WebAssembly 模块可能已经准备就绪。另一方面，JavaScript 通常需要更长的时间，不仅要解析，还要跟上 JIT 编译等的速度。</p>
<p>最后，请记住，WebAssembly 在执行速度方面也比 JavaScript 优化得多。您需要确保测量 JavaScript 和 WebAssembly 之间的运行时比较，以将其考虑到代码大小的重要性。</p>
<p>如果你的 <code>.wasm</code> 文件比预期的大，基本上不要立即沮丧！代码大小最终可能只是端到端故事中的众多因素之一。只看代码大小的 JavaScript 和 WebAssembly 之间的比较缺少树的森林。</p>
<h2 id="针对代码大小优化构建"><a class="header" href="#针对代码大小优化构建">针对代码大小优化构建</a></h2>
<p>有很多配置选项可以用来让<code>rustc</code>制作更小的<code>.wasm</code>二进制文件。在某些情况下，我们用较长的编译时间来换取较小的`.wasm'尺寸。在其他情况下，我们要用WebAssembly的运行速度来换取更小的代码大小。我们应该认识到每个选项的权衡，在用运行时间速度换取代码大小的情况下，要进行剖析和测量，以做出一个明智的决定，确定这种交易是否值得。</p>
<h3 id="使用链接时间优化lto进行编译"><a class="header" href="#使用链接时间优化lto进行编译">使用链接时间优化（LTO）进行编译</a></h3>
<p>在<code>Cargo.toml</code>中，在<code>[profile.release]</code>部分添加<code>lto = true</code>：</p>
<pre><code class="language-toml">[profile.release]
lto = true
</code></pre>
<p>这给了LLVM更多的机会来内联和修剪函数。这不仅会使<code>.wasm</code>更小，而且会使它在运行时更快！缺点是编译时间更长。缺点是编译时间会更长。</p>
<h3 id="告诉llvm对大小而不是速度进行优化"><a class="header" href="#告诉llvm对大小而不是速度进行优化">告诉LLVM对大小而不是速度进行优化</a></h3>
<p>LLVM的优化通道被调整为提高速度，而不是默认的大小。我们可以通过修改<code>Cargo.toml</code>中的<code>[profile.release]</code>部分，将目标改为代码大小：</p>
<pre><code class="language-toml">[profile.release]
opt-level = 's'
</code></pre>
<p>或者，更积极地优化尺寸，以进一步的潜在速度成本：</p>
<pre><code class="language-toml">[profile.release]
opt-level = 'z'
</code></pre>
<p>请注意，令人惊讶的是，<code>opt-level = &quot;s&quot;</code> 有时会产生比 <code>opt-level = &quot;z&quot;</code> 更小的二进制文件。 经常测量！ </p>
<h3 id="使用-wasm-opt-工具"><a class="header" href="#使用-wasm-opt-工具">使用 <code>wasm-opt</code> 工具</a></h3>
<p><a href="https://github.com/WebAssembly/binaryen">Binaryen</a> 工具包是一组特定于 WebAssembly 的编译器工具。 它比 LLVM 的 WebAssembly 后端走得更远，使用它的 <code>wasm-opt</code> 工具对 LLVM 生成的 <code>.wasm</code> 二进制文件进行后处理，通常可以再节省 15-20% 的代码大小。 它通常会同时产生运行时加速！</p>
<pre><code class="language-bash"># Optimize for size.
wasm-opt -Os -o output.wasm input.wasm

# Optimize aggressively for size.
wasm-opt -Oz -o output.wasm input.wasm

# Optimize for speed.
wasm-opt -O -o output.wasm input.wasm

# Optimize aggressively for speed.
wasm-opt -O3 -o output.wasm input.wasm
</code></pre>
<h3 id="关于调试信息的注意事项"><a class="header" href="#关于调试信息的注意事项">关于调试信息的注意事项</a></h3>
<p>wasm 二进制文件大小的最大贡献者之一可能是调试信息和 wasm 二进制文件的“名称”部分。 然而，<code>wasm-pack</code> 工具默认会删除 debuginfo。 此外，除非还指定了 <code>-g</code>，否则 <code>wasm-opt</code> 会默认删除 <code>names</code> 部分。</p>
<p>这意味着，如果您按照上述步骤操作，则默认情况下，wasm 二进制文件中不应有 debuginfo 或 names 部分。 但是，如果您手动以其他方式在 wasm 二进制文件中保留此调试信息，请务必注意这一点！</p>
<h2 id="尺寸分析"><a class="header" href="#尺寸分析">尺寸分析</a></h2>
<p>如果调整构建配置以优化代码大小并没有产生足够小的 <code>.wasm</code> 二进制文件，那么是时候进行一些分析以查看剩余代码大小的来源。</p>
<blockquote>
<p>⚡ 就像我们如何让时间分析指导我们加速工作一样，我们希望让大小分析指导我们的代码大小缩减工作。
如果不这样做，您可能会浪费自己的时间！ </p>
</blockquote>
<h3 id="twiggy-代码大小分析器"><a class="header" href="#twiggy-代码大小分析器"><code>twiggy</code> 代码大小分析器</a></h3>
<p><a href="https://github.com/rustwasm/twiggy"><code>twiggy</code> 是一个代码大小分析器</a> 支持 WebAssembly 作为输入。 它分析二进制的调用图来回答以下问题：</p>
<ul>
<li>
<p>为什么这个函数首先包含在二进制文件中？</p>
</li>
<li>
<p>这个函数的<em>保留大小</em>是多少？ 即 如果我删除它以及删除后成为死代码的所有函数，会节省多少空间？ </p>
</li>
</ul>
<style>
/* For whatever reason, the default mdbook fonts fonts break with the
   following box-drawing characters, hence the manual style. */
pre, code {
  font-family: "SFMono-Regular",Consolas,"Liberation Mono",Menlo,Courier,monospace;
}
</style>
<pre><code class="language-text">$ twiggy top -n 20 pkg/wasm_game_of_life_bg.wasm
 Shallow Bytes │ Shallow % │ Item
───────────────┼───────────┼────────────────────────────────────────────────────────────────────────────────────────
          9158 ┊    19.65% ┊ &quot;function names&quot; subsection
          3251 ┊     6.98% ┊ dlmalloc::dlmalloc::Dlmalloc::malloc::h632d10c184fef6e8
          2510 ┊     5.39% ┊ &lt;str as core::fmt::Debug&gt;::fmt::he0d87479d1c208ea
          1737 ┊     3.73% ┊ data[0]
          1574 ┊     3.38% ┊ data[3]
          1524 ┊     3.27% ┊ core::fmt::Formatter::pad::h6825605b326ea2c5
          1413 ┊     3.03% ┊ std::panicking::rust_panic_with_hook::h1d3660f2e339513d
          1200 ┊     2.57% ┊ core::fmt::Formatter::pad_integral::h06996c5859a57ced
          1131 ┊     2.43% ┊ core::str::slice_error_fail::h6da90c14857ae01b
          1051 ┊     2.26% ┊ core::fmt::write::h03ff8c7a2f3a9605
           931 ┊     2.00% ┊ data[4]
           864 ┊     1.85% ┊ dlmalloc::dlmalloc::Dlmalloc::free::h27b781e3b06bdb05
           841 ┊     1.80% ┊ &lt;char as core::fmt::Debug&gt;::fmt::h07742d9f4a8c56f2
           813 ┊     1.74% ┊ __rust_realloc
           708 ┊     1.52% ┊ core::slice::memchr::memchr::h6243a1b2885fdb85
           678 ┊     1.45% ┊ &lt;core::fmt::builders::PadAdapter&lt;'a&gt; as core::fmt::Write&gt;::write_str::h96b72fb7457d3062
           631 ┊     1.35% ┊ universe_tick
           631 ┊     1.35% ┊ dlmalloc::dlmalloc::Dlmalloc::dispose_chunk::hae6c5c8634e575b8
           514 ┊     1.10% ┊ std::panicking::default_hook::{{closure}}::hfae0c204085471d5
           503 ┊     1.08% ┊ &lt;&amp;'a T as core::fmt::Debug&gt;::fmt::hba207e4f7abaece6
</code></pre>
<h3 id="手动检查-llvm-ir"><a class="header" href="#手动检查-llvm-ir">手动检查 LLVM-IR</a></h3>
<p>在 LLVM 生成 WebAssembly 之前，LLVM-IR 是编译器工具链中的最终中间表示。 因此，它与最终发出的 WebAssembly 非常相似。 更多的 LLVM-IR 通常意味着更多的 <code>.wasm</code> 大小，如果一个函数占用 LLVM-IR 的 25%，那么它通常会占用 <code>.wasm</code> 的 25%。 虽然这些数字仅适用于一般情况，但 LLVM-IR 具有在 <code>.wasm</code> 中不存在的关键信息（因为 WebAssembly 缺乏像 DWARF 这样的调试格式）：哪些子例程被内联到给定的函数中。</p>
<p>您可以使用以下 <code>cargo</code> 命令生成 LLVM-IR：</p>
<pre><code>cargo rustc --release -- --emit llvm-ir
</code></pre>
<p>然后，您可以使用 <code>find</code> 在 <code>cargo</code> 的 <code>target</code> 目录中定位包含 LLVM-IR 的 <code>.ll</code> 文件：</p>
<pre><code>find target/release -type f -name '*.ll'
</code></pre>
<h4 id="参考-2"><a class="header" href="#参考-2">参考</a></h4>
<ul>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM 语言参考手册</a></li>
</ul>
<h2 id="更具侵入性的工具和技术"><a class="header" href="#更具侵入性的工具和技术">更具侵入性的工具和技术</a></h2>
<p>调整构建配置以获得更小的 <code>.wasm</code> 二进制文件是非常容易的。然而，当你需要走更多的路时，你要准备使用更多的侵入性技术，比如重写源代码以避免臃肿。下面是一系列 &quot;动手 &quot;的技术，你可以应用这些技术来获得更小的代码大小。</p>
<h3 id="避免字符串格式化"><a class="header" href="#避免字符串格式化">避免字符串格式化</a></h3>
<p><code>format!</code>, <code>to_string</code>, 等等...会带来大量的代码膨胀。如果可能的话，只在调试模式下进行字符串格式化，而在发布模式下使用静态字符串。</p>
<h3 id="避免-panicking"><a class="header" href="#避免-panicking">避免 Panicking</a></h3>
<p>这绝对是说起来容易做起来难，但是像 <code>twiggy</code> 和手动检查 LLVM-IR 这样的工具可以帮助你找出哪些函数是恐慌的。</p>
<p>Panics 并不总是以<code>panic!()</code> 宏调用的形式出现。 它们隐含地来自许多结构，例如：</p>
<ul>
<li>
<p>索引切片在越界索引时发生 panics：<code>my_slice[i]</code></p>
</li>
<li>
<p>如果除数为零，除法会 panic：<code>dividend / divisor</code></p>
</li>
<li>
<p>解开<code>Option</code> 或<code>Result</code>：<code>opt.unwrap()</code> 或<code>res.unwrap()</code></p>
</li>
</ul>
<p>前两个可以翻译成第三个。 索引可以替换为容易出错的 <code>my_slice.get(i)</code> 操作。 除法可以用<code>checked_div</code> 调用代替。 现在我们只有一个案例要处理。</p>
<p>在不惊慌的情况下展开 <code>Option</code> 或 <code>Result</code> 有两种方式：安全和不安全。</p>
<p>安全的方法是在遇到 <code>None</code> 或 <code>Error</code> 时使用 <code>abort</code> 而不是 panicking： </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
pub fn unwrap_abort&lt;T&gt;(o: Option&lt;T&gt;) -&gt; T {
    use std::process;
    match o {
        Some(t) =&gt; t,
        None =&gt; process::abort(),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>最终，无论如何，恐慌都会转化为 <code>wasm32-unknown-unknown</code> 中的中止，所以这会给你相同的行为，但没有代码膨胀。</p>
<p>或者，<a href="https://crates.io/crates/unreachable"><code>unreachable</code> crate</a> 为 <code>Option</code> 和 <code>Result</code> 提供了一个不安全的 <a href="https://docs.rs/unreachable/1.0.0/unreachable/trait.UncheckedOptionExt.html#tymethod.unchecked_unwrap"><code>unchecked_unwrap</code> 扩展方法</a>，它告诉 Rust 编译器<em>假设</em><code>Option</code> 是<code>Some </code> 或 <code>Result</code> 是 <code>Ok</code>。 如果该假设不成立，会发生什么情况是未定义的行为。 当您 110% <em>知道</em>假设成立时，您真的只想使用这种不安全的方法，而编译器不够聪明，无法看到它。 即使你走这条路，你应该有一个仍然进行检查的调试构建配置，并且只在发布构建中使用未经检查的操作。</p>
<h3 id="避免分配或切换到-wee_alloc"><a class="header" href="#避免分配或切换到-wee_alloc">避免分配或切换到 <code>wee_alloc</code></a></h3>
<p>Rust 的 WebAssembly 的默认分配器是 <code>dlmalloc</code> 到 Rust 的端口。 它的重量约为 10 KB。 如果您可以完全避免动态分配，那么您应该能够摆脱这十 KB。</p>
<p>完全避免动态分配可能非常困难。 但是从热代码路径中删除分配通常要容易得多（并且通常也有助于使这些热代码路径更快）。 在这些情况下，<a href="https://github.com/rustwasm/wee_alloc">用 <code>wee_alloc</code> 替换默认的全局分配器</a> 应该为您节省这十 KB 中的大部分（但不是全部）。 <code>wee_alloc</code> 是一个分配器，专为您需要<em>某种</em>类型的分配器但不需要特别快的分配器的情况而设计，并且很乐意用分配速度换取较小的代码大小。</p>
<h3 id="使用特征对象而不是泛型类型参数"><a class="header" href="#使用特征对象而不是泛型类型参数">使用特征对象而不是泛型类型参数</a></h3>
<p>当您创建使用类型参数的泛型函数时，如下所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whatever&lt;T: MyTrait&gt;(t: T) { ... }
<span class="boring">}
</span></code></pre></pre>
<p>然后 <code>rustc</code> 和 LLVM 将为使用该函数的每个 <code>T</code> 类型创建该函数的新副本。 这为基于每个副本所使用的特定“T”提供了许多编译器优化机会，但这些副本在代码大小方面加起来很快。</p>
<p>如果你使用 trait 对象而不是类型参数，像这样：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn whatever(t: Box&lt;MyTrait&gt;) { ... }
// or
fn whatever(t: &amp;MyTrait) { ... }
// etc...
<span class="boring">}
</span></code></pre></pre>
<p>然后使用通过虚拟调用的动态调度，并且在 <code>.wasm</code> 中只发出该函数的一个版本。 缺点是失去了编译器优化机会以及间接、动态调度的函数调用的额外成本。</p>
<h3 id="使用-wasm-snip-工具"><a class="header" href="#使用-wasm-snip-工具">使用 wasm-snip 工具</a></h3>
<p><a href="https://github.com/fitzgen/wasm-snip"><code>wasm-snip</code>用<code>unreachable</code>指令替换WebAssembly函数的主体。</a>这是一个相当重的、钝的锤子，用于那些看起来像钉子的函数，如果你足够努力地眯着眼睛。</p>
<p>也许你知道某些函数在运行时不会被调用，但编译器在编译时无法证明这一点？把它剪掉吧! 之后，再次运行 <code>wasm-opt</code> 并加上 <code>--dce</code> 标志，所有被剪掉的函数所调用的函数（这些函数在运行时也不可能被调用）也会被删除。</p>
<p>这个工具对于删除恐慌的基础结构特别有用，因为无论如何，恐慌最终都会转化为陷阱。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-互操作"><a class="header" href="#javascript-互操作">JavaScript 互操作</a></h1>
<h2 id="导入和导出-js-函数"><a class="header" href="#导入和导出-js-函数">导入和导出 JS 函数</a></h2>
<h3 id="从-rust-方面"><a class="header" href="#从-rust-方面">从 Rust 方面</a></h3>
<p>在 JS 主机中使用 wasm 时，从 Rust 端导入和导出函数很简单：它的工作方式与 C 非常相似。</p>
<p>WebAssembly 模块声明了一系列导入，每个导入都有一个 <em>module name</em> 和一个 <em>import name</em>。 <code>extern { ... }</code> 块的模块名称可以使用 <a href="https://github.com/rust-lang/rust/issues/52090"><code>#[link(wasm_import_module)]</code></a> 指定，目前它默认为“env”。</p>
<p>出口只有一个名称。 除了任何 <code>extern</code> 函数，WebAssembly 实例的默认线性内存被导出为“内存”。 </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// import a JS function called `foo` from the module `mod`
#[link(wasm_import_module = &quot;mod&quot;)]
extern { fn foo(); }

// export a Rust function called `bar`
#[no_mangle]
pub extern fn bar() { /* ... */ }
<span class="boring">}
</span></code></pre></pre>
<p>由于 wasm 的值类型有限，这些函数必须仅对原始数字类型进行操作。</p>
<h3 id="从js端"><a class="header" href="#从js端">从JS端</a></h3>
<p>在 JS 中，wasm 二进制文件变成了 ES6 模块。 它必须使用线性内存<em>实例化</em>，并具有一组匹配预期导入的 JS 函数。 实例化的详细信息可在 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming">MDN</a> 上找到。 </p>
<p>生成的 ES6 模块将包含从 Rust 导出的所有函数，现在可以作为 JS 函数使用。</p>
<p>[这里][hello world] 是整个设置的一个非常简单的示例。 </p>
<h2 id="超越数字"><a class="header" href="#超越数字">超越数字</a></h2>
<p>在 JS 中使用 wasm 时，wasm 模块的内存和 JS 内存之间存在明显的分裂：</p>
<ul>
<li>
<p>每个 wasm 模块都有一个线性内存（在本文档的顶部描述），在实例化期间进行初始化。 <strong>JS 代码可以自由读写这块内存</strong>。</p>
</li>
<li>
<p>相比之下，wasm 代码不能<em>直接</em>访问 JS 对象。</p>
</li>
</ul>
<p>因此，复杂的互操作以两种主要方式发生：</p>
<ul>
<li>
<p>将二进制数据复制到或复制到 wasm 内存。 例如，这是向 Rust 端提供拥有的 <code>String</code> 的一种方式。</p>
</li>
<li>
<p>建立一个显式的 JS 对象“堆”，然后给定“地址”。 这允许 wasm 代码间接引用 JS 对象（使用整数），并通过调用导入的 JS 函数对这些对象进行操作。</p>
</li>
</ul>
<p>幸运的是，这个互操作的故事非常适合通过一个通用的“bindgen”风格的框架来处理：<a href="https://github.com/rustwasm/wasm-bindgen">wasm-bindgen</a>。 该框架可以编写自动映射到惯用 JS 函数的惯用 Rust 函数签名。</p>
<h2 id="自定义部分"><a class="header" href="#自定义部分">自定义部分</a></h2>
<p>自定义部分允许将命名的任意数据嵌入到 wasm 模块中。 段数据在编译时设置并直接从 wasm 模块读取，不能在运行时修改。</p>
<p>在 Rust 中，自定义节是使用 <code>#[link_section]</code> 属性公开的静态数组（<code>[T; size]</code>）：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link_section = &quot;hello&quot;]
pub static SECTION: [u8; 24] = *b&quot;This is a custom section&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>这会在 wasm 文件中添加一个名为 <code>hello</code> 的自定义部分，rust 变量名称 <code>SECTION</code> 是任意的，更改它不会改变行为。 这里的内容是文本字节，但可以是任何任意数据。</p>
<p>自定义部分可以在 JS 端使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module/customSections"><code>WebAssembly.Module.customSections</code></a> 函数读取，它接受一个 wasm 模块和部分名称作为参数，并返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code></a> 数组。 可以使用相同的名称指定多个部分，在这种情况下，它们都将出现在此数组中。</p>
<pre><code class="language-js">WebAssembly.compileStreaming(fetch(&quot;sections.wasm&quot;))
.then(mod =&gt; {
  const sections = WebAssembly.Module.customSections(mod, &quot;hello&quot;);

  const decoder = new TextDecoder();
  const text = decoder.decode(sections[0]);

  console.log(text); // -&gt; &quot;This is a custom section&quot;
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="哪些板块能与webassembly一起使用现成的产品"><a class="header" href="#哪些板块能与webassembly一起使用现成的产品">哪些板块能与WebAssembly一起使用现成的产品?</a></h1>
<p>最简单的方法是列出目前不能与WebAssembly一起使用的东西；避免这些东西的crack往往可以移植到WebAssembly上，并且通常<em>Just Work</em>。一个好的经验法则是，如果一个板块支持嵌入式和 <code>#![no_std]</code> 的使用，它可能也支持WebAssembly。</p>
<h2 id="一个板块可能会做的事情不会与webassembly一起工作"><a class="header" href="#一个板块可能会做的事情不会与webassembly一起工作">一个板块可能会做的事情，不会与WebAssembly一起工作。</a></h2>
<h3 id="c和系统库的依赖性"><a class="header" href="#c和系统库的依赖性">C和系统库的依赖性</a></h3>
<p>wasm中没有系统库，所以任何试图与系统库绑定的crate都不会工作。</p>
<p>使用C库也可能无法工作，因为wasm没有一个稳定的ABI用于跨语言通信，而且wasm的跨语言链接非常不稳定。每个人都希望这最终能起作用，特别是由于<code>clang</code>现在已经默认发送他们的<code>wasm32</code>目标，但故事还没有完全结束。</p>
<h3 id="文件io"><a class="header" href="#文件io">文件I/O</a></h3>
<p>WebAssembly没有访问文件系统的权限，所以假设文件系统存在的crates — 没有针对WASM的解决方法 — 将不工作。</p>
<h3 id="生成线程"><a class="header" href="#生成线程">生成线程</a></h3>
<p>有<a href="https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html">计划将线程添加到WebAssembly</a>，但它还没有发货。试图在 <code>wasm32-unknown-unknown</code>  目标上的线程上生成，会引起恐慌，从而触发wasm陷阱。</p>
<h2 id="那么哪些通用工具箱倾向于与webassembly一起工作"><a class="header" href="#那么哪些通用工具箱倾向于与webassembly一起工作">那么，哪些通用工具箱倾向于与WebAssembly一起工作？</a></h2>
<h3 id="算法和数据结构"><a class="header" href="#算法和数据结构">算法和数据结构</a></h3>
<p>提供特定<a href="https://crates.io/categories/algorithms">算法</a>或<a href="https://crates.io/categories/data-structures">数据结构</a>实现的板块，例如A*图搜索或splay树，往往能与WebAssembly很好地配合。</p>
<h3 id="no_std"><a class="header" href="#no_std"><code>#![no_std]</code></a></h3>
<p><a href="https://crates.io/categories/no-std">不依赖于标准库的 crates</a> 往往与 WebAssembly 配合得很好。</p>
<h3 id="解析器"><a class="header" href="#解析器">解析器</a></h3>
<p><a href="https://crates.io/categories/parser-implementations">解析器</a> — 只要他们只接受输入而不执行自己的 I/O  — 倾向于与 WebAssembly 配合使用。 </p>
<h3 id="文本处理"><a class="header" href="#文本处理">文本处理</a></h3>
<p><a href="https://crates.io/categories/text-processing">以文本形式表达时处理人类语言复杂性的Crates</a> 倾向于与 WebAssembly 配合使用。</p>
<h3 id="rust-模式"><a class="header" href="#rust-模式">Rust 模式</a></h3>
<p><a href="https://crates.io/categories/rust-patterns">针对特定于 Rust 编程的特定情况的共享解决方案</a> 倾向于与 WebAssembly 配合使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="如何为通用crate添加-webassembly-支持"><a class="header" href="#如何为通用crate添加-webassembly-支持">如何为通用Crate添加 WebAssembly 支持</a></h1>
<p>本节适用于想要支持 WebAssembly 的通用 crate 作者。</p>
<h2 id="也许你的-crate-已经支持-webassembly"><a class="header" href="#也许你的-crate-已经支持-webassembly">也许你的 Crate 已经支持 WebAssembly！</a></h2>
<p>查看有关 <a href="reference/./which-crates-work-with-wasm.html">什么样的东西可以使 WebAssembly 的通用 crate <em>不可移植</em></a> 的信息。 如果您的 crate 没有这些东西，它可能已经支持 WebAssembly！</p>
<p>您始终可以通过为 WebAssembly 目标运行 <code>cargo build</code> 来检查： </p>
<pre><code>cargo build --target wasm32-unknown-unknown
</code></pre>
<p>如果该命令失败，那么您的 crate 现在不支持 WebAssembly。 如果它没有失败，那么你的箱子 * 可能 * 支持 WebAssembly。 您可以通过 <a href="reference/add-wasm-support-to-crate.html#%E7%BB%B4%E6%8A%A4%E5%AF%B9-webassembly-%E7%9A%84%E6%8C%81%E7%BB%AD%E6%94%AF%E6%8C%81">为 wasm 添加测试并在 CI 中运行这些测试</a>来 100% 确定它会（并继续这样做！） </p>
<h2 id="添加对-webassembly-的支持"><a class="header" href="#添加对-webassembly-的支持">添加对 WebAssembly 的支持</a></h2>
<h3 id="避免直接执行-io"><a class="header" href="#避免直接执行-io">避免直接执行 I/O</a></h3>
<p>在 Web 上，I/O 始终是异步的，并且没有文件系统。 将 I/O 排除在您的库之外，让用户执行 I/O，然后将输入切片传递给您的库。</p>
<p>例如，重构这个：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::path::Path;

pub fn parse_thing(path: &amp;Path) -&gt; Result&lt;MyThing, MyError&gt; {
    let contents = fs::read(path)?;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>进入这个：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse_thing(contents: &amp;[u8]) -&gt; Result&lt;MyThing, MyError&gt; {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="添加-wasm-bindgen-作为依赖"><a class="header" href="#添加-wasm-bindgen-作为依赖">添加 <code>wasm-bindgen</code> 作为依赖</a></h3>
<p>如果您需要与外部世界交互（即您不能让图书馆消费者为您驱动该交互），那么您需要添加 <code>wasm-bindgen</code>（以及 <code>js-sys</code> 和 <code>web-sys</code>，如果 您需要它们）作为编译针对 WebAssembly 时的依赖项：</p>
<pre><code class="language-toml">[target.'cfg(target_arch = &quot;wasm32&quot;)'.dependencies]
wasm-bindgen = &quot;0.2&quot;
js-sys = &quot;0.3&quot;
web-sys = &quot;0.3&quot;
</code></pre>
<h3 id="避免同步-io"><a class="header" href="#避免同步-io">避免同步 I/O</a></h3>
<p>如果您必须在库中执行 I/O，则它不能是同步的。 Web 上只有异步 I/O。 使用 <a href="https://crates.io/crates/futures"><code>futures</code> 包</a> 和 [<code>wasm-bindgen-futures</code> 包]((https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen_futures/) 来管理异步 I/O。 如果您的库函数在某个未来类型 <code>F</code> 上是通用的，那么该未来可以通过 Web 上的 <code>fetch</code> 或通过操作系统提供的非阻塞 I/O 来实现。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn do_stuff&lt;F&gt;(future: F) -&gt; impl Future&lt;Item = MyOtherThing&gt;
where
    F: Future&lt;Item = MyThing&gt;,
{
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>您还可以为 WebAssembly 和 Web 以及本机目标定义一个特征并实现它：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ReadMyThing {
    type F: Future&lt;Item = MyThing&gt;;
    fn read(&amp;self) -&gt; Self::F;
}

#[cfg(target_arch = &quot;wasm32&quot;)]
struct WebReadMyThing {
    // ...
}

#[cfg(target_arch = &quot;wasm32&quot;)]
impl ReadMyThing for WebReadMyThing {
    // ...
}

#[cfg(not(target_arch = &quot;wasm32&quot;))]
struct NativeReadMyThing {
    // ...
}

#[cfg(not(target_arch = &quot;wasm32&quot;))]
impl ReadMyThing for NativeReadMyThing {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="避免产生线程"><a class="header" href="#避免产生线程">避免产生线程</a></h3>
<p>Wasm 尚不支持线程（但 <a href="https://rustwasm.github.io/2018/10/24/multithreading-rust-and-wasm.html">实验工作正在进行</a>），因此尝试在 wasm 会恐慌。</p>
<p>您可以使用<code>#[cfg(..)]</code>s 来启用线程和非线程代码路径，具体取决于目标是否为 WebAssembly：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>#![cfg(target_arch = &quot;wasm32&quot;)]
<span class="boring">fn main() {
</span>fn do_work() {
    // Do work with only this thread...
}

#![cfg(not(target_arch = &quot;wasm32&quot;))]
fn do_work() {
    use std::thread;

    // Spread work to helper threads....
    thread::spawn(|| {
        // ...
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>另一种选择是从您的库中提取线程，并允许用户“自带线程”，类似于提取文件 I/O 并允许用户自带 I/O。 这具有与想要拥有自己的自定义线程池的应用程序配合良好的副作用。 </p>
<h2 id="维护对-webassembly-的持续支持"><a class="header" href="#维护对-webassembly-的持续支持">维护对 WebAssembly 的持续支持</a></h2>
<h3 id="在-ci-中构建-wasm32-unknown-unknown"><a class="header" href="#在-ci-中构建-wasm32-unknown-unknown">在 CI 中构建 <code>wasm32-unknown-unknown</code></a></h3>
<p>通过让您的 CI 脚本运行以下命令，确保在针对 WebAssembly 时编译不会失败：</p>
<pre><code>rustup target add wasm32-unknown-unknown
cargo check --target wasm32-unknown-unknown
</code></pre>
<p>例如，您可以将其添加到 Travis CI 的 <code>.travis.yml</code> 配置中：</p>
<pre><code class="language-yaml">
matrix:
  include:
    - language: rust
      rust: stable
      name: &quot;check wasm32 support&quot;
      install: rustup target add wasm32-unknown-unknown
      script: cargo check --target wasm32-unknown-unknown
</code></pre>
<h3 id="在-nodejs-和无头浏览器中进行测试"><a class="header" href="#在-nodejs-和无头浏览器中进行测试">在 Node.js 和无头浏览器中进行测试</a></h3>
<p>您可以使用 <code>wasm-bindgen-test</code> 和 <code>wasm-pack test</code> 子命令在 Node.js 或无头浏览器中运行 wasmntests。 您甚至可以将这些测试集成到您的 CI 中。</p>
<p><a href="https://rustwasm.github.io/wasm-bindgen/wasm-bindgen-test/index.html">在此处了解有关测试 wasm 的更多信息。</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="将-rust-和-webassembly-部署到生产环境"><a class="header" href="#将-rust-和-webassembly-部署到生产环境">将 Rust 和 WebAssembly 部署到生产环境</a></h1>
<blockquote>
<p><strong>⚡ 部署使用 Rust 和 WebAssembly 构建的 Web 应用程序几乎与部署任何其他 Web 应用程序相同！</strong></p>
</blockquote>
<p>要在客户端部署使用 Rust 生成的 WebAssembly 的 Web 应用程序，请将构建的 Web 应用程序的文件复制到您的生产服务器的文件系统，并配置您的 HTTP 服务器以使其可访问。</p>
<h2 id="确保您的-http-服务器使用-applicationwasm-mime-类型"><a class="header" href="#确保您的-http-服务器使用-applicationwasm-mime-类型">确保您的 HTTP 服务器使用 <code>application/wasm</code> MIME 类型</a></h2>
<p>为了最快的页面加载，您需要使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/instantiateStreaming"><code>WebAssembly.instantiateStreaming</code> 函数</a> 通过网络传输管道化 wasm 编译和实例化（或确保您的捆绑器能够使用该函数）。 但是，<code>instantiateStreaming</code> 要求 HTTP 响应设置了 <code>application/wasm</code> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 类型</a>，否则会抛出错误。 </p>
<ul>
<li><a href="https://httpd.apache.org/docs/2.4/mod/mod_mime.html#addtype">如何为 Apache HTTP 服务器配置 MIME 类型</a></li>
<li><a href="https://nginx.org/en/docs/http/ngx_http_core_module.html#types">如何为 NGINX HTTP 服务器配置 MIME 类型</a></li>
</ul>
<h2 id="更多资源"><a class="header" href="#更多资源">更多资源</a></h2>
<ul>
<li><a href="https://webpack.js.org/guides/production/">生产中 Webpack 的最佳实践。</a> 许多 Rust 和 WebAssembly 项目使用 Webpack 来捆绑其 Rust 生成的 WebAssembly、JavaScript、CSS 和 HTML。 本指南提供了在部署到生产环境时充分利用 Webpack 的技巧。</li>
<li><a href="https://httpd.apache.org/docs/">Apache 文档。</a> Apache 是一种用于生产的流行 HTTP 服务器。</li>
<li><a href="https://docs.nginx.com/nginx/admin-guide/installing-nginx/installing-nginx-open-source/">NGINX 文档。</a> NGINX 是一种用于生产的流行 HTTP 服务器。</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
